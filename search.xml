<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo笔记</title>
    <url>/2024/06/14/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is my very first post.</p>
<h1 id="Butterfly练手开始"><a href="#Butterfly练手开始" class="headerlink" title="Butterfly练手开始"></a>Butterfly练手开始</h1><h3 id="1-flink测试"><a href="#1-flink测试" class="headerlink" title="1.flink测试"></a>1.flink测试</h3><div class="flink"><div class="flink-name">网站分享</div><div class="flink-desc">每天看看热门</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://www.bilibili.com/" title="B站" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://picture.gptkong.com/20240623/00359179d42155465fb0f79c3e4e0f7773.jpg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="B站" />
              </div>
              <div class="flink-item-name">B站</div> 
              <div class="flink-item-desc" title="今日热门,今日刷">今日热门,今日刷</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://www.douyin.com/" title="抖音" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://picture.gptkong.com/20240623/003781588bc3794a058a2209d1ada63a0a.jpg" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="抖音" />
              </div>
              <div class="flink-item-name">抖音</div> 
              <div class="flink-item-desc" title="每天看看沙雕">每天看看沙雕</div>
            </a>
          </div></div><div class="flink-name">功能网站</div><div class="flink-desc">有空看看呗</div> <div class="flink-list">
          <div class="flink-list-item">
            <a href="https://www.gptkong.com/tools/image_to_link" title="图像转网络链接" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://picture.gptkong.com/20240618/16527145e5c86d419092d0637b2069c668.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="图像转网络链接" />
              </div>
              <div class="flink-item-name">图像转网络链接</div> 
              <div class="flink-item-desc" title="在线把本地图片转成网络图片">在线把本地图片转成网络图片</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://www.weibo.com/" title="微博" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="微博" />
              </div>
              <div class="flink-item-name">微博</div> 
              <div class="flink-item-desc" title="女厕所">女厕所</div>
            </a>
          </div>
          <div class="flink-list-item">
            <a href="https://twitter.com/" title="Twitter" target="_blank">
              <div class="flink-item-icon">
                <img class="no-lightbox" src="https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png" onerror='this.onerror=null;this.src="/img/friend_404.gif"' alt="Twitter" />
              </div>
              <div class="flink-item-name">Twitter</div> 
              <div class="flink-item-desc" title="社交分享平台">社交分享平台</div>
            </a>
          </div></div></div>

<h3 id="详细文档参考"><a href="#详细文档参考" class="headerlink" title="详细文档参考"></a>详细文档参考</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://butterfly.zhheo.com/create.html</span><br></pre></td></tr></table></figure>

<p>非常良心</p>
<h3 id="文字添加颜色"><a href="#文字添加颜色" class="headerlink" title="文字添加颜色"></a>文字添加颜色</h3><p>使用&lt;注释font color&#x3D;十六进制颜色代码&gt;  和     &lt;&#x2F;font注释&gt; 把要改颜色的字体夹住（copy记得把注释删掉）</p>
<p><font color=#00ffff size=3>浅蓝色好看捏</font></p>
<p><font color=#aa8aaa size=7>还可以空格+size&#x3D;1&#x2F;2&#x2F;3&#x2F;……调整大小</font></p>
<h3 id="后续慢慢修改主题文件配置即可添加或者删除功能"><a href="#后续慢慢修改主题文件配置即可添加或者删除功能" class="headerlink" title="后续慢慢修改主题文件配置即可添加或者删除功能"></a>后续慢慢修改主题文件配置即可添加或者删除功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">推荐上面的详细文档参考</span><br></pre></td></tr></table></figure>

<h1 id="Hexo的BUG解决方案"><a href="#Hexo的BUG解决方案" class="headerlink" title="Hexo的BUG解决方案"></a>Hexo的BUG解决方案</h1><h2 id="0-每次启动前要连接ssh"><a href="#0-每次启动前要连接ssh" class="headerlink" title="0.每次启动前要连接ssh"></a>0.每次启动前要连接ssh</h2><p>一般隔一段时间不用电脑，就需要：输入ssh -T <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;</a>或者ssh -T -p 443 <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x73;&#x73;&#104;&#46;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x69;&#x74;&#x40;&#x73;&#x73;&#104;&#46;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#x6f;&#109;</a>连接一次就行。</p>
<h2 id="1-hexo-init或者git-init-失败"><a href="#1-hexo-init或者git-init-失败" class="headerlink" title="1.hexo init或者git init 失败"></a>1.hexo init或者git init 失败</h2><p>就是没有配置环境，自己去网上找一找，在path处添加路径</p>
<h2 id="2-ssh链接不上"><a href="#2-ssh链接不上" class="headerlink" title="2.ssh链接不上"></a>2.ssh链接不上</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台显示 ssh: connect to host gitee.com port 22: Connection timed out</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">ssh -T -p 443 git@ssh.github.com</span><br><span class="line"># -p 443表示使用443端口，要是443也被占用，也可以尝试其他端口</span><br><span class="line">然后再输入ssh -T git@github.com就行了</span><br></pre></td></tr></table></figure>

<p>或者是你ssh需要重新设置一个新的。</p>
<p>这样你ssh配置几乎没问题的。</p>
<h2 id="3-页面布局杂乱"><a href="#3-页面布局杂乱" class="headerlink" title="3.页面布局杂乱"></a>3.页面布局杂乱</h2><p>特点：本地部署没问题，部署到线上就乱了，布局&#x3D;0</p>
<p>原因：博客文件夹下的config中的url设置错误-&gt;css&#x2F;js的资源没有加载到github上</p>
<p>解决方案：</p>
<p>正确的url: <a href="https://zenfy0326.github.io/">https://zenfy0326.github.io</a></p>
<p>或者是你的仓库名不是你github名字.github.io，而是设置成了bolg.github.io等等，这是不行的。</p>
<h2 id="4-页面显示404"><a href="#4-页面显示404" class="headerlink" title="4.页面显示404"></a>4.页面显示404</h2><p>你仓库的setting-pages-Branch设置选择mian或者其他分支，不知道选哪个就main分支咯，记得save保存。</p>
<h2 id="5-git提示“warning-LF-will-be-replaced-by-CRLF”"><a href="#5-git提示“warning-LF-will-be-replaced-by-CRLF”" class="headerlink" title="5.git提示“warning: LF will be replaced by CRLF”"></a>5.git提示“warning: LF will be replaced by CRLF”</h2><p>windows用户在控制台输入这个就ok了</p>
<p>#提交检出均不转换<br>$ git config –global core.autocrlf false</p>
<h2 id="6-hexo配置404界面"><a href="#6-hexo配置404界面" class="headerlink" title="6.hexo配置404界面"></a>6.hexo配置404界面</h2><hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cover: true</span><br><span class="line">robots: noindex,nofollow</span><br><span class="line">sitemap: false</span><br><span class="line">seo_title: 404 Not Found</span><br><span class="line">bottom_meta: false</span><br><span class="line">sidebar: []</span><br><span class="line">twikoo:</span><br><span class="line">  path: /404.html</span><br><span class="line">  placeholder: 请留言告诉猴哥您要访问哪个页面找不到了</span><br><span class="line"></span><br><span class="line">&#123;% p logo center huge, 404 %&#125;</span><br><span class="line">&#123;% p center bold, 很抱歉，您访问的页面被狗吃了 %&#125;</span><br><span class="line">&#123;% p center small, 快去请齐天大圣！ %&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-怎么引入js-css文件"><a href="#7-怎么引入js-css文件" class="headerlink" title="7.怎么引入js&#x2F;css文件"></a>7.怎么引入js&#x2F;css文件</h2><p> 一般来说，我们都是在主题配置文件（<code>_config.butterfly.yml</code>）里面的<code>inject</code>引入。（不知道这个文件的去看文档）<br>css文件一般在<code>head</code>引入，js文件一般在<code>bottom</code>里引入，特殊情况除外。</p>
<p>例如引入css文件夹里面的<code>style.css</code>和js文件夹里面的<code>script.js</code>，可以这样写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    # 自定义css</span><br><span class="line">    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css?1&quot;&gt;</span><br><span class="line">    # 静态文件后面加个  ?任意内容  可以在每次更新之后用户自动重新请求.</span><br><span class="line">    # 例如添加 ?1 ,在修改此文件后改成 ?2 ,用户访问你的网站时,不会使用本地的缓存,而是请求新的内容。没修改的话就不用动。</span><br><span class="line">  bottom:</span><br><span class="line">    # 自定义js</span><br><span class="line">    - &lt;script src=&quot;/js/script.js?1&quot;&gt;&lt;/script&gt;</span><br><span class="line">    # 引入多个文件就直接往下复制一行改一下文件名即可，如下：</span><br><span class="line">    - &lt;script src=&quot;/js/script1.js?1&quot;&gt;&lt;/script&gt;</span><br><span class="line">    - &lt;script src=&quot;/js/script2.js?1&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="8-怎么禁用F12"><a href="#8-怎么禁用F12" class="headerlink" title="8.怎么禁用F12"></a>8.怎么禁用F12</h2><p>添加js文件输入以下代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">((function() &#123;var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return &#123;addListener: function(fn) &#123;callbacks.push(fn);&#125;,cancleListenr: function(fn) &#123;callbacks = callbacks.filter(function(v) &#123;return v !== fn;&#125;);&#125;&#125;</span><br><span class="line">function loop() &#123;var startTime = new Date();debugger;if (new Date() - startTime &gt; timeLimit) &#123;if (!open) &#123;callbacks.forEach(function(fn) &#123;fn.call(null);&#125;);&#125;open = true;window.stop();alert(&#x27;此处添加关掉调试时提示的文字&#x27;);document.body.innerHTML = &quot;&quot;;&#125; else &#123;open = false;&#125;&#125;&#125;)()).addListener(function() &#123;window.location.reload();&#125;);</span><br><span class="line"></span><br><span class="line">function toDevtools()&#123;</span><br><span class="line">  let num = 0;</span><br><span class="line">  let devtools = new Date();</span><br><span class="line">  devtools.toString = function() &#123;</span><br><span class="line">    num++;</span><br><span class="line">    if (num &gt; 1) &#123;</span><br><span class="line">        window.location.href = &quot;about:blank&quot;</span><br><span class="line">        blast();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;&#x27;, devtools);</span><br><span class="line">&#125;</span><br><span class="line">toDevtools();</span><br><span class="line"></span><br><span class="line">document.onkeydown = document.onkeyup = document.onkeydown = function(event) &#123;</span><br><span class="line">    var e = event || window.event || arguments.callee.caller.arguments[0];</span><br><span class="line">    if (e &amp;&amp; (e.keyCode == 123)) &#123;</span><br><span class="line">      e.keyCode = 0;</span><br><span class="line">      e.returnValue = false;</span><br><span class="line">      btf.snackbarShow(&#x27;此处添加按F12时提示的文字&#x27;);</span><br><span class="line">      return (false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$(document).keydown(function(e)&#123;</span><br><span class="line">  if( e.ctrlKey  == true &amp;&amp; e.keyCode == 83 )&#123;</span><br><span class="line">    console.log(&#x27;ctrl+s&#x27;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="9-图片链接失效"><a href="#9-图片链接失效" class="headerlink" title="9.图片链接失效"></a>9.图片链接失效</h2><p>在source文件夹下创建文件夹保存图片，然后在butterfly.config.yml文件中，把路径改成&#x2F;你新建的文件夹名字&#x2F;图片名称      即可，在md文件中引用图片需要添加两个..在&#x2F;之前。</p>
<p><img src="/../img/YuanShen.png"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C#笔记</title>
    <url>/2024/06/15/C-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-基本语法-上世纪國男"><a href="#C-基本语法-上世纪國男" class="headerlink" title="C#基本语法-上世纪國男"></a>C#基本语法-上世纪國男</h2><p>笔记</p>
<h2 id="基本的代码结构"><a href="#基本的代码结构" class="headerlink" title="基本的代码结构"></a>基本的代码结构</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;<span class="comment">//using 引入命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 中用于组织和声明一组相关的类、结构体、接口等的容器。命名空间有助于组织代码并避免命名冲突。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主函数。当程序启动时，将首先执行 Main 方法。</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">//书写我们的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基本的输出语句"><a href="#基本的输出语句" class="headerlink" title="基本的输出语句"></a>基本的输出语句</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//单行注释Crtl+K+C 取消Crtl+K+U</span></span><br><span class="line">            <span class="comment">//多行注释 /* */   推荐！！！</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//WriteLine,输出以后自动换行；</span></span><br><span class="line">            <span class="comment">//Console.WriteLine(&quot;Hello, World!&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Write,输出以后不会换行</span></span><br><span class="line">            <span class="comment">// Console.Write(&quot;Hello, World!&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（\n）或制表符 tab（\t）。在这里，列出一些转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">Alert 或 bell</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键（Backspace）</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符（Form feed）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符（Newline）</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符 tab</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符 tab</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<p>列如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\&#x27;hello \n  \\word!\&#x27;&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>byte b &#x3D; 255;</td>
<td>8 位无符号整数(0-255)</td>
</tr>
<tr>
<td>sbyte</td>
<td>sbyte sb &#x3D; -128;</td>
<td>8 位有符号整数(-255-255)</td>
</tr>
<tr>
<td>short</td>
<td>short s &#x3D; 32767;</td>
<td>16 位有符号整数</td>
</tr>
<tr>
<td>ushort</td>
<td>ushort us &#x3D; 65535;</td>
<td>16 位无符号整数</td>
</tr>
<tr>
<td>int</td>
<td>int i &#x3D; 42;</td>
<td>32 位有符号整数</td>
</tr>
<tr>
<td>uint</td>
<td>uint ui &#x3D; 123;</td>
<td>32 位无符号整数</td>
</tr>
<tr>
<td>long</td>
<td>long l &#x3D; 123456;</td>
<td>64 位有符号整数</td>
</tr>
<tr>
<td>ulong</td>
<td>ulong ul &#x3D; 123456;</td>
<td>64 位无符号整数</td>
</tr>
<tr>
<td>float</td>
<td>float f &#x3D; 3.14f;</td>
<td>32 位浮点数（精确到7位小数）</td>
</tr>
<tr>
<td>double</td>
<td>double d &#x3D; 3.14;</td>
<td>64 位浮点数（精确到16位小数）</td>
</tr>
<tr>
<td>decimal</td>
<td>decimal dec &#x3D; 123.456m;</td>
<td>128 位高精度小数（精确到28位小数）</td>
</tr>
<tr>
<td>char</td>
<td>char c &#x3D; ‘A’;</td>
<td>16 位 Unicode 字符</td>
</tr>
<tr>
<td>bool</td>
<td>bool flag &#x3D; true;</td>
<td>表示真或假</td>
</tr>
<tr>
<td>string</td>
<td>string str &#x3D; “Hello”;</td>
<td>表示文本字符串</td>
</tr>
<tr>
<td>DateTime</td>
<td>DateTime dt &#x3D; DateTime.Now;</td>
<td>表示日期和时间</td>
</tr>
</tbody></table>
<h2 id="变量和变量赋值"><a href="#变量和变量赋值" class="headerlink" title="变量和变量赋值"></a>变量和变量赋值</h2><p><u>在C#中，变量是用来存储和表示数据的标识符，是程序中的基本元素之一。</u>变量在程序执行过程中可以被赋予不同的值，并且这些值可以是不同的数据类型，如整数、浮点数、字符、布尔值等。</p>
<p>定义一个变量</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a;</span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> b;</span><br><span class="line">b=<span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> c=<span class="number">12.33</span></span><br><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;哈哈哈哈&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量使用注意：①先声明在使用，②先初始化在使用</p>
<p>定义姓名（name），年龄(age)，性别(sex)，身高(height)，体重(weight)，婚否(isMarry),格言（motto）等变量，并在控制台打印输出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如何定义一个变量</span></span><br><span class="line">            <span class="comment">//数据类型 变量名</span></span><br><span class="line">            <span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            <span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">            <span class="built_in">char</span> sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">            <span class="built_in">double</span> height = <span class="number">178.9</span>;</span><br><span class="line">            <span class="built_in">double</span> weight = <span class="number">71</span>;</span><br><span class="line">            <span class="built_in">bool</span> isMarry = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">string</span> motto = <span class="string">&quot;勇敢的人先享受世界&quot;</span>;</span><br><span class="line">            Console.WriteLine(name);</span><br><span class="line">            Console.WriteLine(Name);</span><br><span class="line">            Console.WriteLine(age);</span><br><span class="line">            Console.WriteLine(sex);</span><br><span class="line">            Console.WriteLine(height);</span><br><span class="line">            Console.WriteLine(weight);</span><br><span class="line">            Console.WriteLine(isMarry);</span><br><span class="line">            Console.WriteLine(motto);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量的输出方式"><a href="#变量的输出方式" class="headerlink" title="变量的输出方式"></a>变量的输出方式</h2><p>1.＋号拼接（只能用于字符串与字符串或者字符串和其它类型）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> myNumber = <span class="number">42</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;变量的值是：&quot;</span> + myNumber);</span><br></pre></td></tr></table></figure>

<p>2.占位符输出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我叫&#123;0&#125;，今年&#123;1&#125;岁&quot;</span>,name,age);</span><br></pre></td></tr></table></figure>

<p>3.$插值输出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;name&#125;</span>，今年<span class="subst">&#123;age&#125;</span>岁&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><u>常量是固定值，程序执行期间不会改变。</u>常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 数据类型 常量名称 = 常量值</span></span><br><span class="line">cosnt <span class="built_in">int</span> a = <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：①常量必须在声明时初始化，并且在指定值后就不能修改，②常量的值不能用一个变量的值去初始化</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下编译不通过</span></span><br><span class="line"><span class="built_in">int</span> i =<span class="number">64</span>;</span><br><span class="line">cosnt <span class="built_in">int</span> a = i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>在C#中，变量的命名应该遵循一定的规范，以提高代码的可读性和维护性。以下是一些常见的C#变量命名规范：</p>
<p>1.**驼峰命名法 (Camel Case)**：首字母小写，后续每个单词的首字母大写。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> myName;</span><br><span class="line"><span class="built_in">int</span> myAge;</span><br><span class="line"><span class="built_in">int</span> MYAGE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.变量名必须以字母或者下划线开头；</p>
<p>3.变量名只能由字母、数字和下划线组成，不能包含空格、标点符号、等其它符号；</p>
<p>4.变量名不能与c#中的关键字相同，例如int 、float、double；</p>
<p>5.变量名区分大小写。</p>
<h2 id="表达式和常用运算符"><a href="#表达式和常用运算符" class="headerlink" title="表达式和常用运算符"></a>表达式和常用运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>算术运算符</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>int result &#x3D; 5 + 3;</td>
<td>加法运算符，将两个值相加</td>
</tr>
<tr>
<td>-</td>
<td>int result &#x3D; 5 - 3;</td>
<td>减法运算符，将右侧值从左侧值中减去</td>
</tr>
<tr>
<td>*</td>
<td>int result &#x3D; 5 * 3;</td>
<td>乘法运算符，将两个值相乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>int result &#x3D; 6 &#x2F; 3;</td>
<td>除法运算符，将左侧值除以右侧值</td>
</tr>
<tr>
<td>%</td>
<td>int result &#x3D; 7 % 3;</td>
<td>取余运算符，返回除法的余数</td>
</tr>
<tr>
<td>++</td>
<td>int x &#x3D; 5; x++;</td>
<td>递增运算符，将变量的值增加1</td>
</tr>
<tr>
<td>–</td>
<td>int y &#x3D; 8; y–;</td>
<td>递减运算符，将变量的值减少1</td>
</tr>
</tbody></table>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table>
<thead>
<tr>
<th>比较运算符</th>
<th align="left">示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 5;bool isEqual &#x3D; (a &#x3D;&#x3D; b);</td>
<td>相等运算符，检查两个值是否相等</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 10;bool isNotEqual &#x3D; (a !&#x3D; b);</td>
<td>不等运算符，检查两个值是否不相等</td>
</tr>
<tr>
<td>&gt;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 3;bool isGreater &#x3D; (a &gt; b);</td>
<td>大于运算符，检查左侧值是否大于右侧值</td>
</tr>
<tr>
<td>&lt;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 10;bool isLess &#x3D; (a &lt; b);</td>
<td>小于运算符，检查左侧值是否小于右侧值</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 5;bool isGreaterOrEqual &#x3D;(a &gt;&#x3D; b);</td>
<td>大于等于运算符，检查左侧值是否大于或等于右侧</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td align="left">int a &#x3D; 5; int b &#x3D; 10;bool isLessOrEqual &#x3D;(a &lt;&#x3D; b);</td>
<td>小于等于运算符，检查左侧值是否小于或等于右侧</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td><code>bool result = (true &amp;&amp; false);</code></td>
<td>逻辑与运算符，当两个条件都为真时返回真</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
<td>&#96;</td>
</tr>
<tr>
<td><code>!</code></td>
<td><code>bool result = !true;</code></td>
<td>逻辑非运算符，用于取反，将真变为假，将假变为真</td>
</tr>
</tbody></table>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目运算符，也称为条件运算符，是一种在单行中使用条件进行条件判断的运算符：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&lt;条件表达式&gt; ? &lt;表达式1&gt; : &lt;表达式2&gt;</span></span><br><span class="line"><span class="built_in">int</span> a =<span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="built_in">string</span> isMax=a&gt;b?<span class="string">&quot;a大于b&quot;</span>:<span class="string">&quot;a小于b&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="快捷运算符"><a href="#快捷运算符" class="headerlink" title="快捷运算符"></a>快捷运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>+=</code></td>
<td><code>a += b;</code></td>
<td>相当于 <code>a = a + b;</code>，将 <code>a</code> 的值与 <code>b</code> 相加并将结果赋给 <code>a</code>。</td>
</tr>
<tr>
<td><code>-=</code></td>
<td><code>a -= b;</code></td>
<td>相当于 <code>a = a - b;</code>，将 <code>a</code> 的值减去 <code>b</code> 并将结果赋给 <code>a</code>。</td>
</tr>
<tr>
<td><code>*=</code></td>
<td><code>a *= b;</code></td>
<td>相当于 <code>a = a * b;</code>，将 <code>a</code> 的值乘以 <code>b</code> 并将结果赋给 <code>a</code>。</td>
</tr>
<tr>
<td><code>/=</code></td>
<td><code>a /= b;</code></td>
<td>相当于 <code>a = a / b;</code>，将 <code>a</code> 的值除以 <code>b</code> 并将结果赋给 <code>a</code>。</td>
</tr>
<tr>
<td><code>%=</code></td>
<td><code>a %= b;</code></td>
<td>相当于 <code>a = a % b;</code>，将 <code>a</code> 的值取模 <code>b</code> 并将结果赋给 <code>a</code>。</td>
</tr>
<tr>
<td><code>++</code></td>
<td><code>a++;</code></td>
<td>自增运算符，相当于 <code>a = a + 1;</code>，将 <code>a</code> 的值增加1。</td>
</tr>
<tr>
<td><code>--</code></td>
<td><code>a--;</code></td>
<td>自减运算符，相当于 <code>a = a - 1;</code>，将 <code>a</code> 的值减少1。</td>
</tr>
</tbody></table>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>()</code></td>
<td>圆括号（最高优先级）</td>
</tr>
<tr>
<td>2</td>
<td><code>++</code>, <code>--</code>, <code>!</code></td>
<td>递增、递减、逻辑非</td>
</tr>
<tr>
<td>3</td>
<td><code>*</code>, <code>/</code>, <code>%</code></td>
<td>乘法、除法、取余</td>
</tr>
<tr>
<td>4</td>
<td><code>+</code>, <code>-</code></td>
<td>加法、减法</td>
</tr>
<tr>
<td>5</td>
<td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>is</code>, <code>as</code></td>
<td>关系和类型检查</td>
</tr>
<tr>
<td>6</td>
<td><code>==</code>, <code>!=</code></td>
<td>相等和不等比较</td>
</tr>
<tr>
<td>7</td>
<td><code>&amp;</code></td>
<td>位与</td>
</tr>
<tr>
<td>8</td>
<td><code>^</code></td>
<td>位异或</td>
</tr>
<tr>
<td>9</td>
<td>&#96;</td>
<td>&#96;</td>
</tr>
<tr>
<td>10</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td>11</td>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td><code>??</code></td>
<td>空合并运算符</td>
</tr>
<tr>
<td>13</td>
<td><code>? :</code></td>
<td>条件运算符</td>
</tr>
<tr>
<td>14</td>
<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></td>
<td>赋值和复合赋值</td>
</tr>
<tr>
<td>15</td>
<td><code>,</code></td>
<td>逗号运算符（最低优先级）</td>
</tr>
</tbody></table>
<h2 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> userName = Console.ReadLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>Console.ReadLine()</code> 返回的是一个字符串，如果你需要将用户输入转换为其他类型（例如整数或浮点数）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用int.Parse()、float.Parse</span></span><br><span class="line"><span class="built_in">int</span> num =<span class="built_in">int</span>.Parse(Console.ReadLine())<span class="comment">//字符串转整数</span></span><br><span class="line"><span class="built_in">float</span> num=<span class="built_in">float</span>.Parse(Console.ReadLine())<span class="comment">//字符串转浮点数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><p><code>if</code> 和 <code>else</code> 是在编程中用于实现条件分支的控制结构。它们允许根据条件的真假执行不同的代码块。</p>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h3><p><code>if</code> 语句用于执行一组语句，如果指定的条件为真（<code>true</code>）。其基本语法如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在条件condition为真时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 大于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>if-else&#96; 语句用于执行两组不同的语句，根据指定的条件是真还是假。其基本语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在条件condition为真时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在条件为假时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 大于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 不大于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="if-else-else-if-语句"><a href="#if-else-else-if-语句" class="headerlink" title="if-else else-if 语句"></a><code>if-else else-if</code> 语句</h3><p><code>if-else if-else</code> 语句用于执行多个条件分支，每个条件都被逐一检查。其基本语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在条件1为真时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在条件2为真时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在所有条件都为假时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 大于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 等于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x 小于 5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication12</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输入一个整数&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> x = <span class="built_in">int</span>.Parse(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// string str = x % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;x&#125;</span>是偶数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;x&#125;</span>是奇数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="switch…case"><a href="#switch…case" class="headerlink" title="switch…case"></a><code>switch</code>…case</h3><p> switch语句是一种用于实现多分支选择的控制结构。它比 <code>if-else</code> 语句更适用于对同一个变量进行多个值的比较。<code>switch</code> 语句的基本语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//expression 是需要进行比较的表达式或变量。</span></span><br><span class="line"><span class="comment">//case 后面跟着一个常量或常量表达式，表示某个值。</span></span><br><span class="line"><span class="comment">//break 语句用于退出 switch 语句，防止继续执行下一个 case 或 default。</span></span><br><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 当 expression 等于 value1 时执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 当 expression 等于 value2 时执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 可以有多个 case</span></span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        <span class="comment">// 如果上述所有 case 都不满足时执行的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.Write(<span class="string">&quot;输入一个数字（1到3）: &quot;</span>);</span><br><span class="line"><span class="built_in">int</span> number = <span class="built_in">int</span>.Parse(Console.ReadLine());</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你输入的是数字 1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你输入的是数字 2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你输入的是数字 3&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;输入无效&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while…循环"><a href="#while…循环" class="headerlink" title="while…循环"></a>while…循环</h3><p><code>while</code> 循环是 一种迭代控制结构，用于重复执行一段代码块，直到指定的条件不再满足为止：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">    <span class="comment">// 在每次循环迭代时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>condition</code> 是一个条件表达式，它决定了是否继续执行循环体内的代码块。只要条件为 true，循环就会继续执行。</li>
<li>循环体代码是被重复执行的代码块。当条件为 true 时，循环体会被执行。如果条件为 false，循环体内的代码将不会被执行。</li>
</ul>
<p><code>while</code> 循环的工作原理是，首先评估条件。如果条件为 true，则执行循环体内的代码，并再次评估条件。这个过程会一直重复，直到条件为 false，此时循环停止，控制流跳出循环，继续执行循环之后的代码。</p>
<p>下面是一个简单的示例，演示了 <code>while</code> 循环的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;当前值为：<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">    i++; <span class="comment">// 更新循环变量，防止无限循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>while</code> 循环将在 <code>i</code> 的值小于 5 时重复执行。每次循环迭代时，会打印当前值，然后递增 <code>i</code> 的值。当 <code>i</code> 的值达到 5 时，条件不再满足，循环停止。</p>
<p>需要注意的是，如果循环的条件始终为 true，就会造成无限循环（死循环），导致程序永远无法结束。因此，在使用 <code>while</code> 循环时，确保循环条件最终会变为 false，以避免无限循环的发生。</p>
<p>练习</p>
<p>1.提示用户输入正整数n，输出1+2+3+4…+n的和。</p>
<p>2.输出0-100的偶数。</p>
<p>3.提示用户输入两个数n1,n2，输出这n1-n2两个数之间(包括n1和n2)的所有偶数。</p>
<p>4.假设一只boss血量为100，主角每次攻击－5血量，当血量低于0时，提示boss被击败。</p>
<h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><p>&#96;&#96;do…while<code>循环与</code>while<code> 循环类似，但它在评估条件之前执行循环体内的代码。这意味着，无论条件是否为真，</code>do…while&#96; 循环至少会执行一次循环体内的代码。</p>
<p><code>do...while</code> 循环的基本语法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">    <span class="comment">// 在每次循环迭代时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>循环体代码是被重复执行的代码块，它会在条件评估之前至少执行一次。</li>
<li><code>condition</code> 是一个布尔表达式，它决定了是否继续执行循环。如果条件为 true，则继续执行循环。如果条件为 false，则跳出循环。</li>
</ul>
<p><code>do...while</code> 循环首先执行循环体内的代码，然后再评估条件。如果条件为 true，则继续执行循环，否则循环终止。</p>
<p>以下是一个简单的示例，演示了 <code>do...while</code> 循环的使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;当前值为：<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">    i++; <span class="comment">// 更新循环变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，无论条件是否为 true，循环都会至少执行一次。每次循环迭代时，会打印当前值，然后递增 <code>i</code> 的值。当 <code>i</code> 的值达到 5 时，条件不再满足，循环停止。</p>
<p>与 <code>while</code> 循环相比，<code>do...while</code> 循环在某些情况下更适合用于确保循环体内的代码至少执行一次，因为它首先执行代码，然后再检查条件。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><code>for</code> 循环是 C# 中最常用的迭代控制结构之一，它允许你按照指定的条件重复执行一段代码块。<code>for</code> 循环通常用于在已知循环次数的情况下执行循环，其基本语法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; iteration)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">    <span class="comment">// 在每次循环迭代时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>initialization</code>：在循环开始前执行一次，用于初始化循环变量。通常是一个赋值表达式，用于初始化循环计数器。</li>
<li><code>condition</code>：在每次循环迭代之前检查的条件。如果条件为 true，则继续执行循环；如果条件为 false，则跳出循环。</li>
<li><code>iteration</code>：在每次循环迭代之后执行的代码。通常用于更新循环变量的值。</li>
</ul>
<p><code>for</code> 循环的工作流程如下：</p>
<ol>
<li>执行初始化表达式（<code>initialization</code>）。</li>
<li>检查循环条件（<code>condition</code>）。如果条件为 false，则退出循环。</li>
<li>执行循环体内的代码。</li>
<li>执行迭代表达式（<code>iteration</code>）。</li>
<li>返回步骤 2，继续下一次迭代，直到循环条件为 false。</li>
</ol>
<p>以下是一个简单的示例，演示了 <code>for</code> 循环的使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;当前值为：<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>for</code> 循环将在 <code>i</code> 的值从 0 递增到 4 的过程中重复执行循环体内的代码。在每次迭代中，当前值都会被打印出来。</p>
<p><code>for</code> 循环通常用于在已知循环次数的情况下执行循环，例如遍历数组或执行一定次数的操作。因其简洁和明确的语法，<code>for</code> 循环在实际开发中被广泛使用。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>变量作用域指的是变量在程序中可访问的范围。在 C# 中，变量的作用域可以根据声明的位置和所在代码块来确定。</p>
<p>1.局部作用域</p>
<p>大多数变量都是在方法内部或者代码块内部声明的。这些变量的作用域仅限于声明它们的代码块内部。</p>
<p>2.全局作用作用域</p>
<h3 id="continue与break的区别"><a href="#continue与break的区别" class="headerlink" title="continue与break的区别"></a>continue与break的区别</h3><p>在 C# 中，<code>continue</code> 和 <code>break</code> 是两个用于控制循环行为的关键字。</p>
<ol>
<li>break 关键字：</li>
</ol>
<ul>
<li><code>break</code> 关键字用于在循环内部中断循环的执行，无论循环条件是否已经满足。一旦 <code>break</code> 被执行，循环将立即终止，并且程序流将跳出循环体，继续执行循环后的代码。</li>
</ul>
<p>下面是一个示例，演示了 <code>break</code> 的用法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，一旦 <code>i</code> 的值等于 5，<code>break</code> 语句将被执行，导致循环立即终止。因此，循环只会输出 0 到 5 的数字。</p>
<ol start="2">
<li>continue 关键字：</li>
</ol>
<ul>
<li><code>continue</code> 关键字用于终止当前循环的迭代，并立即开始下一次迭代。当 <code>continue</code> 被执行时，程序流将跳过当前迭代的剩余代码，直接进入下一次循环迭代。</li>
</ul>
<p>下面是一个示例，演示了 <code>continue</code> 的用法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 如果 i 是偶数，跳过本次循环的剩余代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中，当 <code>i</code> 是偶数时，<code>continue</code> 将被执行，导致循环直接跳过输出语句，进入下一次迭代。因此，循环将只输出奇数。</p>
<p><code>break</code> 和 <code>continue</code> 关键字是控制循环流程的有用工具。它们可以帮助我们在循环中实现特定的逻辑或行为，从而使代码更加灵活和可控。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 C# 中，数组（Array）是一种用于存储相同类型数据元素的集合。它是一个连续的内存块，每个元素都可以通过索引访问。</p>
<h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _003_数组</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//dataType[] arrayName;</span></span><br><span class="line">            <span class="comment">//dataType是数据类型;</span></span><br><span class="line">            <span class="comment">//arrayName是数组名;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式1</span></span><br><span class="line">            <span class="built_in">int</span>[] arr1= &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">            <span class="comment">//数组下标   0  1  2   3  4  5  6  </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式2</span></span><br><span class="line">            <span class="built_in">int</span>[] arr2;</span><br><span class="line">            arr2=<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式3</span></span><br><span class="line">            <span class="built_in">int</span>[] arr3;</span><br><span class="line">            arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">7</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式4</span></span><br><span class="line">            <span class="built_in">int</span>[] arr4;</span><br><span class="line">            arr4 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">7</span>]; <span class="comment">//默认值为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _004_数组遍历</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式1</span></span><br><span class="line">            <span class="comment">//for (int i = 0; i &lt; arr.Length; i++)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.Write(arr[i]+&quot; &quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式2</span></span><br><span class="line">            <span class="comment">//int i = 0;</span></span><br><span class="line">            <span class="comment">//while (i&lt;arr.Length)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//     Console.Write(arr[i]+&quot; &quot;);</span></span><br><span class="line">            <span class="comment">//    i++;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式3</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                 Console.Write(item+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组常用的方法"><a href="#数组常用的方法" class="headerlink" title="数组常用的方法"></a>数组常用的方法</h3><p>在 C# 中，数组是一个非常有用的数据结构，它提供了许多方法来对数组进行操作和处理。以下是一些数组中常用的方法：</p>
<h4 id="1-Length-属性："><a href="#1-Length-属性：" class="headerlink" title="1. Length 属性："></a>1. Length 属性：</h4><p><code>Length</code> 属性用于获取数组的长度，即数组中元素的个数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> length = numbers.Length; <span class="comment">// length 的值为 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-IndexOf-方法："><a href="#2-IndexOf-方法：" class="headerlink" title="2. IndexOf 方法："></a>2. IndexOf 方法：</h4><p><code>IndexOf</code> 方法用于查找指定元素在数组中第一次出现的索引。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> index = Array.IndexOf(numbers, <span class="number">3</span>); <span class="comment">// index 的值为 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-Copy-方法："><a href="#3-Copy-方法：" class="headerlink" title="3. Copy 方法："></a>3. Copy 方法：</h4><p><code>Copy</code> 方法用于复制数组的内容到一个新的数组中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] destination = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">Array.Copy(source, destination, source.Length);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-Sort-方法："><a href="#4-Sort-方法：" class="headerlink" title="4. Sort 方法："></a>4. Sort 方法：</h4><p><code>Sort</code> 方法用于对数组进行排序。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Array.Sort(numbers); <span class="comment">// numbers 变为 &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-Resize-方法："><a href="#5-Resize-方法：" class="headerlink" title="5. Resize 方法："></a>5. Resize 方法：</h4><p><code>Resize</code> 方法用于调整数组的大小。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Array.Resize(<span class="keyword">ref</span> numbers, <span class="number">10</span>); <span class="comment">// numbers 的大小变为 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-Clear-方法："><a href="#6-Clear-方法：" class="headerlink" title="6. Clear 方法："></a>6. Clear 方法：</h4><p><code>Clear</code> 方法用于清除数组的所有元素，将其设置为默认值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Array.Clear(numbers, <span class="number">0</span>, numbers.Length); <span class="comment">// 将 numbers 数组的所有元素清零</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-Reverse-方法："><a href="#7-Reverse-方法：" class="headerlink" title="7. Reverse 方法："></a>7. Reverse 方法：</h4><p><code>Reverse</code> 方法用于反转数组中元素的顺序。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Array.Reverse(numbers); <span class="comment">// numbers 变为 &#123;5, 4, 3, 2, 1&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="C-中的函数（方法）"><a href="#C-中的函数（方法）" class="headerlink" title="C#中的函数（方法）"></a>C#中的函数（方法）</h2><h3 id="函数的声明与调用"><a href="#函数的声明与调用" class="headerlink" title="函数的声明与调用"></a>函数的声明与调用</h3><p>在 C# 中，方法是一段可重复调用的代码块，它用于执行特定的任务或操作。方法有自己的名称，并且可以接受参数以及返回值。下面是关于 C# 中方法的一些重要概念和特性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">FX</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//函数调用</span></span><br><span class="line">             <span class="keyword">add</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  &lt;访问修饰符&gt; &lt;返回类型&gt; &lt;方法名&gt;(参数列表)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//     方法体</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line">            Console.WriteLine(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问修饰符</strong>：指定方法的访问级别，可以是 <code>public</code>、<code>private</code>、<code>protected</code> 或 <code>internal</code> 等。</li>
<li><strong>返回类型</strong>：指定方法返回的数据类型，如果方法不返回任何值，则使用 <code>void</code>。</li>
<li><strong>方法名</strong>：方法的名称，用于调用方法。</li>
<li><strong>参数列表</strong>：指定方法接受的参数，可以包含零个或多个参数。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _006_函数</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//函数调用</span></span><br><span class="line">            <span class="comment">//5和5为实参</span></span><br><span class="line">            <span class="built_in">int</span> sum= <span class="keyword">add</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(sum);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  &lt;访问修饰符&gt; &lt;返回类型&gt; &lt;方法名&gt;(参数列表)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//     方法体</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//x和y 为形参</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = x + y;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _006_函数</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//函数调用</span></span><br><span class="line">            <span class="comment">//5和5为实参</span></span><br><span class="line">            <span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">double</span> result1 = <span class="keyword">add</span>(<span class="number">5.5</span>, <span class="number">4.5</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">            Console.WriteLine(result1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//函数名相同，参数不同就为函数的重载</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = x + y;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> sum = x + y;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h3><p>函数的递归是指在函数的定义中调用函数本身的过程。递归是一种重要的编程技巧，它可以简化问题的解决方案，并使代码更加清晰和易于理解。在 C# 中，函数可以是递归的，允许函数调用自身，但需要小心处理递归调用的终止条件，以免导致无限循环。</p>
<p>递归的注意事项：</p>
<ul>
<li><strong>终止条件</strong>：递归函数必须有明确的终止条件，否则会导致无限递归。</li>
<li><strong>性能问题</strong>：递归可能导致性能问题，因为它需要在每一层递归中保留状态。</li>
<li><strong>栈溢出</strong>：如果递归调用的层数过多，可能导致栈溢出错误。</li>
</ul>
<p>示例：斐波那契数列</p>
<p>斐波那契数列是一个经典的递归示例，它定义如下：斐波那契数列中的每个数字都是前两个数字的和，其中第一个和第二个数字分别为 0 和 1。</p>
<p>数列的前几个数字如下所示：0, 1, 1, 2, 3, 5, 8, 13, 21, …</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _007_函数的递归</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> n = <span class="number">10</span>; <span class="comment">// 计算斐波那契数列的第 n 个数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(CalculateFibonacci(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateFibonacci</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 基本情况：当 n 为 0 或 1 时，斐波那契数为 n</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 递归情况：计算第 n 个斐波那契数为前两个数的和</span></span><br><span class="line">            <span class="keyword">return</span> CalculateFibonacci(n - <span class="number">1</span>) + CalculateFibonacci(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举（Enum）类型是一种 C# 中的数据类型，用于定义命名的常量集合。枚举类型允许我们定义一组具有逻辑联系的命名常量，以提高代码的可读性和可维护性。在 C# 中，枚举类型通常用于代表一组相关的值。</p>
<h3 id="定义枚举类型："><a href="#定义枚举类型：" class="headerlink" title="定义枚举类型："></a>定义枚举类型：</h3><p>在 C# 中，可以使用 <code>enum</code> 关键字定义枚举类型。以下是枚举类型的基本语法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> 枚举名</span><br><span class="line">&#123;</span><br><span class="line">    常量<span class="number">1</span>,</span><br><span class="line">    常量<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 可以有更多的常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Weekday</span><br><span class="line">&#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用枚举类型："><a href="#使用枚举类型：" class="headerlink" title="使用枚举类型："></a>使用枚举类型：</h3><p>定义了枚举类型之后，我们可以声明变量并赋予枚举常量作为其值。例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Weekday today = Weekday.Monday;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>today</code> 变量的类型是 <code>Weekday</code> 枚举类型，并且它的值被设为 <code>Monday</code>。</p>
<h3 id="枚举的特性："><a href="#枚举的特性：" class="headerlink" title="枚举的特性："></a>枚举的特性：</h3><ol>
<li><p><strong>默认值</strong>：枚举类型的默认基础类型是整数（int）。第一个枚举常量的默认值是 0，后续常量的值逐次递增。</p>
</li>
<li><p><strong>显式赋值</strong>：我们可以显式地为枚举常量指定值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Weekday</span><br><span class="line">&#123;</span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 其他常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换</strong>：枚举类型可以与整数类型相互转换。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> day = (<span class="built_in">int</span>)Weekday.Monday; <span class="comment">// day 的值为 1</span></span><br><span class="line">Weekday day = (Weekday)<span class="number">1</span>; <span class="comment">// day 的值为 Monday</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>枚举成员访问</strong>：我们可以通过枚举的名称来访问其成员。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Weekday today = Weekday.Monday;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>和C++中一样，类衍生出对象，水果可以衍生出苹果，</p>
<p>在程序员眼中，现实中的一切事物皆为对象。而面向对象是一种对现实 世界理解和抽象的方法，是计算机编程思想。面向对象的思想是从现实世界中客观存在的事物出发来构造软件系统，并且在系统中尽可能的运用人类的思维方式。</p>
<h3 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h3><p>类描述了一组有相同特性（属性）和相同行为（方法）的对象<br>类可以定义为数据和方法的集合。<br>类也称为模板，因为它们提供了对象的基本框架。</p>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>类是描述现实生活中的实体的，实体就是对象！</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>如下声明了一个动物类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _008_面向对象编程</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> heght;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> audio;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;name&#125;</span>,身高<span class="subst">&#123;heght&#125;</span>cm,体重<span class="subst">&#123;weight&#125;</span>kg,我会<span class="subst">&#123;audio&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>实例化动物类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _008_面向对象编程</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过new关键字实例化了一个mouse对象</span></span><br><span class="line">            Animal mouse = <span class="keyword">new</span> Animal();</span><br><span class="line">            <span class="comment">//为对象属性赋值</span></span><br><span class="line">            mouse.name = <span class="string">&quot;jerry&quot;</span>;</span><br><span class="line">            mouse.weight = <span class="number">1</span>;</span><br><span class="line">            mouse.heght = <span class="number">10</span>;</span><br><span class="line">            mouse.audio = <span class="string">&quot;吱吱吱&quot;</span>;</span><br><span class="line">            <span class="comment">//调用对象方法</span></span><br><span class="line">            mouse.action();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性：对字段的访问作出一些限定，不允许外界随意访问。</p>
<p>在程序中，使用属性封装字段时，需要将字段访问级别设为private，并通过属性地get和set访问器来对字段进行读写操作，从而保证类内部数据安全。</p>
<p>属性地分类：</p>
<ul>
<li><p>读写属性：同时有get、set访问器的属性。</p>
</li>
<li><p>只读属性：只有get访问器。</p>
</li>
<li><p>只写属性：只有set访问器。</p>
<p><strong>读写属性语法格式如下：</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>[数据类型][属性名]&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123;<span class="comment">//返回参数值&#125;</span></span><br><span class="line">	<span class="keyword">set</span>&#123;<span class="comment">//设置隐式参数value给字段赋值&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>只读属性地语法格式如下：</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>[数据类型][属性名]&#123;</span><br><span class="line">	<span class="keyword">get</span>&#123;<span class="comment">//返回参数值&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>只写属性地语法格式如下</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [数据类型] [属性名] &#123;     </span><br><span class="line">     <span class="keyword">set</span> &#123; <span class="comment">//设置隐式参数value给字段赋值 &#125;   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>类的设计</strong>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;	  <span class="comment">//定义私有字段name</span></span><br><span class="line">    	<span class="comment">//只读属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name  &#123;          <span class="comment">//定义公有属性Name封装name</span></span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age; 		       <span class="comment">//定义私有字段age</span></span><br><span class="line">    	<span class="comment">//读写属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age&#123;                <span class="comment">//定义公有属性Age封装age字段</span></span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123;……&#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="built_in">string</span> Gender&#123;         <span class="comment">//定义表示性别的 自动属性</span></span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Introduce</span>()</span>&#123;……&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>访问修饰符：用于限定外界对类和方法的访问权限，可以指定数据和方法的可见性。</p>
<p>访问修饰符分类：public、protected、internal、private。</p>
<p>访问级别：</p>
<ul>
<li>public：最高访问级别，访问不受限制。</li>
<li>protected:保护访问级别，受保护的成员可自身及派生类（子类）访问。</li>
<li>internal：内部访问级别，只有在同一程序集中，内部类型或者成员才能访问。</li>
<li>protected internal：内部保护级别，访问仅限于当前程序集，可由自身及派生类（子类）访问。</li>
<li>private：私有访问，最低访问级别，私有成员只有在声明他们的类和结构中才可访问。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法是类的一个特殊成员，他会在类实例化对象时自动调用，为对象开辟内存空间，并对类中的成员进行初始化。</p>
<p>定义构造方法的条件：</p>
<p>1.方法名与类名相同。</p>
<p>2.在方法名的前面没有返回值类型的声明。</p>
<p>3.在方法中不能使用return语句返回一个值。</p>
<p><strong>无参构造方法</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">       <span class="comment">// 下面是Person类的构造方法</span></span><br><span class="line">    	<span class="comment">//方法名与类名相同，没有返回值类型的声明，该构造方法中没有参数，因此为无参构造函数</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;无参的构造方法被调用了...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">           Person p = <span class="keyword">new</span> Person();  <span class="comment">//实例化Person 对象</span></span><br><span class="line">           Console.ReadKey();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>有参构造方法</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//方法名与类型相同，没有返回值类型的声明，该构造方法中有一个int类型的参数，因此为有参构造方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>&#123;</span><br><span class="line">            Age = a;   </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I am &quot;</span> + Age + <span class="string">&quot; years old.!&quot;</span>);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         ……</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">         Person p = <span class="keyword">new</span> Person(<span class="number">20</span>);    <span class="comment">//实例化 Person 对象</span></span><br><span class="line">         p.Speak();</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 然而并没有什么软用。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2024/06/15/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git使用-上世纪國男"><a href="#git使用-上世纪國男" class="headerlink" title="git使用-上世纪國男"></a>git使用-上世纪國男</h1><p>笔记</p>
<h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>前往这个网站下载git<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">CNPM Binaries Mirror (npmmirror.com)</a>这是阿里的git镜像网站</p>
<p>双击下载后的 <code>Git-2.40.0-64-bit.exe</code>，开始安装</p>
<p><img src="https://picture.gptkong.com/20240618/1716b9c680bbe14e0a85b91ffc521e477c.png"></p>
<p>最后一个选项不要打勾。</p>
<p>其他全是默认即可。</p>
<h3 id="配置系统变量环境"><a href="#配置系统变量环境" class="headerlink" title="配置系统变量环境"></a>配置系统变量环境</h3><h4 id="1-获取git的安装路径"><a href="#1-获取git的安装路径" class="headerlink" title="1. 获取git的安装路径"></a>1. 获取git的安装路径</h4><p><code>win+r</code> 输入 <code>cmd</code> 打开，输入命令行 <code>where git</code>并回车，复制返回的地址。</p>
<h4 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="2. 设置环境变量"></a>2. 设置环境变量</h4><p><strong>我的电脑右键 &#x3D;》属性 &#x3D;》高级系统设置 &#x3D;》系统属性（高级）&#x3D;》 环境变量，进入环境变量对话框。</strong></p>
<p>如果环境变量未正确配置，输入git 命令行会报错，系统将无法正确识别 “git” 命令。</p>
<p>选中 <code>系统变量</code> 里的 <code>Path</code> ，点击编辑。添加-复制刚刚的路径</p>
<p><img src="https://img-blog.csdnimg.cn/60753801cd674afdad940c6390ff6347.png"></p>
<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><p>安装完 Git 之后，要做的第一件事就是设置用户名和邮件地址。 这很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到每一次提交中，不可更改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email 你的邮箱@qq.com</span><br></pre></td></tr></table></figure>

<h2 id="git原理"><a href="#git原理" class="headerlink" title="git原理"></a>git原理</h2><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="img"></p>
<ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<h2 id="git创建仓库Git-创建仓库"><a href="#git创建仓库Git-创建仓库" class="headerlink" title="git创建仓库Git 创建仓库"></a>git创建仓库Git 创建仓库</h2><p>你也可以使用一个已经存在的目录作为 Git 仓库。</p>
<hr>
<h3 id="git-init仓库初始化"><a href="#git-init仓库初始化" class="headerlink" title="git init仓库初始化"></a>git init仓库初始化</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。</p>
<p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为Git仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init myrep</span><br></pre></td></tr></table></figure>

<p>初始化后，会在 myrep 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;提交说明：初始化项目版本&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="git-clone代码拷贝"><a href="#git-clone代码拷贝" class="headerlink" title="git clone代码拷贝"></a>git clone代码拷贝</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p>
<p>克隆仓库的命令格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo&gt; 克隆地址</span><br></pre></td></tr></table></figure>

<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>**repo:**Git 仓库。</li>
<li>**directory:**本地目录。</li>
</ul>
<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：常用方式就是这种，有克隆网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>

<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>

<p>下表列出了 git 创建仓库的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git init</code></td>
<td align="left">初始化仓库</td>
</tr>
<tr>
<td align="left"><code>git clone</code></td>
<td align="left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody></table>
<hr>
<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add</code></td>
<td align="left">添加文件到暂存区</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code></td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git commit</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">将文件从暂存区和工作区中删除。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git checkout</code></td>
<td align="left">分支切换。</td>
</tr>
<tr>
<td align="left"><code>git switch （Git 2.23 版本引入）</code></td>
<td align="left">更清晰地切换分支。</td>
</tr>
<tr>
<td align="left"><code>git restore （Git 2.23 版本引入）</code></td>
<td align="left">恢复或撤销文件的更改。</td>
</tr>
</tbody></table>
<h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code></td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git blame &lt;file&gt;</code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<h2 id="git分支系统"><a href="#git分支系统" class="headerlink" title="git分支系统"></a>git分支系统</h2><p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。</p>
<p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。如图所示：</p>
<p><img src="https://static.jyshare.com/images/svg/git-brance.svg"></p>
<p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>有参数时就会根据参数yourbranch创造yourbranch分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch yourbranch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>切换到mybranch分支命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout mybranch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>合并分支命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除分支命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d yourbranch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>合并完后就可以删除分支:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d yourbranch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Git-提交历史"><a href="#Git-提交历史" class="headerlink" title="Git 提交历史"></a>Git 提交历史</h2><p>一般常用两个命令：</p>
<p><strong>git log</strong> - 查看历史提交记录。</p>
<p><strong>git blame <file></strong> - 以列表形式查看指定文件的历史修改记录。</p>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</p>
<p><strong>git log</strong> 命令用于查看 Git 仓库中提交历史记录。</p>
<p><strong>git log</strong> 显示了从最新提交到最早提交的所有提交信息，包括提交的哈希值、作者、提交日期和提交消息等。</p>
<p><strong>git log</strong> 命令的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log [选项] [分支名/提交哈希]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-p</code>：显示提交的补丁（具体更改内容）。</li>
<li><code>--oneline</code>：以简洁的一行格式显示提交信息。</li>
<li><code>--graph</code>：以图形化方式显示分支和合并历史。</li>
<li><code>--decorate</code>：显示分支和标签指向的提交。</li>
<li><code>--author=&lt;作者&gt;</code>：只显示特定作者的提交。</li>
<li><code>--since=&lt;时间&gt;</code>：只显示指定时间之后的提交。</li>
<li><code>--until=&lt;时间&gt;</code>：只显示指定时间之前的提交。</li>
<li><code>--grep=&lt;模式&gt;</code>：只显示包含指定模式的提交消息。</li>
<li><code>--no-merges</code>：不显示合并提交。</li>
<li><code>--stat</code>：显示简略统计信息，包括修改的文件和行数。</li>
<li><code>--abbrev-commit</code>：使用短提交哈希值。</li>
<li><code>--pretty=&lt;格式&gt;</code>：使用自定义的提交信息显示格式。</li>
</ul>
<h2 id="git-tag-标签注解"><a href="#git-tag-标签注解" class="headerlink" title="git tag 标签注解"></a>git tag 标签注解</h2><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了</p>
<h2 id="git链接到github"><a href="#git链接到github" class="headerlink" title="git链接到github"></a>git链接到github</h2><p>你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p>
<p>在本地仓库文件目录下右键git bash使用以下命令生成 SSH Key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">ssh-keygen -t rsa -C &quot;你的Github邮箱@example.com&quot;  //获取ssh的公钥，输入后连按三下回车键即可</span><br><span class="line">ssh -T git@github.com //验证连接上ssh没，失败会提示的</span><br><span class="line">可能会显示22号端口连不了</span><br><span class="line">换443端口：</span><br><span class="line">ssh -T -p 443 git@ssh.github.com</span><br><span class="line"># -p 443表示使用443端口，要是443也被占用，也可以尝试其他端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后使用默认的，一路回车就行。</p>
<p>然后在C盘用户-用户名-.ssh文件内找到两个文件夹：id_rsa和id_rsa.pub，id_rsa.pub里面的就是你的ssh配置的key，然后复制到github里面（回到 github 上，进入 Account &#x3D;&gt; Settings（账户配置），复制粘贴到key上就行）</p>
<h2 id="从本地push到github仓库"><a href="#从本地push到github仓库" class="headerlink" title="从本地push到github仓库"></a>从本地push到github仓库</h2><p><code>git init</code>: 初始化一个新的 Git 仓库。</p>
<p>git remote -v ：查看是否已经绑定其他的远程仓库，</p>
<p>git remote rm origin xxxx：删除远程仓库xxxx</p>
<p><code>git remote add origin [url]</code>: 将本地仓库与远程仓库关联。</p>
<p><code>git add .</code> 或 <code>git add [file]</code>: 将文件更改添加到暂存区。<br><code>git rm --cached [path]</code>: 从暂存区中删除文件（但保留在工作目录中）。<br>提交管理:</p>
<p><code>git commit -m &quot;[message]&quot;</code>: 将暂存区内容提交到本地仓库。<br><code>git status: </code>查看仓库状态，包括更改、暂存和未跟踪的文件。git branch: 列出所有本地分支。<br><code>git checkout -b [branch_name]</code>: 创建并切换到新分支。<br>远程同步:</p>
<p><code>git pull --rebase origin master</code>: 更新项目并避免与远程仓库的代码发生冲突。<br><code>git push origin master</code>: 将本地仓库的更改推送到远程仓库。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init		//初始化本地文件夹，添加git的一些文件</span><br><span class="line">git add .    //add后面有空格的，把本地文件加载到git的一些版本库/暂存区</span><br><span class="line">git commit -m &quot;first commit&quot; //提交第一次修改信息“firts commit”</span><br><span class="line">git remote add origin https://github.com/xxxx/xxxx.git //链接远程仓库,xxx是仓库的链接一部分</span><br><span class="line">git pull	//下载远程仓库的文件到本地仓库。</span><br><span class="line">git push 	//拉取远程仓库代码到本地</span><br><span class="line">git push -u origin master //push到远程仓库的master分支</span><br><span class="line">如果更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="从github克隆到本地"><a href="#从github克隆到本地" class="headerlink" title="从github克隆到本地"></a>从github克隆到本地</h2><p><code>git clone</code> [地址或者项目的ssh]就好了。</p>
<h2 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin是远程仓库的别名，我这里用repo代替了。</span><br><span class="line"></span><br><span class="line">git branch -r //查看远程分支列表</span><br><span class="line"></span><br><span class="line">git branch apple //创建分支apple，现在这个分支还在本地</span><br><span class="line"></span><br><span class="line">git push repo apple //push这个apple分支到远程仓库repo上</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to=repo/apple apple //将repo仓库的远程分支apple和本地分支apple关联</span><br><span class="line"></span><br><span class="line">git push repo --delete apple  //将远程仓库repo的apple分支删除。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="git大文件上传"><a href="#git大文件上传" class="headerlink" title="git大文件上传"></a>git大文件上传</h2><p>需要 装Git LFS到git&#x2F;bin目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init #创建本地仓库环境</span><br><span class="line">git lfs install #安装大文件上传应用</span><br><span class="line">git lfs track * #追踪要上传的大文件，*表示路径下的所有文件</span><br><span class="line">git add .gitattributes #添加先上传的属性文件(要先上传属性文件，不然有可能失败)</span><br><span class="line">git commit -m &quot;pre&quot; #添加属性文件上传的说明</span><br><span class="line">git remote add origin https://github.com/Youpeng-Zhang/MOP.git #建立本地和Github仓库的链接</span><br><span class="line">git push origin master #上传属性文件</span><br><span class="line">git add * #添加要上传的大文件，*表示路径下的所有文件</span><br><span class="line">git commit -m &quot;Git LFS commit&quot; #添加大文件上传的说明</span><br><span class="line">git push origin master #上传大文件</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>C++笔记</title>
    <url>/2024/06/15/C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="C-笔记-上世纪國男"><a href="#C-笔记-上世纪國男" class="headerlink" title="C++笔记-上世纪國男"></a>C++笔记-上世纪國男</h5><p>笔记，忘了就回来看看。</p>
<h5 id="C与C-的区别-一"><a href="#C与C-的区别-一" class="headerlink" title="C与C++的区别** (一)"></a>C与C++的区别** (一)</h5><ul>
<li><p>命名空间</p>
<ul>
<li>基本语法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空间名</span></span><br><span class="line"><span class="keyword">namespace</span>  标识符</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//变量</span></span><br><span class="line">    <span class="comment">//函数</span></span><br><span class="line">    <span class="comment">//结构体</span></span><br><span class="line">    <span class="comment">//类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> MM</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何访问空间中的东西： 空间名::空间中的成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本访问方式</span></span><br><span class="line"><span class="comment">//相对于C语言来说，需要一个前缀</span></span><br><span class="line"><span class="comment">//::  作用域分辨符</span></span><br><span class="line">MM::age=<span class="number">1001</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(MM::name,<span class="string">&quot;灰姑凉&quot;</span>);</span><br><span class="line"><span class="comment">//省略前缀</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 空间名;    <span class="comment">//省略当前这个空间名</span></span><br></pre></td></tr></table></figure>

<p>使用using 语法注意点是: 防止空间变量或者函数不要和空间外的变量或者函数名字相同</p>
<ul>
<li>命名空间的嵌套</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">	<span class="keyword">namespace</span> B</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何访问: 剥洋葱</span></span><br><span class="line">A::num=<span class="number">1001</span>;</span><br><span class="line">A::B::age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//省略前缀</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A::B;</span><br><span class="line">num=<span class="number">1991</span>;</span><br><span class="line">age=<span class="number">1992</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++最简单的程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>头文件的改变<ul>
<li>标准输入输出头文件: #include <iostream></li>
<li>包含C语言的文件： #include <cxxx> 当然用#include &lt;xxx.h&gt;</li>
<li>自己写的头文件还是用C语言的方式包含  #include ”myhead.h“</li>
</ul>
</li>
<li>基本输出的改变： cout 加上&lt;&lt;<ul>
<li>不再需要格式控制字符</li>
<li>依然支持转移字符</li>
<li>换行： endl替换\n</li>
</ul>
</li>
<li>基本输入的改变： cin 加上&gt;&gt;<ul>
<li>不再不需要格式空字符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPrint</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> age=<span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>]=<span class="string">&quot;老babay&quot;</span>;</span><br><span class="line">	<span class="type">double</span> dNum=<span class="number">1.1</span>;</span><br><span class="line">	std::cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; dNum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;			<span class="comment">//一般情况这句话会写头文件下面</span></span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; dNum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; dNum &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout.put(&#x27;A&#x27;);  IO流中讲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testInput</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="comment">//单个数据输入</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入一个整数:&quot;</span>;</span><br><span class="line">	std::cin &gt;&gt; age;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;请输入name,age,num:&quot;</span>;</span><br><span class="line">	std::cin &gt;&gt; name &gt;&gt; age &gt;&gt; num;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testPrint</span>();</span><br><span class="line">	<span class="built_in">testInput</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++数据类型的改变</p>
<ul>
<li>空指针的改变: NULL  改为nullptr</li>
<li>bool类型引入<ul>
<li>赋值为: true ,false</li>
<li>非零值非空值表示成立，只有0和空表示不成立</li>
<li>bool占用字节数是1</li>
<li>打印结果只有两个值: true:1 false: 0</li>
<li>一般条件表达式或者逻辑表达式，或者充当开关变量，标记变量</li>
</ul>
</li>
</ul>
</li>
<li><p>引用类型： C++极其重要的类型</p>
<ul>
<li>基本用法: 起别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型&amp; 标识符<span class="number">1</span>=标识符<span class="number">2</span></span><br><span class="line"><span class="comment">//标识符2有一个别名字的叫做标识符1， 他们是一个东西</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常引用： 给常量起别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> 类型&amp; 标识符=常量;</span><br></pre></td></tr></table></figure>

<ul>
<li>右值引用: 给右值起别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型&amp;&amp; 标识符=右值</span><br></pre></td></tr></table></figure>

<ul>
<li>引用的用法<ul>
<li>当做函数参数:防止拷贝本的产生</li>
<li>当做函数返回值： 增加左值使用用法(等效返回值一个变量)</li>
</ul>
</li>
<li>自动推断类型： auto类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">(<span class="type">int</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Reference types 引用类型</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">returnValue</span><span class="params">(<span class="type">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">returnValueReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num;			<span class="comment">//warning C4172: 返回局部变量或临时变量的地址: num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapC</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  <span class="comment">//int a=实参1  int b=实参2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SwapCpp</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> <span class="comment">//int &amp;a =实参1 ，int &amp;b=实参2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//以后想要在子函数中修改什么，传入相应的引用</span></span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>* &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p = &amp;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const在C++上面更为严格，类型需要严重性的一致</span></span><br><span class="line"><span class="comment">//如果你想要既可以传入常量也可以传入变量，需要const修饰</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">printConstValue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只需要传入常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOnlyConstValue</span><span class="params">(<span class="type">int</span>&amp;&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testReferenceTypes</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//3.1 基本用法</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b = a;					<span class="comment">//a就是b b就是a</span></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//int&amp; constNum = 12;		//常量的引用，这样是错误的 </span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; constNum = <span class="number">12</span>;</span><br><span class="line">	<span class="comment">//右值引用也可以表示常量</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; rightValue = <span class="number">1001</span>;</span><br><span class="line">	<span class="comment">//3.2 引用的用法</span></span><br><span class="line">	<span class="comment">//充当函数参数：防止拷贝本产生</span></span><br><span class="line">	<span class="comment">//当做函数返回值: 增加左值使用  不能返回局部变量引用</span></span><br><span class="line">	<span class="comment">//返回值是一个值</span></span><br><span class="line">	<span class="comment">//returnValue(num) = 12;		//错误</span></span><br><span class="line">	<span class="comment">//1 = 2;</span></span><br><span class="line">	<span class="built_in">returnValueReference</span>() = <span class="number">1111</span>;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//充当函数</span></span><br><span class="line">	<span class="type">int</span> aa = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> bb = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">SwapC</span>(aa, bb);</span><br><span class="line">	cout &lt;&lt; aa &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; bb &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">SwapCpp</span>(aa, bb);  <span class="comment">//注意不需要取地址传参</span></span><br><span class="line">	cout &lt;&lt; aa &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; bb &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">modify</span>(p);</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//常引用传参</span></span><br><span class="line">	<span class="built_in">printConstValue</span>(<span class="string">&quot;ILoveyou&quot;</span>);</span><br><span class="line">	<span class="comment">//右值引用当做函数参数，只能传入右值</span></span><br><span class="line">	<span class="built_in">printOnlyConstValue</span>(<span class="number">1212</span>);</span><br><span class="line">	<span class="comment">//move可以把左值变成右值</span></span><br><span class="line">	<span class="built_in">printOnlyConstValue</span>(<span class="built_in">move</span>(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//auto类型</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMax</span><span class="params">(<span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testAuto</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//5.1 不能单独定义变量</span></span><br><span class="line">	<span class="comment">//auto a;  错误</span></span><br><span class="line">	<span class="comment">//5.2 auto一般结合赋值使用</span></span><br><span class="line">	<span class="keyword">auto</span> intNum = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; intNum &lt;&lt; endl;   <span class="comment">//int</span></span><br><span class="line">	<span class="built_in">int</span> (*pMax)(<span class="type">int</span>, <span class="type">int</span>) = Max;</span><br><span class="line">	<span class="keyword">auto</span> ppMax = Max;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ppMax</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">auto</span> pp = printMax;</span><br><span class="line">	<span class="built_in">pp</span>(ppMax, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.基本数据类型的改变</span></span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//2.bool类型引入</span></span><br><span class="line">	<span class="type">bool</span> bNum = <span class="literal">true</span>;		<span class="comment">//正常赋值,用true和false</span></span><br><span class="line">	<span class="comment">//非正常的赋值</span></span><br><span class="line">	bNum = <span class="number">-111</span>;</span><br><span class="line">	cout &lt;&lt; bNum &lt;&lt; endl;	<span class="comment">//1</span></span><br><span class="line">	<span class="comment">//3.引用类型</span></span><br><span class="line">	<span class="built_in">testReferenceTypes</span>();</span><br><span class="line">	<span class="comment">//4. :: 作用分辨符</span></span><br><span class="line">	<span class="comment">//就近原则</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">100000</span>;</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ::num &lt;&lt; endl;		<span class="comment">//代表是全局区变量</span></span><br><span class="line">	<span class="comment">//5.自动推断类型</span></span><br><span class="line">	<span class="built_in">testAuto</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++函数的改变 </p>
<ul>
<li><p>内联思想： 函数以二进制形式存在，去提高效率</p>
<ul>
<li>内联函数：用inline修饰的函数</li>
<li>短小精悍</li>
<li>在结构体中或者类型实现的函数，默认为内联</li>
</ul>
</li>
<li><p>重载思想： C++允许同名不同参的函数存在</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同(建立在存在不同类型)</li>
<li>常属性的成员函数和类中的普通函数重载  (类中会讲)</li>
</ul>
</li>
<li><p>缺省思想： 给函数形参初始化，达到不同形态的函数调用</p>
<ul>
<li>缺省的顺序 必须是从右往左，连续缺省</li>
<li>缺省时候，要避免存在普通函数，防止存在二义性</li>
</ul>
</li>
<li><p>Lambda表达式： 函数的定义 并且返回一个函数指针，所以一般在C++中会结合auto使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[捕获方式](函数参数)能否修改 是否存在异常-&gt;函数返回值类型&#123;函数体;&#125;;</span><br><span class="line">捕获方式: 理解使用函数外面的变量的方式</span><br><span class="line"><span class="number">1.</span>[]</span><br><span class="line"><span class="number">2.</span>[=] </span><br><span class="line"><span class="number">3.</span>[&amp;]</span><br><span class="line"><span class="number">4.</span>[&amp;x,=]</span><br><span class="line"><span class="number">5.</span>[<span class="keyword">this</span>]  类中数据成员的捕获</span><br><span class="line">函数参数： 自己写函数的时候的函数参数</span><br><span class="line">能否修改: <span class="keyword">mutable</span></span><br><span class="line">是否存在异常: <span class="built_in">throw</span>() 不存在异常</span><br><span class="line">函数返回值类型:自己写函数的时候的函数返回值</span><br><span class="line">函数体： 原来函数的函数体</span><br><span class="line"><span class="comment">//注意点： 一般在用的时候，能否修改 是否存在异常-&gt;函数返回值类型 是可以省略</span></span><br><span class="line">[捕获方式](函数参数)&#123;函数体;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.参数的数目不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b + c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.参数的类型不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.顺序不同</span></span><br><span class="line"><span class="comment">//错误，不可以跟上面函数构成重载</span></span><br><span class="line"><span class="comment">//void print(char b, char a) </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; a + b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> age, <span class="type">double</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> num, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//const属性不构成重载</span></span><br><span class="line"><span class="comment">//void print(int a) </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//void print(const int a) </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//4.缺省:不传入参数使用默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>, <span class="type">int</span> b=<span class="number">2</span>, <span class="type">int</span> c=<span class="number">3</span>,<span class="type">int</span> d=<span class="number">4</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a + b + c + d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.Lambda表达</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMax</span><span class="params">(<span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testLambda</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//最完整的Lambda表达式</span></span><br><span class="line">	<span class="comment">//int Max(int a, int b) </span></span><br><span class="line">	<span class="built_in">int</span>(*pMax)(<span class="type">int</span>, <span class="type">int</span>) = [](<span class="type">int</span> a, <span class="type">int</span> b)<span class="keyword">mutable</span> <span class="built_in">throw</span>()-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;;</span><br><span class="line">	<span class="comment">//一般用的时候，怎么简单怎么来，结合auto+省略的Lambda表达式去使用</span></span><br><span class="line">	<span class="keyword">auto</span> p= [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//进阶一下： 函数的定义和调用写在一起</span></span><br><span class="line">	cout &lt;&lt; [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a &gt; b ? a : b; &#125;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMax</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a + b; &#125;, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printMax</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;<span class="keyword">return</span> a - b; &#125;, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//捕获方式</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//[]() &#123;cout &lt;&lt; num &lt;&lt; endl; &#125;;错误  没有捕获方式，表示没用权力</span></span><br><span class="line">	<span class="keyword">auto</span> p1=[=]() &#123;cout &lt;&lt; num &lt;&lt; endl; &#125;;</span><br><span class="line">	<span class="keyword">auto</span> p2 = [&amp;]() &#123;cout &lt;&lt; num &lt;&lt; endl; &#125;;</span><br><span class="line">	<span class="built_in">p1</span>();					<span class="comment">//打印1</span></span><br><span class="line">	<span class="built_in">p2</span>();</span><br><span class="line">	num = <span class="number">1001</span>;</span><br><span class="line">	<span class="built_in">p1</span>();					<span class="comment">//不会因为值的改变而改变调用  ，打印1</span></span><br><span class="line">	<span class="built_in">p2</span>();</span><br><span class="line">	<span class="comment">//[this] 后面讲了类的时候在讲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Max</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1.1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printValue</span>();			<span class="comment">//a=1,b=2,c=3,d=4;</span></span><br><span class="line">	<span class="built_in">printValue</span>(<span class="number">11</span>);			<span class="comment">//a=11,b=2,c=3,d=4;</span></span><br><span class="line">	<span class="built_in">printValue</span>(<span class="number">11</span>, <span class="number">22</span>);       <span class="comment">//a=11,b=22,c=3,d=4</span></span><br><span class="line">	<span class="built_in">testLambda</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="C与C-的区别-二）"><a href="#C与C-的区别-二）" class="headerlink" title="C与C++的区别 (二）"></a><strong>C与C++的区别</strong> (二）</h5><ul>
<li><p>动态申请内存的区别</p>
<ul>
<li>C语言中申请内存: realloc malloc calloc  C++中只有new</li>
<li>C语言释放内存: free   C++中 delete</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  <span class="comment">//和#include &lt;string&gt;有区别	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testNewMemory</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.申请单个变量内存</span></span><br><span class="line">	<span class="type">int</span>* pC = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">assert</span>(pC);</span><br><span class="line">	*pC = <span class="number">123</span>;</span><br><span class="line">	<span class="built_in">free</span>(pC);</span><br><span class="line">	pC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="type">int</span>* cpp = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">	*cpp = <span class="number">123</span>;</span><br><span class="line">	cout &lt;&lt; *cpp &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> cpp;</span><br><span class="line">	cpp = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//2.申请一段内存   一维数组</span></span><br><span class="line">	<span class="type">int</span>* pcArray = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>);  <span class="comment">//int pcArray[3];</span></span><br><span class="line">	<span class="built_in">assert</span>(pcArray);</span><br><span class="line">	pcArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; pcArray[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">free</span>(pcArray);</span><br><span class="line">	pcArray = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="type">int</span>* cppArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];    <span class="comment">//int cppArray[3];</span></span><br><span class="line">	cppArray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; cppArray[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] cppArray;</span><br><span class="line">	cppArray = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//3.申请内存并做初始化</span></span><br><span class="line">	<span class="comment">//C语言有一个calloc</span></span><br><span class="line">	<span class="comment">//3.1 单个数据用()</span></span><br><span class="line">	<span class="type">int</span>* pNum = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);      <span class="comment">//*pNum=100</span></span><br><span class="line">	cout &lt;&lt; pNum &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> pNum;</span><br><span class="line">	pNum = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//3.2 多个数据用&#123;&#125;</span></span><br><span class="line">	<span class="type">int</span>* pArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;  <span class="comment">//int pArray[3]=&#123;1,2,3&#125;;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pArray[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++允许你重新管理申请堆内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testReNew</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* sum = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="comment">//前面十六个字节存放4个整数</span></span><br><span class="line">	<span class="comment">//(sum + 0)代表是从那个位置开始申请</span></span><br><span class="line">	<span class="type">int</span>* pInt = <span class="built_in">new</span>(sum + <span class="number">0</span>) <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="comment">//来10个字节存储字符串</span></span><br><span class="line">	<span class="type">char</span>* pstr = <span class="built_in">new</span>(pInt + <span class="number">4</span>) <span class="type">char</span>[<span class="number">10</span>]&#123;<span class="string">&quot;ILoveyou&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//等效：char* pstr = new(sum + 16) char[10]&#123;&quot;ILoveyou&quot;&#125;;</span></span><br><span class="line">	cout &lt;&lt; sum + <span class="number">16</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pstr &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	<span class="keyword">delete</span>[] sum;</span><br><span class="line">	sum = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testUserData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//结构体不需要struct关键字</span></span><br><span class="line">	<span class="comment">//单一结构体也是&#123;&#125;初始化</span></span><br><span class="line">	MM* pMM = <span class="keyword">new</span> MM &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">18</span> &#125;;</span><br><span class="line">	cout &lt;&lt; pMM-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pMM-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testNewMemory</span>();</span><br><span class="line">	<span class="built_in">testReNew</span>();</span><br><span class="line">	<span class="built_in">testUserData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++结构体的基本区别</p>
<ul>
<li>类型上： 不在需要struct ，直接结构体名可以充当类型，.c文件必须struct关键字</li>
<li>访问方式和C语言没区别<ul>
<li>必须要用结构体变量访问</li>
<li>变量访问的方式： 变量.成员</li>
<li>指针表示，访问: 指针-&gt;成员</li>
</ul>
</li>
<li>C++结构体中允许存在函数<ul>
<li>结构体中的函数如何访问数据：直接访问</li>
<li>结构体中函数如何在类外实现：函数名必须要用：结构体名::函数名</li>
<li>通过结构体中的函数去设置结构体数据</li>
<li>C++结构体申请内存</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MM</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//数据成员</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="comment">//成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printData</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* mmName, <span class="type">int</span> mmAge)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::printData</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MM::setData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* mmName, <span class="type">int</span> mmAge)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy_s</span>(name,<span class="number">20</span>, mmName);    <span class="comment">//&quot;宝宝&quot;</span></span><br><span class="line">	age = mmAge;				  <span class="comment">//19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testCppStruct</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.基本的访问方式</span></span><br><span class="line">	MM mm = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">19</span> &#125;;</span><br><span class="line">	cout &lt;&lt; mm.name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; mm.age &lt;&lt; endl;</span><br><span class="line">	MM* pMM = &amp;mm;</span><br><span class="line">	cout &lt;&lt; pMM-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; pMM-&gt;age &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.C++结构体中的函数的访问</span></span><br><span class="line">	mm.<span class="built_in">print</span>();						<span class="comment">//打印就是mm.name,mm.age</span></span><br><span class="line">	pMM-&gt;<span class="built_in">print</span>();</span><br><span class="line">	MM baby = &#123; <span class="string">&quot;baby&quot;</span>,<span class="number">19</span> &#125;;</span><br><span class="line">	baby.<span class="built_in">print</span>();					<span class="comment">//baby.name, baby.age</span></span><br><span class="line">	baby.<span class="built_in">printData</span>();</span><br><span class="line">	<span class="comment">//3.通过函数去描述行为</span></span><br><span class="line">	MM boy;</span><br><span class="line">	boy.<span class="built_in">setData</span>(<span class="string">&quot;宝宝&quot;</span>, <span class="number">19</span>);			<span class="comment">//boy.name=&quot;宝宝&quot;，boy.age=19</span></span><br><span class="line">	boy.<span class="built_in">print</span>();					<span class="comment">//boy.name ,boy.age</span></span><br><span class="line">	<span class="comment">//4.C++结构体申请内存</span></span><br><span class="line">	<span class="comment">//这种写法是建立在没有构造函数的基础下是对的</span></span><br><span class="line">	MM* p = <span class="keyword">new</span> MM;</span><br><span class="line">	p-&gt;<span class="built_in">setData</span>(<span class="string">&quot;申请内存&quot;</span>, <span class="number">199</span>);</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	MM* pArray = <span class="keyword">new</span> MM[<span class="number">3</span>];    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		pArray[i].<span class="built_in">setData</span>(<span class="string">&quot;数组&quot;</span>, i + <span class="number">19</span>);</span><br><span class="line">		pArray[i].<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] pArray;</span><br><span class="line">	pArray = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testCppStruct</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++中string： 本节课只需要知道如何使用C++string即可，不需要知道为什么这样用</p>
<ul>
<li>首先需要知道C++string 是一个类，头文件是#include<string></li>
<li>如何使用C++string</li>
<li>string 中的一些函数操作 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/basic-string-class?view=msvc-160">basic_string 类 | Microsoft Docs</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testCppString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.常用的创建方式</span></span><br><span class="line">	<span class="comment">//1.1常用的创建方式</span></span><br><span class="line">	string str1;				<span class="comment">//类似创建变量的方式</span></span><br><span class="line">	std::string noStd;			<span class="comment">//没有using namespace std ,也需要加前缀</span></span><br><span class="line">	str1 = <span class="string">&quot;ILoveyou&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	<span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;ILoveyou&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">	<span class="function">string <span class="title">str3</span><span class="params">(str2)</span></span>;</span><br><span class="line">	cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//1.2不常用</span></span><br><span class="line">	<span class="function">string <span class="title">str4</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;O&#x27;</span>)</span></span>;				<span class="comment">//str4=&quot;OOOOO&quot;;</span></span><br><span class="line">	cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">	<span class="function">string <span class="title">str5</span><span class="params">(<span class="string">&quot;Iloveyou&quot;</span>, <span class="number">1</span>, <span class="number">5</span>)</span></span>;		<span class="comment">//从0开始，用第一个到第五个字符初始化</span></span><br><span class="line">	cout &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.基本操作</span></span><br><span class="line">	<span class="comment">//2.1string里面有一个函数可以表示字符串属性</span></span><br><span class="line">	cout &lt;&lt; str5.<span class="built_in">size</span>() &lt;&lt; endl;		<span class="comment">//元素个数</span></span><br><span class="line">	cout &lt;&lt; str5.<span class="built_in">length</span>() &lt;&lt; endl;		<span class="comment">//长度</span></span><br><span class="line">	cout &lt;&lt; str5.<span class="built_in">capacity</span>() &lt;&lt; endl;	<span class="comment">//容量</span></span><br><span class="line">	string  longStr = <span class="string">&quot;12345678910123423&quot;</span>;</span><br><span class="line">	cout &lt;&lt; longStr.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//2.2 常规操作</span></span><br><span class="line">	<span class="comment">//比较，直接比即可  所有条件运算符直接用</span></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line">	cout &lt;&lt; (longStr &gt; str5) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (longStr == str5) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (longStr != str5) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//连接直接用+</span></span><br><span class="line">	string strF = <span class="string">&quot;First&quot;</span>;</span><br><span class="line">	string strS = <span class="string">&quot;Second&quot;</span>;</span><br><span class="line">	string result = strF + strS;</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//3.string与char* 转换</span></span><br><span class="line">	<span class="comment">//不能用%s方式直接打印string</span></span><br><span class="line">	<span class="comment">//调用string类中两个函数</span></span><br><span class="line">	<span class="comment">//data() ,c_str()</span></span><br><span class="line">	<span class="function">string <span class="title">info</span><span class="params">(<span class="string">&quot;C++中的string&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, info.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, info.<span class="built_in">data</span>());</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	string strName = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	<span class="built_in">strcpy_s</span>(name, <span class="number">20</span>, strName.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">	<span class="comment">//4.下表法访问string</span></span><br><span class="line">	string pStr = <span class="string">&quot;ILoveyou&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pStr.<span class="built_in">length</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pStr.<span class="built_in">at</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; pStr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testCppString</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++类型转换 </p>
<ul>
<li>基本数据类型转换: 类型(变量)</li>
<li>static_cast<ul>
<li>可以用做基本数据类型转换</li>
<li>把空类型的指针转换为目标指针类型</li>
<li>不能转换带有const属性指针</li>
</ul>
</li>
<li>const_cast： const属性指针的一些转换操作</li>
<li>reinterpret_cast：指针转整数，整数转指针</li>
<li>dynamic_cast    :后续讲完多态在给同学们讲解</li>
</ul>
</li>
</ul>
<h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><p>写两个子函数</p>
<ul>
<li>第一个子函数，实现二维数组的内存申请</li>
<li>第二个子函数，实现内存释放</li>
</ul>
<h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><ul>
<li>类和对象<ul>
<li>什么是类? 类是一些具有共同属性和行为的事物的抽象</li>
<li>什么是对象? 类的具体化(实例化)，明确属性和行为</li>
<li>属性: 数据成员(int，float，char…)描述， 一系列事物公有特征</li>
<li>行为: 成员函数(类中函数)描述,一系列公有事物共同操作</li>
</ul>
</li>
<li>类的特点<ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
<li>抽象性</li>
<li>隐藏性</li>
</ul>
</li>
<li>学会创建类的语法<ul>
<li>权限限定词:public,protected,private，在结构体中也是可以使用</li>
<li>类中默认是private属性，结构体中默认是public属性</li>
<li>权限限定词作用是用来限定类外对类中数据访问<ul>
<li>一般情况类外访问类中数据必须通过对象来访问，所以我们写C++程序，做的第一件事是创建对象</li>
<li>权限限定词是可以多个，或者没有</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:			<span class="comment">//公有</span></span><br><span class="line"><span class="keyword">protected</span>:		<span class="comment">//保护</span></span><br><span class="line"><span class="keyword">private</span>:    	<span class="comment">//私有</span></span><br><span class="line">&#125;;  <span class="comment">//分号必须要有的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>明白类中的权限问题<ul>
<li>静态数据成员和静态成员也受权限限定，可以不需要对象也可以调用</li>
<li>类外只能访问public属性，别的属性都不能被访问，类中没有权限限定</li>
<li>protected和private 在继承中有区别，目前不需要知道</li>
</ul>
</li>
<li>学会如何访问类中的数据<ul>
<li>类中数据可以直接初始化</li>
<li>接口的概念，C++当中一般指是public属性下方法(成员函数)</li>
<li>两种修改类中数据的方式<ul>
<li>通过提供一个带参的函数去修改数据成员</li>
<li>通过返回引用的方式修改数据成员</li>
</ul>
</li>
</ul>
</li>
<li>C++各种对象的形式对类中数据的访问<ul>
<li>普通对象<ul>
<li>注意权限问题，类外只能访问public属性下内容</li>
<li>对象用: 对象.成员</li>
</ul>
</li>
<li>对象数组</li>
<li>对象指针<ul>
<li>可以用指针指向运算符(-&gt;)访问 ：指针-&gt;成员</li>
<li>也可以用(*指针).成员</li>
</ul>
</li>
<li>对象本身就是一个数据，所以普通数据能做他都可以做<ul>
<li>当做函数返回值</li>
<li>当做函数参数</li>
<li>当做变量赋值</li>
</ul>
</li>
<li>this指针<ul>
<li>this指针可以解决形参名和数据成员名字相同的问题</li>
<li>可以函数充当函数返回值</li>
</ul>
</li>
<li>类的成员函数的表示方式<ul>
<li>如何定义一个类的成员函数的指针</li>
<li>如果通过成员函数的函数指针调用函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h5><ul>
<li>构造函数<ul>
<li>没有返回值</li>
<li>函数名和类名相同</li>
<li>构造对象的时候被调用</li>
<li>构造函数一般情况都是用来数据成员初始化</li>
<li>一般情况构造函数是public属性</li>
<li>默认的拷贝构造函数是没有参数，无参构造函数,一旦自己写构造函数，默认的就不存在</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>拷贝构造函数也是构造函数,具有构造函数相同属性</li>
<li>拷贝构造函数只有一个参数，就是对对象的引用</li>
<li>拷贝构造主要是为了实现通过一个对象去创建对象</li>
</ul>
</li>
<li>析构函数<ul>
<li>函数名: ~类名</li>
<li>析构函数没有参数</li>
<li>public属性</li>
<li>不写析构存在一个默认的析构</li>
<li>析构函数是对象死亡的时候(生命周期结束)，自动调用，不需要人调用</li>
<li>什么时候需要手动写析构函数，当类中的数据成员做到了内存申请的时候，需要手动写析构函数</li>
</ul>
</li>
<li>深拷贝和浅拷贝： 当数据成员是指针的时候，并做内存申请</li>
<li>默认的函数的相关操作<ul>
<li>我们可以删除默认的函数，用delete删除</li>
<li>我们使用默认的函数，用default函数</li>
</ul>
</li>
</ul>
<h5 id="C-特殊成员"><a href="#C-特殊成员" class="headerlink" title="C++特殊成员"></a>C++特殊成员</h5><ul>
<li><p>const成员</p>
<ul>
<li><p>常数据成员： const修饰的数据成员</p>
<ul>
<li>const属性代表只读(不可以修改)</li>
<li>常数据成员的初始化必须要采用初始化参数列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化参数列表</span></span><br><span class="line">类名(变量<span class="number">1</span>，变量<span class="number">2</span>,...):数据成员<span class="number">1</span>(变量<span class="number">1</span>)，数据成员<span class="number">2</span>(变量<span class="number">2</span>)...&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常成员函数:  const修饰的成员成员函数,注意写法，const是放在函数后面</p>
<ul>
<li>在当前常成员函数中不能修改数据成员</li>
<li>常成员可以和普通同时存在</li>
</ul>
</li>
<li><p>常对象: const 修饰对象</p>
<ul>
<li>常对象只能调用常成员函数</li>
</ul>
</li>
</ul>
</li>
<li><p>static成员</p>
<ul>
<li>static数据成员<ul>
<li>必须在类外做初始化</li>
<li>静态数据成员是属于类的，不属于对象，是所有对象共有，也就是说所有对象用的是一个数据</li>
<li>静态数据成员访问不需要对象，可以直接用类名限定访问: 类名::成员</li>
<li>静态数据成员也受权限限定</li>
</ul>
</li>
<li>static成员函数<ul>
<li>访问可以不需要对象，用对象访问也可以的</li>
<li>也受权限限定</li>
<li>静态成员函数不能直接访问非静态数据成员,只能通过指定访问</li>
</ul>
</li>
<li>static对象<ul>
<li>保留上一次运行的结果，初始化操作只做一次</li>
</ul>
</li>
</ul>
</li>
<li><p>类的组合 ：一个类是另一个类一部分</p>
<ul>
<li>构造函数的的写法：必须采用初始化参数列表</li>
<li>构造的顺序(考试)<ul>
<li>组合类中构造顺序和初始化参数列表写的顺序无关，只和声明顺序有关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="C-友元"><a href="#C-友元" class="headerlink" title="C++友元"></a>C++友元</h5><ul>
<li>友元函数：单纯提供一个场所给予类的对象具有无视权限的功能<ul>
<li>普通函数成为友元： 再类中用friend 声明即可</li>
<li>以另一个类的成员函数成为友元函数</li>
</ul>
</li>
<li>友元类</li>
</ul>
<h5 id="C-类的继承"><a href="#C-类的继承" class="headerlink" title="C++类的继承"></a>C++类的继承</h5><ul>
<li>继承基本语法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类名: 继承方式 父类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承方式: 权限限定词</span></span><br><span class="line"><span class="comment">//public  公有</span></span><br><span class="line"><span class="comment">//protected: 保护</span></span><br><span class="line"><span class="comment">//private: 私有继承</span></span><br><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//生成新的属性和行为</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承的实质: 父类(基类)当中的属性，子类(派生类)中也有一份，这一份的属性是由继承方式的决定的。</p>
<ul>
<li>继承权限问题</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>public ：继承</td>
<td>public</td>
<td>protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>protected：继承</td>
<td>protected</td>
<td>protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>private:继承</td>
<td>private</td>
<td>private</td>
<td>不可访问</td>
</tr>
</tbody></table>
<ul>
<li>继承具有遗传性</li>
</ul>
<p>继承的属性是一值存在的，无论被继承多少代，都是存在，所以一般类的击沉不会写太多层数，导致类很冗长。</p>
<ul>
<li><p>继承中的构造函数</p>
<ul>
<li>子类构造函数必须要调用父类的构造函数</li>
<li>子类的构造函数必须采用初始化列表的写法去初始化继承下来的属性</li>
</ul>
</li>
<li><p>继承的分类</p>
<ul>
<li>单继承：只有一个父类</li>
<li>多继承: 2个或者以上的父类<ul>
<li>菱形继承</li>
</ul>
</li>
</ul>
</li>
<li><p>继承中的同名访问问题  &#x2F;&#x2F;21:20继续</p>
<ul>
<li>正常赋值的访问：  默认访问方式采用就近原则,当然可以采用类名限定指定的方式</li>
<li>非正常赋值的访问： 没有virtual看指针类型</li>
</ul>
</li>
<li><p>继承的作用：</p>
<p>抽象中的抽象。其实大家在使用继承的时候，更多的是继承别人的东西</p>
<p>自己设计代码采用继承的方式，更多增加代码的重用性</p>
</li>
</ul>
<p>C++继承作业: 抽象画图工具的工具类</p>
<h5 id="C-虚函数和多态"><a href="#C-虚函数和多态" class="headerlink" title="C++虚函数和多态"></a>C++虚函数和多态</h5><ul>
<li>虚函数与虚函数表</li>
<li>纯虚函数和抽象类</li>
<li>多态</li>
<li>ADT过程和虚析构函数</li>
<li>dynamic下行转换和交叉转换  </li>
<li>类中类的访问</li>
</ul>
<h5 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h5><ul>
<li>函数模板</li>
<li>类模板</li>
<li>模板特化</li>
</ul>
<h5 id="C-可变参模板"><a href="#C-可变参模板" class="headerlink" title="C++可变参模板"></a>C++可变参模板</h5><ul>
<li>可变参函数模板<ul>
<li>折叠参数类型的定义 : typename …Arg  </li>
<li>折叠参数的定义: Arg  …arg;</li>
<li>如何展开折叠参数<ul>
<li>递归的方式去展开参数包</li>
<li>通过列表({}的数据)展开参数包</li>
</ul>
</li>
</ul>
</li>
<li>可变参类模板： 类模板用到可变参数<ul>
<li>继承+模板特化的方式展开</li>
<li>递归的方式展开参数包</li>
</ul>
</li>
<li>标准库中的可变参模板<ul>
<li>包含头文件：#include <tuple></li>
<li>如何创建</li>
<li>如何获取数据</li>
<li>其他操作</li>
</ul>
</li>
</ul>
<h5 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h5><p>​	智能指针本质就是一个模板类，通过类的对象生命周期的自动结束效果，实现内存的自动释放。也就是把指针当做对象去处理，所以一般不会去new一个智能指针，自己new还是需要自己手动释放，一般都是创建一个智能指针对象，去管理堆区的变量。</p>
<ul>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>unique_ptr</li>
</ul>
<h5 id="C-类型推断"><a href="#C-类型推断" class="headerlink" title="C++类型推断"></a>C++类型推断</h5><ul>
<li>auto</li>
<li>decltype</li>
</ul>
<h5 id="C-IO流"><a href="#C-IO流" class="headerlink" title="C++IO流"></a>C++IO流</h5><ul>
<li>输入输出流</li>
<li>字符流</li>
<li>文件流</li>
</ul>
<h5 id="C-正则表达式"><a href="#C-正则表达式" class="headerlink" title="C++正则表达式"></a>C++正则表达式</h5><p>正则是一种规则，它用来匹配（进而捕获、替换）字符串。这种规则需要“模式”、“字符串”这两样东西，“模式”根据正则规则，来处理“字符串”。这种规则被许多语言支持，C++11以后才支持正则。</p>
<h6 id="具有特殊意义的元字符"><a href="#具有特殊意义的元字符" class="headerlink" title="具有特殊意义的元字符"></a>具有特殊意义的元字符</h6><p>\：\字符能够改变字符原本的含义</p>
<p>^：^字符指示字符串的头，且要求字符串以字符开头，不占位。^表示一个真正的^符号。</p>
<p>$：$字符指示字符串的尾，且要求字符串以字符结尾，不占位。$表示一个真正的$符号。</p>
<p>\b：指示字符串的边界（头&#x2F;尾&#x2F;空格左&#x2F;空格右），字符\b要求边界的左边是字符，\b字符要求边界的右边是字符。</p>
<p>.：表示一个除了\n以外的任意一个字符。\.表示一个真正的.符号。</p>
<p>|：a|b  a或b之一</p>
<p>[abc]：abc之中的任意一个</p>
<p>[^abc]:  abc之外的</p>
<p>[a-z]:	任意小写字母</p>
<p>[^a-z]:  除了小写字母之外的</p>
<p>\w：任意一个字母数字下划线，等价于[(0-9)(a-z)(A-Z)(_)]</p>
<p>\W：字母数字下划线之外的，等价于[]</p>
<p>\d:	任意一个数子</p>
<p>\D:	除了数字之外的</p>
<p>\s:	空白符（空格、制表符、换页符）</p>
<h5 id="C-日期时间库"><a href="#C-日期时间库" class="headerlink" title="C++日期时间库"></a>C++日期时间库</h5><ul>
<li>时间间隔 duration</li>
<li>时钟 clock()</li>
<li>时间点 time point</li>
<li>时间转换</li>
</ul>
<h5 id="时间间隔duration"><a href="#时间间隔duration" class="headerlink" title="时间间隔duration"></a>时间间隔duration</h5><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rep</span>, <span class="keyword">class</span> <span class="title class_">_Period</span> = ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ratio 代表的是一个分子除以分母的数值</span></span><br><span class="line"><span class="comment">ratio&lt;1,1000000000&gt;     纳秒</span></span><br><span class="line"><span class="comment">ratio&lt;1,1000000&gt; 		微秒</span></span><br><span class="line"><span class="comment">ratio&lt;1,1000&gt;	   		毫秒</span></span><br><span class="line"><span class="comment">ratio&lt;60*60*24&gt;			一天</span></span><br><span class="line"><span class="comment">ratio&lt;60*60&gt;			小时</span></span><br><span class="line"><span class="comment">ratio&lt;60&gt;				分钟</span></span><br><span class="line"><span class="comment">ratio&lt;1&gt;				秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>为了方便使用，在标准库中定义了一些常用的时间间隔时、分、秒、毫秒、微秒、纳秒</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>纳秒：<code>std::chrono::nanoseconds</code></td>
<td>duration&lt;long long, nano&gt;</td>
</tr>
<tr>
<td>微秒：<code>std::chrono::microseconds</code></td>
<td>duration&lt;long long, micro&gt;</td>
</tr>
<tr>
<td>毫秒：<code>std::chrono::milliseconds</code></td>
<td>duration&lt;long long, milli&gt;</td>
</tr>
<tr>
<td>秒：<code>std::chrono::seconds</code></td>
<td>duration<long long></td>
</tr>
<tr>
<td>分钟：<code>std::chrono::minutes</code></td>
<td>duration&lt;int, ratio&lt;60&gt;&gt;</td>
</tr>
<tr>
<td>小时：<code>std::chrono::hours</code></td>
<td>duration&lt;int, ratio&lt;3600&gt;&gt;</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1秒后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1秒后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	std::<span class="function">chrono::seconds  <span class="title">test</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; test.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">	std::<span class="function">chrono::hours  <span class="title">h</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	chrono::seconds result = h - test;</span><br><span class="line">	cout &lt;&lt; result.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; result &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="时钟clocks"><a href="#时钟clocks" class="headerlink" title="时钟clocks"></a>时钟clocks</h5><h6 id="system-clock"><a href="#system-clock" class="headerlink" title="system_clock"></a>system_clock</h6><p>系统范围的实时时钟,对当前时间点 time_point 的访问，将得到时间点转换为 time_t 类型的时间对象，就可以基于这个时间对象获取到当前的时间信息了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回表示当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//将 time_point 时间点类型转换为 std::time_t 类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//将 std::time_t 类型转换为 time_point 时间点类型</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取当前的系统时间:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://www.cplusplus.com/reference/chrono/time_point/time_point/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::system_clock::time_point result;</span><br><span class="line">	chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt; <span class="built_in">day</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//1970.1.1时间 + 1天</span></span><br><span class="line">	chrono::<span class="function">system_clock::time_point <span class="title">ppt</span><span class="params">(day)</span></span>; </span><br><span class="line">	<span class="comment">//1970.1.1时间 + 10天</span></span><br><span class="line">	chrono::<span class="function">system_clock::time_point <span class="title">t</span><span class="params">(chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt;(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="comment">//系统当前时间</span></span><br><span class="line">	chrono::system_clock::time_point tp = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="comment">//转换为time_t类型数据</span></span><br><span class="line">	<span class="type">time_t</span> tm = chrono::system_clock::<span class="built_in">to_time_t</span>(tp);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;今天日期:&quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm);</span><br><span class="line">	std::tm* p = <span class="built_in">localtime</span>(&amp;tm);</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;格式化输出时间:&quot;</span> &lt;&lt; <span class="built_in">put_time</span>(p, <span class="string">&quot;%F %X&quot;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;count:&quot;</span> &lt;&lt; tp.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="steady-clock"><a href="#steady-clock" class="headerlink" title="steady_clock"></a>steady_clock</h6><p>程序耗时的时长，此时使用 syetem_clock 就不合适了，因为这个时间可以跟随系统的设置发生变化。在 C++11 中提供的时钟类 steady_clock 相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。</p>
<p>计算程序执行期间消耗的总时长</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::steady_clock::time_point start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;start:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;运行中....&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	chrono::steady_clock::time_point end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">auto</span> dt = end - start;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;耗时:&quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ns&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="high-resolution-clock"><a href="#high-resolution-clock" class="headerlink" title="high_resolution_clock"></a>high_resolution_clock</h6><p>high_resolution_clock 提供的时钟精度比 system_clock 要高，它也是不可以修改的。在底层源码中，这个类其实是 steady_clock 类的别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::high_resolution_clock::time_point start = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;start:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;运行中....&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	chrono::high_resolution_clock::time_point end = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="keyword">auto</span> dt = end - start;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;耗时:&quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ns&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="时间转换函数"><a href="#时间转换函数" class="headerlink" title="时间转换函数"></a><strong>时间转换函数</strong></h5><h6 id="duration-cast"><a href="#duration-cast" class="headerlink" title="duration_cast"></a>duration_cast</h6><p>duration_cast 是 chrono 库提供的一个模板函数，这个函数不属于 duration 类。通过这个函数可以对 duration 类对象内部的时钟周期 Period，和周期次数的类型 Rep 进行修改</p>
<p>浮点时长和整数时长间转型能隐式进行无需使用 duration_cast ，其他情况下都需要通过函数进行转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::high_resolution_clock::time_point start = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;start:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;运行中....&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	chrono::high_resolution_clock::time_point end = chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="comment">//整数时长：要求 duration_cast</span></span><br><span class="line">	<span class="keyword">auto</span> dt = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end - start);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;耗时:&quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//小数时长：不要求 duration_cast</span></span><br><span class="line">	chrono::duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; dms = end - start;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;耗时:&quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="time-point-cast"><a href="#time-point-cast" class="headerlink" title="time_point_cast"></a>time_point_cast</h6><p>time_point_cast 也是 chrono 库提供的一个模板函数，这个函数不属于 time_point 类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期 Period，和周期次数的类型 Rep 可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Duration&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ms</span><span class="params">(<span class="type">const</span> chrono::time_point&lt;chrono::high_resolution_clock, Duration&gt;&amp; time_point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; time_point.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::time_point&lt;chrono::high_resolution_clock, chrono::milliseconds&gt; <span class="title">time_point_sec</span><span class="params">(chrono::seconds(<span class="number">6</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 无精度损失, 可以进行隐式类型转换</span></span><br><span class="line">    <span class="function">chrono::time_point&lt;chrono::high_resolution_clock, chrono::milliseconds&gt; <span class="title">time_point_ms</span><span class="params">(time_point_sec)</span></span>;</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_ms);    <span class="comment">// 6000 ms</span></span><br><span class="line"></span><br><span class="line">    time_point_ms = chrono::<span class="built_in">time_point</span>&lt;chrono::high_resolution_clock, chrono::milliseconds&gt;(chrono::<span class="built_in">milliseconds</span>(<span class="number">6789</span>));</span><br><span class="line">    <span class="comment">// error，会损失精度，不允许进行隐式的类型转换</span></span><br><span class="line">    <span class="comment">//chrono::time_point&lt;chrono::high_resolution_clock, chrono::seconds&gt; sec(time_point_ms);</span></span><br><span class="line">    <span class="comment">// 显示类型转换,会损失精度。6789 truncated to 6000</span></span><br><span class="line">    time_point_sec = std::chrono::<span class="built_in">time_point_cast</span>&lt;chrono::seconds&gt;(time_point_ms);</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_sec); <span class="comment">// 6000 ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：关于时间点的转换如果没有没有精度的损失可以直接进行隐式类型转换，如果会损失精度只能通过显示类型转换，也就是调用 time_point_cast 函数来完成该操作</p>
<h5 id="C-文件系统filesystem"><a href="#C-文件系统filesystem" class="headerlink" title="C++文件系统filesystem"></a>C++文件系统filesystem</h5><p>filesystem主要用来处理文件目录，也就是文件夹创建和删除，遍历，不是用来读写文件</p>
<h6 id="path类："><a href="#path类：" class="headerlink" title="path类："></a>path类：</h6><p>路径处理</p>
<h6 id="file-status类"><a href="#file-status类" class="headerlink" title="file_status类"></a>file_status类</h6><p>文件状态一些判断</p>
<h6 id="directory-entry类"><a href="#directory-entry类" class="headerlink" title="directory_entry类"></a>directory_entry类</h6><p>文件路口</p>
<h6 id="directory-iterator类"><a href="#directory-iterator类" class="headerlink" title="directory_iterator类"></a>directory_iterator类</h6><p>文件目录的遍历</p>
<p>filesystem中成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断path是否存在  不存在返回false 存在返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exists</span><span class="params">(file_status stat)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exists</span><span class="params">(<span class="type">const</span> path&amp; pval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">exists</span><span class="params">(<span class="type">const</span> path&amp; pval, error_code&amp; ec)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//构建目录的  只能构建一层目录</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> path&amp; pval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> path&amp; pval, error_code&amp; ec)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> path&amp; pval, <span class="type">const</span> path&amp; attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directory</span><span class="params">(<span class="type">const</span> path&amp; pval, <span class="type">const</span> path&amp; attr, error_code&amp; ec)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//构建目录，可以构建 a/b/c 这种目录</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directories</span><span class="params">(<span class="type">const</span> path&amp; pval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">create_directories</span><span class="params">(<span class="type">const</span> path&amp; pval, error_code&amp; ec)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2024/06/15/Markdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MARKOWN语法使用指南"><a href="#MARKOWN语法使用指南" class="headerlink" title="MARKOWN语法使用指南"></a>MARKOWN语法使用指南</h1><p>Markdown语法使用介绍</p>
<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>一个#加一个空格，就是一级标题&#x2F;&#x2F;快捷键是Ctrl+1（左边键盘的）</p>
<p>两个#加一个空格，就是二级标题&#x2F;&#x2F;快捷键是Ctrl+2  (左边键盘的)</p>
<p>以此类推…..</p>
<p>因此标题前面再按delete可以去除标题效果。</p>
<h2 id="1-2加粗"><a href="#1-2加粗" class="headerlink" title="1.2加粗"></a>1.2加粗</h2><p>使用两个*即可加粗。</p>
<p>比如：<strong>我是你爹</strong></p>
<p>可以让光标移到加粗字附近，就会发现有两个*展开了，按delete依旧可以去除加粗效果。</p>
<h2 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2.无序列表"></a>2.无序列表</h2><p>在每一行的开头使用一个-和一个空格即可完成一个无序列表符号</p>
<ul>
<li>这就是一个无序列表的符号</li>
<li>按下enter自动进行下一个无序列表符号</li>
<li>按两下enter自动把这无序列表取消</li>
</ul>
<p>这一行就取消了无序列表。</p>
<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><p>使用一个&gt;即可进行引用，&gt;必须在每一行开头。</p>
<blockquote>
<p>你妈没了</p>
<p>按两下enter换行就会断开&gt;，也就是断开引用</p>
<blockquote>
<p>可以进行重复引用，没啥软用</p>
</blockquote>
</blockquote>
<h2 id="4-分隔线"><a href="#4-分隔线" class="headerlink" title="4.分隔线"></a>4.分隔线</h2><p>连续使用三个***或者—或者___</p>
<p>比如：</p>
<hr>
<hr>
<hr>
<p>效果都是一样的，建议使用三个***，这个简单。</p>
<hr>
<p>另外这个必须在每一行开头写，不然也是没有用的。</p>
<h2 id="5-链接语法"><a href="#5-链接语法" class="headerlink" title="5.链接语法"></a>5.链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选</p>
<p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p>
<p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p>
<p>比如[链接语法](<a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法 | Markdown 官方教程</a>)，这里有三个标题，最后附加链接网址.</p>
<p><a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法 | Markdown 官方教程</a></p>
<h2 id="6-图片链接"><a href="#6-图片链接" class="headerlink" title="6.图片链接"></a>6.图片链接</h2><p>插入图片Markdown语法代码：<code>![自定义图片名称](图片链接 &quot;图片title&quot;)</code>。“图片title”可有可无。</p>
<p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p>
<p><img src="C:\Users\Han\Desktop\QQ群推广资料\21.png" alt="曼波"></p>
<p>曼波是本地图片，下面风景是网络图片。</p>
<p><img src="https://markdown.com.cn/assets/img/philly-magic-garden.9c0b4415.jpg" alt="111"></p>
<p>如图所示，Markdown能输出本地图片，也能输出网络图片。</p>
<p>Markdown只是引用图片，一旦图片网络位置改变，就显示不了图片了。</p>
<p>建议使用Markdown不要插入图片，使用文本和mermaid语音绘图即可。</p>
<h2 id="7-脚注"><a href="#7-脚注" class="headerlink" title="7.脚注"></a>7.脚注</h2><p>使用中文方括号[],里面加入 ^1,^2,^3……..以此类推。</p>
<p>然后鼠标放到脚注上点击www.什么什么的，就能在文末编辑脚注里面的内容。</p>
<p>比如这是一个脚注1：臭傻逼<a href="%E6%96%87%E6%9C%AB%E6%89%BE%E5%88%B0%E8%84%9A%E6%B3%A8%E7%9A%84%E6%B3%A8%E9%87%8A">^1</a></p>
<p>这是一个脚注2：大傻逼<a href="%E4%B8%8D%E7%82%B9%E5%87%BB%E8%93%9D%E8%89%B2%E7%9A%84www%E5%B0%B1%E4%B8%8D%E8%83%BD%E5%86%99%E6%B3%A8%E9%87%8A%E5%93%A6">^2</a></p>
<p>这是一个不点击蓝色www的脚注，没有脚注注释：烂逼[^3]</p>
<h2 id="8-文字删除线"><a href="#8-文字删除线" class="headerlink" title="8.文字删除线"></a>8.文字删除线</h2><p>使用两个~即可实现删除线：<del>字太丑了</del></p>
<h2 id="9-绘图-树状图"><a href="#9-绘图-树状图" class="headerlink" title="9.绘图-树状图"></a>9.绘图-树状图</h2><p>代码块里面输入以下内容即可生成对应的树状图,语言选择输入mermaid</p>
<p>graph TB;</p>
<p>A1(学习)–&gt;B2(吃饭)</p>
<p>A1(学习)–&gt;B1(打飞机)</p>
<p>B1(打飞机)–&gt;C1(睡觉)</p>
<p>如：（网页可能显示不出来）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">A1(学习)--&gt;B2(吃饭)</span><br><span class="line">A1(学习)--&gt;B1(打飞机)</span><br><span class="line">B1(打飞机)--&gt;C1(冷静)</span><br></pre></td></tr></table></figure>



<h2 id="10-绘制表情"><a href="#10-绘制表情" class="headerlink" title="10.绘制表情"></a>10.绘制表情</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。必须要使用英文冒号: 111 而不是中文冒号：111，发现没，冒号后面的空位大小不一样，中文冒号后面空位大。</p>
<p>比如：:tent:</p>
<p>:joy:</p>
<p>:black_joker:</p>
<p>:joy_cat:</p>
<h2 id="11-任务列表"><a href="#11-任务列表" class="headerlink" title="11.任务列表"></a>11.任务列表</h2><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<ul>
<li><input disabled="" type="checkbox"> 完成树状图</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">正文里面写这个：</span><br><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br><span class="line">每一个字符之间都有空格，-空格[空格]空格,一开始输入-号和空格的时候会生成一个黑点，不用管它，等你输入[ ]之后会自动修正的</span><br><span class="line">显示如下：</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> Write the press release</li>
<li><input disabled="" type="checkbox"> Update the website</li>
<li><input disabled="" type="checkbox"> Contact the media</li>
<li><input checked="" disabled="" type="checkbox"> lowercase checkmark</li>
</ul>
<h2 id="12-字体添加背景颜色"><a href="#12-字体添加背景颜色" class="headerlink" title="12.字体添加背景颜色"></a>12.字体添加背景颜色</h2><p>1.使用两个&#96;     （键盘左边数字1旁边那个键在英文输入法状态下就是这个符号 ）</p>
<p>即可把中间文字添加背景颜色，如<code>丁真：我测你妈~</code></p>
<p>2.使用&lt;&gt;+font color&#x3D;#十六进制颜色代码<font color=#aa8aa>把字体添加颜色</font>改成自己想要的颜色和大小，</p>
<p>在第一部分是&lt;&gt;中输入font color&#x3D;#aa8aa空格size&#x3D;1到9，数字越大字体越大，</p>
<p>第二部分就是你想要改颜色的文字了</p>
<p>第三部分就是&lt;&gt;里面输入&#x2F;font       这样就完成了！</p>
<p>比如：<font color=#088088 size=5>知识改变命运</font></p>
]]></content>
      <categories>
        <category>Markdown</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>AI工具以及使用</title>
    <url>/2024/06/15/ai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AI工具"><a href="#AI工具" class="headerlink" title="AI工具"></a>AI工具</h1><p>AI工具能方便项目更迅速的完成。不仅能写代码，还能检查bug，给予适当的建议，以及帮助我们快速制作视频、图片、音源等。</p>
<h1 id="1-Sovits"><a href="#1-Sovits" class="headerlink" title="1.Sovits"></a>1.Sovits</h1><p>根据模型更改视频人物的声音，代表视频有AI王心凌、AI爱莉希雅、AI熊大、AI懒洋洋等制作的’’活字印刷’’视频</p>
<h3 id="大致训练步骤"><a href="#大致训练步骤" class="headerlink" title="大致训练步骤"></a>大致训练步骤</h3><p>1.训练质量比数量重要，大约要高质量的音频90分钟</p>
<p>2.使用UVR5进行人声和背景音乐分离（保存为wav格式），步骤：MDX-Net 1024 0.75；VR—A 320 3 5_HP；VR-A UVR-DE-DE 320 3</p>
<p>3.使用RX10进行呼吸、降噪去除，具体步骤为：对话去除混响-&gt;呼吸（选中呼吸，编辑，查找类似事件，模块，渲染，静音）-&gt;去噪声（可选），保存为wav格式。</p>
<p>4.使用Audition Slicer对语音切片，单个语音15秒以内，必须是由字母、下划线、数字组成的wav格式。</p>
<p>5.把文件夹放在sovits-dataset_raw中，点击sovits里的bat文件开始训练，推荐使用vec768l12进行</p>
<p>6.训练好的模型文件.pth默认放在sovits文件的logs&#x2F;44k文件下。<br>  模型配置文件默认放在sovits文件的configs文件下。204364kb</p>
<p><strong>期间要使用UVR5、RX10、AUdition Slicer软件进行音视频操作。</strong></p>
<h3 id="Sovits设置使用"><a href="#Sovits设置使用" class="headerlink" title="Sovits设置使用"></a>Sovits设置使用</h3><p>1.模型文件必须包含.pth文件（模型文件）和.json文件（模型的配置文件）</p>
<p>2.不推荐扩散模型和聚类模型的配置（可有可无的），有也无伤大雅。</p>
<p>3.模型文件.pth默认放在sovits文件的logs&#x2F;44k文件下。</p>
<p>4.模型配置文件默认放在sovits文件的configs文件下。<br>推荐：<br>5.在sovits网页最下一行选择独立目录模式，把所有的模型文件、模型配置文件、扩散模型、扩散模型配置文件等，放在sovits的models文件中（注意要有方便记忆的模型名字，可以有中文，不然很多模型记不住的）</p>
<p>6.可以打开sovits进行换声了</p>
<h1 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2.GPT"></a>2.GPT</h1><p>这里提供两个免费的GPT网站：</p>
<p><a href="https://yiyan.baidu.com/">文心一言 (baidu.com)</a></p>
<p><a href="https://www.doubao.com/chat/39821039323906">豆包 - 抖音旗下 AI 智能助手 (doubao.com)</a></p>
<h1 id="3-文生图"><a href="#3-文生图" class="headerlink" title="3.文生图"></a>3.文生图</h1><p>网站：[SDXL Turbo 和 Stable Diffusion 3 免费在线生成器](<a href="https://sdxlturbo.ai/zh-CN/app?prompt=black">https://sdxlturbo.ai/zh-CN/app?prompt=black</a> flower)</p>
<h3 id="Stable-Diffusion使用"><a href="#Stable-Diffusion使用" class="headerlink" title="Stable Diffusion使用"></a>Stable Diffusion使用</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://docs.stablediffusion.cn/upload/image/20240204/1707056536878137.png"></p>
<p>①首先我们输入的提示词（prompt）会首先进入TE（TextEncoder），而clip就是stable diffusion所使用的TE。TE这部分的作用就是把tag转化成U-net网络能理解的embedding形式，当然了，我们平时用的emb模型，就是一种自然语言很难表达的promot。（简单的说就是将“人话”转换成AI能够理解的语言）</p>
<p>②将“人话”转换成AI能够理解的语言之后，U-net会对随机种子生成的噪声图进行引导，来指导去噪的方向，找出需要改变的地方并给出改变的数据。我们之前所设置的steps数值就是去噪的次数，所选择的采样器、CFG等参数也是在这个阶段起作用的。（简单的说就是U-net死盯着乱码图片，看他像什么，并给出更改的建议，使得图像更加想这个东西）</p>
<p>③一张图片中包含的信息是非常多的，直接计算会消耗巨量的资源，所以从一开始上面的这些计算都是在一个比较小的潜空间进行的。而在潜空间的数据并不是人能够正常看到的图片。这个时候就需要VAE用来将潜空间“翻译”成人能够正常看到的图片的（简单的说就是把AI输出翻译成人能看到的图片）</p>
<p>经过以上三个步骤，就实现了“提示词→图片”的转化，也就是AI画出了我们想要的图片。这三个步骤也就对应了模型的三个组成部分：clip、unet、VA</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这里推荐使用秋叶的LoRA模型训练包</p>
<p><a href="https://www.bilibili.com/video/BV1AL411q7Ub/">https://www.bilibili.com/video/BV1AL411q7Ub/</a></p>
<h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><p><a href="https://docs.qq.com/doc/DWEpNdERNbnBRZWNL">提示词汇集)</a></p>
<h3 id="文生图"><a href="#文生图" class="headerlink" title="文生图"></a>文生图</h3><p>（图片网址链接失效了）</p>
<p><img src="https://picture.gptkong.com/20240623/152095c5469a2f41e59246d1d2a5bcc75b.png" alt="一目了然"></p>
<p>根据这个图，使用Stable Diffusion进行文生图就一目了然了。</p>
<p>注意：必须使用英伟达显卡。</p>
<h3 id="图生图"><a href="#图生图" class="headerlink" title="图生图"></a>图生图</h3><p>如图所示（图片网址链接失效了）</p>
<p><img src="https://picture.gptkong.com/20240623/15238b3b7563044d6ab37adf9772d28be8.png"></p>
<p>一张图就看懂了。</p>
<h3 id="Stable-Diffusion扩展安装"><a href="#Stable-Diffusion扩展安装" class="headerlink" title="Stable Diffusion扩展安装"></a>Stable Diffusion扩展安装</h3><p>这个AI还能安装其他插件，依次点击<strong>扩展-可用-加载自</strong>，然后重启webui即可。</p>
<h3 id="Ps安装Stable-Diffusion绘画插件"><a href="#Ps安装Stable-Diffusion绘画插件" class="headerlink" title="Ps安装Stable Diffusion绘画插件"></a>Ps安装Stable Diffusion绘画插件</h3><p><a href="https://github.com/AbdullahAlfaraj/Auto-Photoshop-StableDiffusion-Plugin/releases/tag/v1.2.3">插件页面)</a></p>
<p>下载好之后安装到ps的Plug-ins目录下。</p>
<p>然后在ps里面打开插件即可。</p>
<h1 id="4-VideoRemover"><a href="#4-VideoRemover" class="headerlink" title="4.VideoRemover"></a>4.VideoRemover</h1><p>AI给视频去字幕</p>
<p>详情查看videoremover.md,或者站内搜索Videoremover。</p>
<h1 id="5-AI换脸"><a href="#5-AI换脸" class="headerlink" title="5.AI换脸"></a>5.AI换脸</h1><p>抖音AI工具进行换脸即可，傻瓜式操作</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>RX10使用</title>
    <url>/2024/06/15/RX10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RX10介绍"><a href="#RX10介绍" class="headerlink" title="RX10介绍"></a>RX10介绍</h1><p>一款专业的音频修复和增强软件，一直是电影和电视节目中使用的行业标准音频修复工具，iZotope能够帮助用户对音频进行制作、后期合成处理、混音以及对损坏的音频进行修复，再解锁更多功能之后还能够对电影、游戏、电视之中的音频进行美化、编辑、修复等操作。</p>
<p>简单点来说，对音频可以进行非常丰富的修改。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>RX10下载路径：<a href="https://soft.macxf.com/soft/3236.html?id=MzE5MTM=">https://soft.macxf.com/soft/3236.html?id=MzE5MTM%3D</a></p>
<p>安装基本上也是默认，改一下安装位置就行。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>针对获取干净人声的操作如下：</p>
<p>使用RX10进行呼吸、降噪去除，具体步骤为：对话去除混响-&gt;呼吸（选中呼吸，编辑，查找类似事件，模块，渲染，静音）-&gt;去噪声（可选），保存为wav格式。</p>
<p>其他功能直接选择Rx10里面的模块即可，都是中文模块，点哪个用哪个，嘎嘎方便。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>RX10</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>UVR5使用</title>
    <url>/2024/06/15/UVR5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UVR5使用笔记"><a href="#UVR5使用笔记" class="headerlink" title="UVR5使用笔记"></a>UVR5使用笔记</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>分离音频的人声和混响等杂音，获得干净的人声。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://ultimatevocalremover.com/">UVR5下载地址</a></p>
<p>下载安装就行，基本上都是默认，安装地址可以更改。</p>
<h2 id="使用设置"><a href="#使用设置" class="headerlink" title="使用设置"></a>使用设置</h2><p>使用UVR5进行人声和背景音乐分离（保存为wav格式），</p>
<p>步骤：MDX-Net 1024 0.75；</p>
<p>VR—A 320 3 5_HP；</p>
<p>VR-A UVR-DE-DE 320 3</p>
<p>这是我的MDX-Net设置图片：图片失效了，有空我在补充</p>
<p><img src="https://picture.gptkong.com/20240623/1823a89b73d6244f7094a2ee5eab70dec8.png"></p>
<p>这是我的VR Architecture设置：图片失效了，有空我在补充</p>
<p><img src="https://picture.gptkong.com/20240623/1824b7c58c529d433d8c2162b141b152f7.png"></p>
<p>接下来只需要按照上面的顺序进行人声分离即可，进行到第三步，就能获得干净的人声了。</p>
]]></content>
      <categories>
        <category>视频</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>UVR5</tag>
      </tags>
  </entry>
  <entry>
    <title>Videoremover</title>
    <url>/2024/06/23/Videoremover/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Videoremover介绍"><a href="#Videoremover介绍" class="headerlink" title="Videoremover介绍"></a>Videoremover介绍</h1><p>拿来给视频去字幕的，全自动，</p>
<p>Video-subtitle-remover (VSR) 是一款基于AI技术，将视频中的硬字幕去除的软件。 主要实现了以下功能：</p>
<ul>
<li><strong>无损分辨率</strong>将视频中的硬字幕去除，生成去除字幕后的文件</li>
<li>通过超强AI算法模型，对去除字幕文本的区域进行填充（非相邻像素填充与马赛克去除）</li>
<li>支持自定义字幕位置，仅去除定义位置中的字幕（传入位置）</li>
<li>支持全视频自动去除所有文本（不传入位置）</li>
<li>支持多选图片批量去除水印文本</li>
<li>使用NVIDIA显卡</li>
</ul>
<p>我用了一下：很慢，效果一般般。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载安装地址：</p>
<p><a href="https://github.com/YaoFANGUK/video-subtitle-remover">YaoFANGUK&#x2F;video-subtitle-remover: 基于AI的图片&#x2F;视频硬字幕去除、文本水印去除，无损分辨率生成去字幕、去水印后的图片&#x2F;视频文件。无需申请第三方API，本地实现。AI-based tool for removing hard-coded subtitles and text-like watermarks from videos or Pictures. (github.com)</a></p>
<p>这是一个github项目</p>
<h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><p>在安装目录下找到vsr文件，找到并点击启动程序.exe既可启动</p>
<p>控制台不能关，然后直接点open即可打开文件夹选你要去字幕的视频，然后点击run即可全自动去字幕了。</p>
<p>如图：图片失效了</p>
<p><img src="https://picture.gptkong.com/20240623/183693c6ac02c3464fb020dfb152b5fc15.png"></p>
<p>我只能说，全自动还可以，就是速度慢，效果差。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>视频</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt笔记</title>
    <url>/2024/06/15/Qt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Qt-上世纪國男"><a href="#Qt-上世纪國男" class="headerlink" title="Qt-上世纪國男"></a>Qt-上世纪國男</h1><p>做毕设的时候疯狂学Qt，笔记留着以后温故而知新。</p>
<h2 id="1-Qt介绍"><a href="#1-Qt介绍" class="headerlink" title="1.Qt介绍"></a>1.Qt介绍</h2><p>Qt（官方发音 [kju:t]，音同 cute）是一个跨平台的 C++ 开发库，主要用来开发图形用户界面（Graphical User Interface，GUI）程序，当然也可以开发不带界面的命令行（Command User Interface，CUI）程序。</p>
<p>Qt 是纯 C++ 开发的，所以学好 C++ 非常有必要，Qt 还存在 Python、Ruby、Perl 等脚本语言的绑定， 也就是说可以使用脚本语言开发基于 Qt 的程序。开源社区就是这样，好东西就会被派生扩展，到处使用， 越来越壮大。</p>
<p>Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、Unix，智能手机系统 Android、iOS、WinPhone， 嵌入式系统 QNX、VxWorks 。</p>
<h2 id="Qt-可以做什么？"><a href="#Qt-可以做什么？" class="headerlink" title="Qt 可以做什么？"></a>Qt 可以做什么？</h2><p>Qt 经常被当做一个 GUI 库，用来开发图形界面应用程序，但这并不是 Qt 的全部；Qt 除了可以绘制漂亮的界面（包括控件、布局、交互），还包含很多其它功能，比如多线程、访问数据库、图像处理、音频视频处理、网络通信、文件操作等，这些 Qt 都已经内置了。</p>
<p>总起来说，Qt 主要用于<strong>桌面程序开发</strong>和嵌入式开发。</p>
<h2 id="2-为什么用Qt？"><a href="#2-为什么用Qt？" class="headerlink" title="2.为什么用Qt？"></a>2.为什么用Qt？</h2><p>用 Qt 来开发 Windows 桌面程序有以下优点：</p>
<ul>
<li>简单易学：Qt 封装的很好，几行代码就可以开发出一个简单的客户端，不需要了解 Windows API。</li>
<li>资料丰富：资料丰富能够成倍降低学习成本，否则你只能去看源码，关于 DirectUI、Htmlayout、aardio 的资料就很少。</li>
<li>漂亮的界面：Qt 很容易做出漂亮的界面和炫酷的动画，而 MFC、WTL、wxWidgets 比较麻烦。</li>
<li>独立安装：Qt 程序最终会编译为本地代码，不需要其他库的支撑，而 Java 要安装虚拟机，C# 要安装 .NET Framework。</li>
<li>跨平台：如果你的程序需要运行在多个平台下，同时又希望降低开发成本，Qt 几乎是必备的。</li>
</ul>
<h2 id="3-Qt-Creator"><a href="#3-Qt-Creator" class="headerlink" title="3.Qt Creator"></a>3.Qt Creator</h2><p>Qt是开源的库 Qt Creator是一个集成开发环境</p>
<p><a href="https://mp.weixin.qq.com/s/n58OskK1ldmelCnRXPgOCg">安装文档教程</a></p>
<p><a href="https://www.bilibili.com/video/BV1r54y1G7m4/">安装视频教程</a></p>
<h2 id="安装之后添加组件"><a href="#安装之后添加组件" class="headerlink" title="安装之后添加组件"></a>安装之后添加组件</h2><p>1，找到Qt安装目录中的维护工具MaintenanceTool.exe</p>
<p>2，添加国内源</p>
<p>手动添加储存库要定位一个储存有****QT在线安装镜像的地址****，这可难坏我了，但是经过不懈努力还是被我找到了（网址：<a href="http://download.qt.io/static/mirrorlist/%EF%BC%89%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E6%98%BE%E7%A4%BA%E4%BA%86%E5%90%84%E5%9B%BD%E7%9A%84qt%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9%EF%BC%8C%E4%B8%AD%E5%9B%BD%E6%9C%89%E5%9B%9B%E4%B8%AA%EF%BC%8C%E6%88%91%E7%94%A8%E7%9A%84%E6%98%AF%E4%B8%AD%E7%A7%91%E5%A4%A7%E7%9A%84%E7%AB%99%EF%BC%8C%E7%82%B9%E5%87%BBHTTP%E4%BC%9A%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82">http://download.qt.io/static/mirrorlist/）这个网站，显示了各国的qt镜像站点，中国有四个，我用的是中科大的站，点击HTTP会进入一个网络文件夹。</a></p>
<p><a href="https://mirrors.ustc.edu.cn/qtproject/online/qtsdkrepository/windows_x86/root/qt/">Index of &#x2F;qtproject&#x2F;online&#x2F;qtsdkrepository&#x2F;windows_x86&#x2F;root&#x2F;qt&#x2F; (ustc.edu.cn)</a></p>
<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/01%20%E5%85%A5%E9%97%A8/assets/image-20211118010214312.png" alt="image-20211118010214312"></p>
<p>然后依次进入&#x2F;online&#x2F;qtsdkrepository&#x2F;windows_x86&#x2F;root&#x2F;qt&#x2F; 最终的文件夹显示如下，在这个界面<strong>复制一下当前地址框地址</strong>到临时存储库。</p>
<h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>Qt Creator是跨平台的 Qt IDE， Qt Creator 是 Qt 被 Nokia收购后推出的一款新的轻量级集成开发环境（IDE）。此 IDE 能够跨平台运行，支持的系统包括 Linux（32 位及 64 位）、Mac OS X 以及 Windows。</p>
<ul>
<li><font color="red">使用QtCreator创建的项目目录中不能包含中文和空格</font></li>
<li><font color="red">QtCreator默认使用Utf8格式编码对文件字符进行编码</font></li>
</ul>
<p>修改Qt Creator文件编码：菜单栏-&gt;工具-&gt;选项-&gt;文本编辑器-&gt;行为-&gt;文件编码</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li>选择项目模板（没写的，其他的都默认就行）</li>
</ul>
<p>选择Qt widgets Application</p>
<ul>
<li>填写项目名称和选择路径(<font color="red">不能包含中文和空格<del>不能包含中文和空格</del>不能包含中文和空格~</font>)</li>
<li>选择窗口类信息</li>
<li>选择编译套件(用Qt Creator开发请选择MinGW <code>Minimalist GNU for Windows</code>)</li>
</ul>
<h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><blockquote>
<p>主函数所在的文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span>				<span class="comment">//生成的窗口类头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>			<span class="comment">//引用程序类头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建应用程序对象, 在一个Qt项目中实例对象有且仅有一个</span></span><br><span class="line">    <span class="comment">// 类的作用: 检测触发的事件, 进行事件循环并处理</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;	</span><br><span class="line">    <span class="comment">//创建窗口对象</span></span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//应用程序对象开始事件循环，保证应用程序不退出</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="widget-h"><a href="#widget-h" class="headerlink" title="widget.h"></a>widget.h</h3><blockquote>
<p>窗口类头文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span>			<span class="comment">//Qt标准窗口类头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget	<span class="comment">//自己的类继承自Qwidget类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT					<span class="comment">//使用信号与槽机制，必须包含该宏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>



<h3 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a>widget.cpp</h3><blockquote>
<p>窗口类源文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HelloQt-pro"><a href="#HelloQt-pro" class="headerlink" title="HelloQt.pro"></a>HelloQt.pro</h3><blockquote>
<p>Qt项目文件，注释需要用#号</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#项目编译时需要加载哪些模块</span></span><br><span class="line"><span class="attr">QT</span>       <span class="string">+= core gui</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果当前Qt版本大于4, 要添加一个额外的模块: widgets</span></span><br><span class="line"><span class="comment"># Qt 5中对gui模块进行了拆分, 将 widgets 独立出来了</span></span><br><span class="line"><span class="attr">greaterThan(QT_MAJOR_VERSION,</span> <span class="string">4): QT += widgets</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 让Qt支持c++11标准</span></span><br><span class="line"><span class="attr">CONFIG</span> <span class="string">+= c++11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#如果您使用任何已标记为不推荐使用的Qt功能，则以下定义使您的编译器发出警告（确切的警告取决于您的编译器）。 </span></span><br><span class="line"><span class="comment">#请参考不推荐使用的API的文档，以了解如何将您的代码移植远离它。</span></span><br><span class="line"><span class="attr">DEFINES</span> <span class="string">+= QT_DEPRECATED_WARNINGS</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#如果使用过时的API，您还可以使代码无法编译。</span></span><br><span class="line"><span class="comment">#为此，请取消注释以下行。</span></span><br><span class="line"><span class="comment">#您也可以选择仅在特定版本的Qt之前禁用已弃用的API。</span></span><br><span class="line"><span class="comment">#DEFINES + = QT_DISABLE_DEPRECATED_BEFORE = 0x060000    ＃禁用所有在Qt 6.0.0之前弃用的API</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 项目中的源文件	删除后，项目里不会显示所有的源文件</span></span><br><span class="line"><span class="attr">SOURCES</span> <span class="string">+= \</span></span><br><span class="line"><span class="string">    main.cpp \</span></span><br><span class="line"><span class="string">    widget.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 项目中的头文件</span></span><br><span class="line"><span class="attr">HEADERS</span> <span class="string">+= \</span></span><br><span class="line"><span class="string">    widget.h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#部署的默认规则</span></span><br><span class="line"><span class="attr">qnx</span>: <span class="string">target.path = /tmp/$$&#123;TARGET&#125;/bin					#嵌入式</span></span><br><span class="line"><span class="attr">else</span>: <span class="string">unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin	#unix</span></span><br><span class="line"><span class="comment">!isEmpty(target.path): INSTALLS += target</span></span><br></pre></td></tr></table></figure>

<p>pro是Qt的工程文件，这个文件是给qmake用来生成Makefile用的。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li>运行     Ctrl + r</li>
<li>编译     Ctrl + b</li>
<li>注释     Ctrl + &#x2F;</li>
<li>字体缩放 Ctrl + 鼠标滚轮</li>
<li>查找&#x2F;替换 Ctrl + f</li>
<li>整行移动   Ctrl + Shift + ↑ 或 ↓</li>
<li>自动对齐   Ctrl + i</li>
<li>帮助文档<ul>
<li>第一种：Qt Creator 直接查看   F1</li>
<li>第二种：打开独立的帮助文档程序  assistant</li>
</ul>
</li>
<li>同名.h 和 .cpp 之间的切换  F4</li>
<li>快速添加函数的定义  Alt + Enter      <span style="font-size:15px"><code>鼠标移动到函数申明上</code></span></li>
<li>修改变量名，并应用到所有用到该变量的地方  Ctrl + Shift +r</li>
<li>快速打开输出窗口 Alt + 数字键(1-8)</li>
<li>书签功能,即在某行代码处进行标记,方便以后找到。书签也可以添加文字标注。<ul>
<li>按Ctrl + M   添加&#x2F;删除书签</li>
<li>按Ctrl + .     查找并移动到下一个标签</li>
</ul>
</li>
</ul>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>萝卜白菜各有所爱，如何修改QtCreator的主题呢？</p>
<p><code>菜单栏-&gt;工具-&gt;选项-&gt;文本编辑器</code></p>
<p>个人喜欢黑色的</p>
<p>上面是选择系统自带的，当然也可以自己配置一个，我这配置了一个Vs白色主题的。</p>
<ul>
<li>xml文件 <code>Visual studio white(Qt creator代码样式).xml</code></li>
<li>把该文件复制到Qt的安装目录下的-&gt;Qt\Qt5.14.2\Tools\QtCreator\share\qtcreator\styles目录中</li>
<li>最后进入文本编辑器选择</li>
</ul>
<p>4.Qt+VS2019+Bug</p>
<p>用VS写Qt程序很舒服滴~！</p>
<h3 id="1-打开VS"><a href="#1-打开VS" class="headerlink" title="1.打开VS"></a>1.打开VS</h3><p>选择菜单栏-&gt;扩展-&gt;管理扩展</p>
<h3 id="2-VS安装Qt插件"><a href="#2-VS安装Qt插件" class="headerlink" title="2.VS安装Qt插件"></a>2.VS安装Qt插件</h3><p>选择菜单栏的 扩展-&gt;管理扩展，输入Qt搜索，然后下载Qt Visual Studio Tools（下载灰常的银杏，慢的死~还不一定能下载）</p>
<p><strong>如果实在不能忍受这龟速，就用别的办法</strong></p>
<p>先到Qt官网下载对于版本的插件，我这里是Vs2019：</p>
<p><a href="https://download.qt.io/official_releases/vsaddin/">Qt官网插件下载</a></p>
<p><a href="https://marketplace.visualstudio.com/items">微软拓展商店下载</a></p>
<p>选择清华大学镜像源下载即可。</p>
<h3 id="3-安装VSIX-即上面下载的那个插件"><a href="#3-安装VSIX-即上面下载的那个插件" class="headerlink" title="3.安装VSIX(即上面下载的那个插件)"></a>3.安装VSIX(即上面下载的那个插件)</h3><p>如果是通过Vs下载的，会自动安装。</p>
<p>如果是手动下载的，需要双击自己安装。</p>
<p>打开安装包之后，点击Install等待安装完成即可。</p>
<p>安装之前，请先关掉Vs<code>没有关掉会出现如下界面，点击end tasks即可</code></p>
<p>关闭Vs之后，一秒安装完成</p>
<p>安装完成，关掉程序</p>
<h3 id="4-设置插件"><a href="#4-设置插件" class="headerlink" title="4.设置插件"></a>4.设置插件</h3><p>再次打开Vs，扩展-&gt;Qt VS Tools-&gt;Qt Options</p>
<p>点击Qt Options之后会弹出界面</p>
<p>首先删掉自动配置好的路径，然后点击Add自己添加一个，如下是具体的路径选项，选择msvc2017_64文件夹，点击确定即可</p>
<p>然后点击OK</p>
<h3 id="5-VS创建Qt项目"><a href="#5-VS创建Qt项目" class="headerlink" title="5.VS创建Qt项目"></a>5.VS创建Qt项目</h3><p>在Vs中点击新建项目，搜索Qt找到Qt Widgets Application然后点击下一步。</p>
<p>下一步之后，给项目取名称</p>
<p>点击创建，</p>
<p>然后从Debug和Release模式里选择一个即可(默认即可)</p>
<p>然后点击完成就ok啦。</p>
<h3 id="6，中文乱码"><a href="#6，中文乱码" class="headerlink" title="6，中文乱码"></a>6，中文乱码</h3><p>由于windows默认的编码方式为GB2312，而Qt使用的是Unicode，两种编码方式不一样导致了乱码产生。</p>
<p>我们需要把代码文件改为utf-8保存，可以手动修改，也可以借助插件自动修改。</p>
<h4 id="1，手动修改"><a href="#1，手动修改" class="headerlink" title="1，手动修改"></a>1，手动修改</h4><p>VS隐藏了高级保存功能，导致没办法直接去设置代码编码。那么我们直接把高级保存功能调用出来即可：</p>
<ol>
<li><p>单击“工具”|“自定义”命令，弹出“自定义”对话框。</p>
</li>
<li><p>单击“命令”标签，进入“命令”选项卡；在“菜单栏”下拉列表中，选择“文件”选项；单击“添加命令”按钮，弹出“添加命令”对话框。</p>
</li>
<li><p>在“类别”列表中，选择“文件”选项；在“命令”列表中，选择“高级保存选项”选项。 单击“确定”。</p>
<img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/01%20%E5%85%A5%E9%97%A8/assets/image-20210504163713084.png" alt="image-20210504163713084" style="zoom:67%;" /></li>
</ol>
<p>…这个操作还是比较麻烦，使用下面的自动修改是最方便的</p>
<h4 id="2，自动修改"><a href="#2，自动修改" class="headerlink" title="2，自动修改"></a>2，自动修改</h4><p>打开 VS2017，依次点击 工具 -&gt; 扩展和更新，搜索插件 “ForceUTF8”，安装后源码文件会强制保存为带 BOM 的 UTF-8。</p>
<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/01%20%E5%85%A5%E9%97%A8/assets/image-20210504162322942.png" alt="image-20210504162322942"></p>
<p><strong>注意：</strong><font color=red>修改之后，写C&#x2F;C++代码会出现乱码，此时再进到插件-&gt;已安装吧Force UTF-8禁用掉，然后重启Vs即可</font></p>
<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/01%20%E5%85%A5%E9%97%A8/assets/image-20210504162639221.png" alt="image-20210504162639221"></p>
<h3 id="7，Vs中修改应用程序图标"><a href="#7，Vs中修改应用程序图标" class="headerlink" title="7，Vs中修改应用程序图标"></a>7，Vs中修改应用程序图标</h3><ul>
<li><p>1，备好一个.ico图标文件</p>
</li>
<li><p>2，创建一个.rc文件(创建txt修改后缀即可)，然后加入以下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">IDI_ICON1 <span class="attribute">ICON</span> DISCARDABLE &quot;zay<span class="selector-class">.ico</span>&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3，将.rc文件和.ico文件都放在项目的文件夹中</p>
</li>
<li><p>在VS中右击Source File筛选器选择<strong>添加</strong>||<strong>现有项</strong>，将<strong>logo.rc</strong>和<strong>zay.ico</strong>文件添加到项目中，重新生成即可</p>
</li>
</ul>
<h2 id="Qt-Creator-MSVC"><a href="#Qt-Creator-MSVC" class="headerlink" title="Qt Creator + MSVC"></a>Qt Creator + MSVC</h2><p>先安装好Qt Creator和visual studio，前者做编辑器，用后者的编译器，最后安装一个调试器。</p>
<p>通过<a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/">windows SDK</a>工具安装调试器(CDB)。</p>
<p>下载之后安装即可</p>
<p>安装完成之后重新打开Qt Creator，会自动检测调试工具的路径。</p>
<p>安装Vs之后，编译器也会自动检测到</p>
<p>最后需要自己选择一下，对应版本的编译器和调试器x64和x86都可以配置。</p>
<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>如果出现乱码可以在.pro文件中加入以下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">msvc</span><br><span class="line">&#123;</span><br><span class="line">	QMAKE_CFLAGS += /utf-<span class="number">8</span>	<span class="selector-id">#C</span>语言编译器选项</span><br><span class="line">	QMAKE_CXXFLAGS+=/utf-<span class="number">8</span>	<span class="selector-id">#C</span>++编译器选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Qt用我经常用的C-编写"><a href="#Qt用我经常用的C-编写" class="headerlink" title="Qt用我经常用的C++编写"></a>Qt用我经常用的C++编写</h1><p>C++语言看C++.md即可</p>
<h2 id="1-log输出"><a href="#1-log输出" class="headerlink" title="1. log输出"></a>1. log输出</h2><blockquote>
<p>在Qt中进行log输出, 一般不使用c中的<code>printf</code>, 也不是使用C++中的<code>cout</code>, Qt框架提供了专门用于日志输出的类, 头文件名为 <code>QDebug</code>。</p>
</blockquote>
<p><strong>基本分类</strong></p>
<ul>
<li>qDebug：调试信息提示</li>
<li>qInfo     ：输出信息</li>
<li>qWarning ：一般的警告提示</li>
<li>qCritical ：严重的错误提示</li>
<li>qFatal ：致命错误提示，会直接中断程序</li>
</ul>
<p><strong>C风格输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;我是%s，今年%d岁了~&quot;</span>,<span class="string">&quot;maye&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">qInfo</span>(<span class="string">&quot;maye%d&quot;</span>,<span class="number">666</span>);</span><br><span class="line"><span class="built_in">qWarning</span>(<span class="string">&quot;hello %s&quot;</span>,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"><span class="built_in">qCritical</span>(<span class="string">&quot;helo %s&quot;</span>,<span class="string">&quot;critical&quot;</span>);</span><br><span class="line"><span class="built_in">qFatal</span>(<span class="string">&quot;hello %s&quot;</span>,<span class="string">&quot;qFatal&quot;</span>);		<span class="comment">//致命错误会直接中断程序</span></span><br></pre></td></tr></table></figure>

<p><strong>C++风格</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;好帅&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">qInfo</span>()&lt;&lt;<span class="string">&quot;qInfo&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">qWarning</span>()&lt;&lt;<span class="string">&quot;qWarnning&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">qCritical</span>()&lt;&lt;<span class="string">&quot;qCritical&quot;</span>&lt;&lt;endl;</span><br><span class="line">#<span class="built_in">qFatal</span>()&lt;&lt;<span class="string">&quot;qFatal&quot;</span>&lt;&lt;endl;			<span class="comment">//致命错误不能用&lt;&lt;输出</span></span><br></pre></td></tr></table></figure>





<h2 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2. 字符串类型"></a>2. 字符串类型</h2><blockquote>
<p>C     &#x3D;&gt; <code>char*</code></p>
<p>C++ &#x3D;&gt; <code>std::string</code></p>
<p>Qt	&#x3D;&gt; <code>QByteArray</code>, <code>QString</code></p>
</blockquote>
<h3 id="2-1-QByteArray"><a href="#2-1-QByteArray" class="headerlink" title="2.1 QByteArray"></a>2.1 QByteArray</h3><blockquote>
<p>在Qt中<code>QByteArray</code>可以看做是C语言中 <code>char*</code>的升级版本。我们在使用这种类型的时候可通过这个类的构造函数申请一块动态内存，用于存储我们需要处理的字符串数据。</p>
<p>下面给大家介绍一下这个类中常用的一些API函数，<code>大家要养成遇到问题主动查询帮助文档的好习惯</code></p>
</blockquote>
<ul>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造空对象, 里边没有数据</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>();</span><br><span class="line"><span class="comment">// 将data中的size个字符进行构造, 得到一个字节数组对象</span></span><br><span class="line"><span class="comment">// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">const</span> <span class="type">char</span> *data, <span class="type">int</span> size = <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组</span></span><br><span class="line">QByteArray::<span class="built_in">QByteArray</span>(<span class="type">int</span> size, <span class="type">char</span> ch);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>数据操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_back</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::push_front</span><span class="params">(<span class="type">const</span> QByteArray &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::remove</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">// 从字符数组的尾部删除 n 个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::truncate</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QByteArray::clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::replace</span><span class="params">(<span class="type">const</span> QByteArray &amp;before, <span class="type">const</span> QByteArray &amp;after)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>子字符串查找和判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组中是否包含子字符 ch, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::contains</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::startsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QByteArray::endsWith</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">QByteArray::end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="comment">// i的取值范围 0 &lt;= i &lt; size()</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">QByteArray::at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> QByteArray::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>查看字节数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组对象中 子字符串ba 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ba)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回字节数组对象中 字符串ch 出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::count</span><span class="params">(<span class="type">char</span> ch)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将QByteArray类型的字符串 转换为 char* 类型</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int, short, long, float, double -&gt; QByteArray</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QByteArray &amp;<span class="title">QByteArray::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(qlonglong n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> f = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> prec = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QByteArray -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QByteArray::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QByteArray::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QByteArray::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QByteArray::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QByteArray::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::string -&gt; QByteArray</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QByteArray <span class="title">QByteArray::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QByteArray -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QByteArray::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QByteArray::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-QString"><a href="#2-2-QString" class="headerlink" title="2.2 QString"></a>2.2 QString</h3><blockquote>
<p>QString也是封装了字符串, 但是内部的编码为<code>utf8</code>, UTF-8属于Unicode字符集, 它固定使用多个字节（window为2字节, linux为3字节）来表示一个字符，这样可以将世界上几乎所有语言的常用字符收录其中。</p>
<p>下面给大家介绍一下这个类中常用的一些API函数。</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空字符串对象</span></span><br><span class="line"><span class="built_in">QString</span>();</span><br><span class="line"><span class="comment">// 将 char* 字符串 转换为 QString 类型</span></span><br><span class="line"><span class="built_in">QString</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="comment">// 将 QByteArray 转换为 QString 类型</span></span><br><span class="line"><span class="built_in">QString</span>(<span class="type">const</span> QByteArray &amp;ba);</span><br><span class="line"><span class="comment">// 其他重载的同名构造函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾部追加数据</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部添加数据</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">prepend</span><span class="params">(<span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">prepend</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">prepend</span><span class="params">(<span class="type">const</span> QByteArray &amp;ba)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QString::push_front</span><span class="params">(<span class="type">const</span> QString &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QString &amp;str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> position, <span class="type">const</span> QByteArray &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="comment">// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">remove</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的尾部删除 n 个字符</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">chop</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">truncate</span><span class="params">(<span class="type">int</span> position)</span></span>;</span><br><span class="line"><span class="comment">// 将对象中的数据清空, 使其为null</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="comment">// 将字节数组中的 子字符串 before 替换为 after</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">replace</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="子字符串查找和判断"><a href="#子字符串查找和判断" class="headerlink" title="子字符串查找和判断"></a>子字符串查找和判断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">endsWith</span><span class="params">(<span class="type">const</span> QString &amp;s, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器</span></span><br><span class="line"><span class="function">iterator  <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">iterator  <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组的方式进行遍历</span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar  <span class="title">at</span><span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> QChar  <span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> position)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看字节数"><a href="#查看字节数" class="headerlink" title="查看字节数"></a>查看字节数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字节数组对象中字符的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节串对象中 子字符串 str 出现的次数</span></span><br><span class="line"><span class="comment">// 参数 cs 为是否区分大小写, 默认区分大小写</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">count</span><span class="params">(<span class="type">const</span> QStringRef &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int, short, long, float, double -&gt; QString</span></span><br><span class="line"><span class="comment">// 其他重载的同名函数可参考Qt帮助文档, 此处略</span></span><br><span class="line"><span class="function">QString&amp; <span class="title">setNum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">setNum</span><span class="params">(<span class="type">short</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">setNum</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">QString&amp; <span class="title">setNum</span><span class="params">(<span class="type">float</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">QString&amp;<span class="title">QString::setNum</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::number</span><span class="params">(<span class="type">double</span> n, <span class="type">char</span> format = <span class="string">&#x27;g&#x27;</span>, <span class="type">int</span> precision = <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QString -&gt; int, short, long, float, double</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QString::toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">QString::toShort</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">QString::toLong</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR, <span class="type">int</span> base = <span class="number">10</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">QString::toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QString::toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有字符转换为大写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toUpper</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 所有字符转换为小写</span></span><br><span class="line"><span class="function">QString <span class="title">QString::toLower</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>C语言中有sprintf()函数，QString也提供了一个asprintf()函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString res =  QString::<span class="built_in">asprintf</span>(<span class="string">&quot;fileName:%s size:%d&quot;</span>,<span class="string">&quot;./av.jpg&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过QString还提供的另一种格式化字符串输出的函数arg()，更为方便。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">arg</span><span class="params">(<span class="type">const</span> QString &amp;a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">arg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> fieldWidth = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>, QChar fillChar = QLatin1Char( <span class="string">&#x27; &#x27;</span> ))</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//用于填充字符串中的%1,%2…为给定格式的整形数字，其中第一个参数是要填充的数字，第二个参数为最小宽度，第三个参数为进制，第四个参数为当原始数字长度不足最小宽度时用于填充的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line">QString str =  <span class="built_in">QString</span>(<span class="string">&quot;%1 %2 %3&quot;</span>).<span class="built_in">arg</span>(<span class="number">1</span>).<span class="built_in">arg</span>(<span class="number">2</span>);</span><br><span class="line">str = str.<span class="built_in">arg</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;str&lt;&lt;endl;     <span class="comment">//&quot;hello 2 1&quot;</span></span><br><span class="line"></span><br><span class="line">QString text = <span class="built_in">QString</span>(<span class="string">&quot;%1:%2:%3&quot;</span>).<span class="built_in">arg</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="built_in">QChar</span>(<span class="string">&#x27;0&#x27;</span>)).<span class="built_in">arg</span>(<span class="number">35</span>).<span class="built_in">arg</span>(<span class="number">59</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;text&lt;&lt;endl;    <span class="comment">//&quot;01:35:59&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-不同字符串类型相互转换"><a href="#2-2-不同字符串类型相互转换" class="headerlink" title="2.2 不同字符串类型相互转换"></a>2.2 不同字符串类型相互转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::string -&gt; QString</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QString <span class="title">QString::fromStdString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"><span class="comment">// QString -&gt; std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">QString::toStdString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">#QString -&gt; QByteArray</span><br><span class="line"><span class="comment">// 转换为本地编码, 跟随操作系统</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLocal8Bit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 Latin-1 编码的字符串 不支持中文</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toLatin1</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 转换为 utf8 编码格式的字符串 (常用)</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QString::toUtf8</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">#QByteArray -&gt; QString</span><br><span class="line"><span class="comment">//使用QString的构造函数即可</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-QVariant"><a href="#3-QVariant" class="headerlink" title="3. QVariant"></a>3. QVariant</h2><blockquote>
<p>QVariant(变体数据类型)这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而QVariant则可以统统搞定。</p>
<p>QVariant 这个类型充当着最常见的数据类型的联合。QVariant 可以保存很多Qt的数据类型，包括<code>QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、 QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize和QString</code>，并且还有C++基本类型，如<code> int、float</code>等。</p>
</blockquote>
<h2 id="4-标准类型"><a href="#4-标准类型" class="headerlink" title="4. 标准类型"></a>4. 标准类型</h2><ul>
<li>将标准类型转换为QVariant类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这类转换需要使用QVariant类的构造函数, 由于比较多, 大家可自行查阅Qt帮助文档, 在这里简单写几个</span></span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">int</span> val);</span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">bool</span> val);</span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">double</span> val);</span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">const</span> <span class="type">char</span> *val);</span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">const</span> QByteArray &amp;val);</span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">const</span> QString &amp;val);</span><br><span class="line">......</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用设置函数也可以将支持的类型的数据设置到QVariant对象中</span></span><br><span class="line"><span class="comment">// 这里的 T 类型, 就是QVariant支持的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"><span class="comment">// 该函数行为和 setValue() 函数完全相同</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QVariant <span class="title">fromValue</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Exmple</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QVariant <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">QVariant v;</span><br><span class="line">v.<span class="built_in">setValue</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">QVariant v = QVariant::<span class="built_in">fromValue</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = v.<span class="built_in">toInt</span>();          <span class="comment">// i is now 5</span></span><br><span class="line">QString s = v.<span class="built_in">toString</span>();   <span class="comment">// s is now &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>判断 QVariant中封装的实际数据类型</li>
</ul>
<blockquote>
<p>Type 是枚举类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类型，返回的是一个枚举类型;如QVariant::Int ...</span></span><br><span class="line"><span class="function">Type <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//获取类型名</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">typeName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//根据类型id(枚举)获取类型名(字符串)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">typeToName</span><span class="params">(<span class="type">int</span> typeId)</span></span>;</span><br><span class="line"><span class="comment">//根据类型名(字符串)获取类型id(枚举)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">Type <span class="title">nameToType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>将QVariant对象转换为实际的数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在转换之前可以先判断能够转换成对应的类型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canConvert</span><span class="params">(<span class="type">int</span> targetTypeId)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canConvert</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> 		<span class="title">toBool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QByteArray 	<span class="title">toByteArray</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> 		<span class="title">toDouble</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> 		<span class="title">toFloat</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> 		<span class="title">toInt</span><span class="params">(<span class="type">bool</span> *ok = Q_NULLPTR)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QString 	<span class="title">toString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//v.value&lt;int&gt;();       </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="4-1-自定义类型"><a href="#4-1-自定义类型" class="headerlink" title="4.1 自定义类型"></a>4.1 自定义类型</h3><blockquote>
<p>除了标准类型, 我们自定义的类型也可以使用<code>QVariant</code>类进行封装, <code>被QVariant存储的数据类型需要有一个默认的构造函数和一个拷贝构造函数</code>。为了实现这个功能，首先必须使用<code>Q_DECLARE_METATYPE()</code>宏。通常会将这个宏放在类的声明所在头文件的下面， 原型为： </p>
<p><code>Q_DECLARE_METATYPE(Type)</code></p>
<p>使用的具体步骤如下: </p>
</blockquote>
<ul>
<li><p>第一步: 定义类型，并注册</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()&#123;&#125;  <span class="comment">//必须要有默认构造函数</span></span><br><span class="line">                <span class="comment">//拷贝构造函数也必须有，不过没有深、浅拷贝时，用默认的即可</span></span><br><span class="line">    <span class="built_in">Animal</span>(QString name):_name(name)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;Animal show name is :&quot;</span>&lt;&lt; _name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义类型注册</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Animal);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步: 使用forvalue()存储对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//QVariant vt(Animal(&quot;snake&quot;));	//不可以通过构造函数存自定义类型</span></span><br><span class="line">    QVariant vt;</span><br><span class="line">    <span class="comment">//有以下两种方法可以，存自定义类型</span></span><br><span class="line">    vt = QVariant::<span class="built_in">fromValue</span>(<span class="built_in">Animal</span>(<span class="string">&quot;dog&quot;</span>));	<span class="comment">//①</span></span><br><span class="line">    vt.<span class="built_in">setValue</span>(<span class="built_in">Animal</span>(<span class="string">&quot;cat&quot;</span>));					<span class="comment">//②</span></span><br><span class="line">    <span class="comment">//如果能转换到Animal类型，就转换</span></span><br><span class="line">    <span class="keyword">if</span>(vt.<span class="built_in">canConvert</span>&lt;Animal&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        Animal animal = vt.<span class="built_in">value</span>&lt;Animal&gt;();</span><br><span class="line">        animal.<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>操作涉及的API如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前QVariant对象可用转换为对应的模板类型 T, 返回true, 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canConvert</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将当前QVariant对象转换为实际的 T 类型</span></span><br><span class="line"><span class="function">T <span class="title">value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="5-位置和尺寸"><a href="#5-位置和尺寸" class="headerlink" title="5. 位置和尺寸"></a>5. 位置和尺寸</h2><blockquote>
<p>在QT中我们常见的 点, 线, 尺寸, 矩形 都被进行了封装, 下边依次为大家介绍相关的类。</p>
</blockquote>
<h3 id="5-1-QPoint"><a href="#5-1-QPoint" class="headerlink" title="5.1 QPoint"></a>5.1 QPoint</h3><blockquote>
<p><code>QPoint</code>类封装了我们常用用到的坐标点 (x, y), 常用的 API如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setX</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QPoint::setY</span><span class="params">(<span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::rx</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QPoint::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">QPoint::ry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x和y坐标都为0则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNull</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回x()和y()的绝对值之和，传统上称为从原点到该点的向量的“曼哈顿长度”。</span></span></span><br><span class="line"><span class="function"><span class="comment">//(p1-p2).manhattanLength();   </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">manhattanLength</span><span class="params">()</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个交换了x和y坐标的点:   QPoint&#123;1, 2&#125;.transposed() // &#123;2, 1&#125;  </span></span></span><br><span class="line"><span class="function">QPoint <span class="title">transposed</span><span class="params">()</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 直接通过坐标对象进行算术运算: 加减乘除</span></span></span><br><span class="line"><span class="function">QPoint &amp;QPoint::<span class="keyword">operator</span>*</span>=(<span class="type">float</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">double</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>*=(<span class="type">int</span> factor);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>+=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>-=(<span class="type">const</span> QPoint &amp;point);</span><br><span class="line">QPoint &amp;QPoint::<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-QLine"><a href="#5-2-QLine" class="headerlink" title="5.2 QLine"></a>5.2 QLine</h3><blockquote>
<p><code>QLine</code>是一个直线类, 封装了两个坐标点 (<code>两点确定一条直线</code>)</p>
<p>常用API如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置直线的起点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setP1</span><span class="params">(<span class="type">const</span> QPoint &amp;p1)</span></span>;</span><br><span class="line"><span class="comment">// 设置直线的终点坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setP2</span><span class="params">(<span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPoints</span><span class="params">(<span class="type">const</span> QPoint &amp;p1, <span class="type">const</span> QPoint &amp;p2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QPoint <span class="title">p1</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回直线的起始点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">p2</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回直线的终点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">center</span><span class="params">()</span> <span class="type">const</span></span>;	<span class="comment">// 返回值直线的中心点坐标, (p1() + p2()) / 2	</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x1</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回值直线起点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y1</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回值直线起点的 y 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x2</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回值直线终点的 x 坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y2</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 返回值直线终点的 y 坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dx</span><span class="params">()</span> <span class="type">const</span>			<span class="comment">//返回直线向量的水平分量  </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dy</span><span class="params">()</span> <span class="type">const</span>			<span class="comment">//返回直线向量的垂直分量  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用给定的坐标点平移这条直线</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translate</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translate</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">// 用给定的坐标点平移这条直线, 返回平移之后的坐标点(不会改变这条线的坐标)</span></span><br><span class="line"><span class="function">QLine <span class="title">translated</span><span class="params">(<span class="type">const</span> QPoint &amp;offset)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QLine <span class="title">translated</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线对象进行比较</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> QLine &amp;line) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>5.3 QSize</p>
<blockquote>
<p>在QT中<code>QSize</code>类用来形容长度和宽度, 常用的API如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 得到宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">rwidth</span><span class="params">()</span></span>;			<span class="comment">// 得到宽度的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;		<span class="comment">// 得到高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">rheight</span><span class="params">()</span></span>;			<span class="comment">// 得到高度的引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transpose</span><span class="params">()</span></span>;			<span class="comment">// 交换高度和宽度的值</span></span><br><span class="line"><span class="function">QSize <span class="title">transposed</span><span class="params">()</span> <span class="type">const</span></span>;	<span class="comment">// 交换高度和宽度的值, 返回交换之后的尺寸信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个大小，宽为当前大小与other的最小值，高为当前大小与other的最小值</span></span><br><span class="line"><span class="function">QSize <span class="title">boundedTo</span><span class="params">(<span class="type">const</span> QSize&amp; oterSize)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个大小，宽为当前大小与other的最大值，高为当前大小与other的最大值    </span></span></span><br><span class="line"><span class="function">QSize <span class="title">expandedTo</span><span class="params">(<span class="type">const</span> QSize &amp;otherSize)</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">根据指定的模式，按给定的宽度和高度缩放矩形:  </span></span></span><br><span class="line"><span class="comment"><span class="function">	如果mode为Qt::IgnoreAspectRatio，则大小设置为(width, height)。  </span></span></span><br><span class="line"><span class="comment"><span class="function">	如果mode为Qt::KeepAspectRatio，当前大小将在内部缩放到一个尽可能大的矩形(宽度，高度)，保持高宽比。  </span></span></span><br><span class="line"><span class="comment"><span class="function">	如果mode是Qt::KeepAspectRatioByExpanding，当前大小被缩放到一个矩形，尽可能小的外部(宽度，高度)，保持长宽比。  </span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Qt::AspectRatioMode mode)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scale</span><span class="params">(<span class="type">const</span> QSize &amp;size, Qt::AspectRatioMode mode)</span></span></span><br><span class="line"><span class="function">QSize <span class="title">scaled</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, Qt::AspectRatioMode mode)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QSize <span class="title">scaled</span><span class="params">(<span class="type">const</span> QSize &amp;s, Qt::AspectRatioMode mode)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 进行算法运算: 加减乘除</span></span></span><br><span class="line"><span class="function">QSize &amp;<span class="keyword">operator</span>*</span>=(qreal factor);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> QSize &amp;size);</span><br><span class="line">QSize &amp;<span class="keyword">operator</span>/=(qreal divisor);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-4-QRect"><a href="#5-4-QRect" class="headerlink" title="5.4 QRect"></a>5.4 QRect</h3><blockquote>
<p>在Qt中使用 <code>QRect</code>类来描述一个矩形, 常用的API如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>();</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和右下角坐标构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QPoint &amp;bottomRight);</span><br><span class="line"><span class="comment">// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">const</span> QPoint &amp;topLeft, <span class="type">const</span> QSize &amp;size);</span><br><span class="line"><span class="comment">// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象</span></span><br><span class="line">QRect::<span class="built_in">QRect</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置矩形的尺寸信息, 左上角坐标不变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setSize</span><span class="params">(<span class="type">const</span> QSize &amp;size)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形左上角坐标为(x,y), 大小为(width, height)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setWidth</span><span class="params">(<span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="comment">// 设置矩形高度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::setHeight</span><span class="params">(<span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值矩形左上角坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右上角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top())</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::topRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left(), top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomLeft</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右下角坐标</span></span><br><span class="line"><span class="comment">// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::bottomRight</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形中心点坐标</span></span><br><span class="line"><span class="function">QPoint <span class="title">QRect::center</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形上边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::y</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回值矩形下边缘y轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::bottom</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形左边缘 x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::left</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形右边缘x轴坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::right</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回矩形的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的宽度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QRect::height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回矩形的尺寸信息</span></span><br><span class="line"><span class="function">QSize <span class="title">QRect::size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整矩形的尺寸 （左上角和右下角坐标偏移量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRect::adjust</span><span class="params">(<span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2)</span></span></span><br><span class="line"><span class="function">QRect <span class="title">QRect::adjusted</span><span class="params">(<span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2)</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>QPoint，QLine，QSize，QRect各自都还有浮点型版本的，分别是QPointF，QLineF，QSizeF，QRectF，函数基本一样</p>
<ol start="6">
<li>日期和时间</li>
</ol>
<h2 id="6-QDate"><a href="#6-QDate" class="headerlink" title="6. QDate"></a>6. QDate</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDate::<span class="built_in">QDate</span>();</span><br><span class="line">QDate::<span class="built_in">QDate</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 重新设置日期对象中的日期</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QDate::setDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 ndays 天</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nmonths 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 给日期对象添加 nyears 月</span></span><br><span class="line"><span class="function">QDate <span class="title">QDate::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到日期对象中的年/月/日</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::year</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::month</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QDate::day</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDate::getDate</span><span class="params">(<span class="type">int</span> *year, <span class="type">int</span> *month, <span class="type">int</span> *day)</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*日期对象格式化</span></span><br><span class="line"><span class="comment">    d 		- 	没有前导零的日子 (1 to 31)  </span></span><br><span class="line"><span class="comment">    dd		-	前导为0的日子   (01 to 31)  </span></span><br><span class="line"><span class="comment">    ddd		-	显示(缩写) 周一、周二、周三、周四、周五、周六、周日		</span></span><br><span class="line"><span class="comment">    dddd	- 	显示(完整) 星期一、星期二、星期三、星期四、星期五、星期六、星期日</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    M		-	没有前导零的月份(1到12)  </span></span><br><span class="line"><span class="comment">    MM		-	前导零的月份(01到12)  </span></span><br><span class="line"><span class="comment">    MMM		-	缩写 1月、2月、3月...         </span></span><br><span class="line"><span class="comment">    MMMM	-	完整 一月、二月、三月...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    yy		-	两个数字的年 (00 to 99)</span></span><br><span class="line"><span class="comment">    yyyy	-	以四位数表示的年份</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QDate::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期比较</span></span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>!=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>==(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDate::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDate &amp;d) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到本地的当前日期</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDate <span class="title">QDate::currentDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-1-QTime"><a href="#6-1-QTime" class="headerlink" title="6.1 QTime"></a>6.1 QTime</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QTime::<span class="built_in">QTime</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    h 			==&gt; must be in the range 0 to 23</span></span><br><span class="line"><span class="comment">    m and s 	==&gt; must be in the range 0 to 59</span></span><br><span class="line"><span class="comment">    ms 			==&gt; must be in the range 0 to 999</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">QTime::<span class="built_in">QTime</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s = <span class="number">0</span>, <span class="type">int</span> ms = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// Returns true if the set time is valid; otherwise returns false.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTime::setHMS</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> ms = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addSecs</span><span class="params">(<span class="type">int</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QTime <span class="title">QTime::addMSecs</span><span class="params">(<span class="type">int</span> ms)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">  <span class="function">QTime <span class="title">n</span><span class="params">(<span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;                <span class="comment">// n == 14:00:00</span></span><br><span class="line">  QTime t;</span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">70</span>);                <span class="comment">// t == 14:01:10</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-70</span>);               <span class="comment">// t == 13:58:50</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">10</span> * <span class="number">60</span> * <span class="number">60</span> + <span class="number">5</span>);  <span class="comment">// t == 00:00:05</span></span><br><span class="line">  t = n.<span class="built_in">addSecs</span>(<span class="number">-15</span> * <span class="number">60</span> * <span class="number">60</span>);     <span class="comment">// t == 23:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从时间对象中取出 时/分/秒/毫秒</span></span><br><span class="line"><span class="comment">// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::hour</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::minute</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::second</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::msec</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	-- 时</span></span><br><span class="line"><span class="comment">    h	==&gt;	The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    hh	==&gt;	The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</span></span><br><span class="line"><span class="comment">    H	==&gt;	The hour without a leading zero (0 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    HH	==&gt;	The hour with a leading zero (00 to 23, even with AM/PM display)</span></span><br><span class="line"><span class="comment">    -- 分</span></span><br><span class="line"><span class="comment">    m	==&gt;	The minute without a leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    mm	==&gt;	The minute with a leading zero (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 秒</span></span><br><span class="line"><span class="comment">    s	==&gt;	The whole second, without any leading zero (0 to 59)</span></span><br><span class="line"><span class="comment">    ss	==&gt;	The whole second, with a leading zero where applicable (00 to 59)</span></span><br><span class="line"><span class="comment">    -- 毫秒</span></span><br><span class="line"><span class="comment">	zzz	==&gt;	The fractional part of the second, to millisecond precision, </span></span><br><span class="line"><span class="comment">			including trailing zeroes where applicable (000 to 999).</span></span><br><span class="line"><span class="comment">	-- 上午或者下午</span></span><br><span class="line"><span class="comment">    AP or A		==&gt;		使用AM/PM(大写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">    ap or a		==&gt;		使用am/pm(小写) 描述上下午, 中文系统显示汉字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QString <span class="title">QTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 时间比较</span></span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>==(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QTime &amp;t) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数 -&gt; 得到当前时间</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QTime <span class="title">QTime::currentTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="经时计时器"><a href="#经时计时器" class="headerlink" title="经时计时器"></a>经时计时器</h3><p>QTime的经时计时器已经过时了，推荐使用QElapsedTimer。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QTime已废弃的函数</span></span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTime::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 计时结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QTime::restart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用的API函数</span></span><br><span class="line"><span class="comment">// QElapsedTimer 类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QElapsedTimer::start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::restart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">qint64 <span class="title">QElapsedTimer::elapsed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>主要的使用方法就是测量一个操作耗时多久，例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QElapsedTimer elapse;</span><br><span class="line">elapse.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++);</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;elapse.<span class="built_in">elapsed</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-QDateTime"><a href="#6-2-QDateTime" class="headerlink" title="6.2 QDateTime"></a>6.2 QDateTime</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>();</span><br><span class="line">QDateTime::<span class="built_in">QDateTime</span>(<span class="type">const</span> QDate &amp;date, <span class="type">const</span> QTime &amp;time, Qt::TimeSpec spec = Qt::LocalTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共成员函数</span></span><br><span class="line"><span class="comment">// 设置日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setDate</span><span class="params">(<span class="type">const</span> QDate &amp;date)</span></span>;</span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateTime::setTime</span><span class="params">(<span class="type">const</span> QTime &amp;time)</span></span>;</span><br><span class="line"><span class="comment">// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数</span></span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addYears</span><span class="params">(<span class="type">int</span> nyears)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMonths</span><span class="params">(<span class="type">int</span> nmonths)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addDays</span><span class="params">(qint64 ndays)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addSecs</span><span class="params">(qint64 s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">QDateTime <span class="title">QDateTime::addMSecs</span><span class="params">(qint64 msecs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到对象中的日期</span></span><br><span class="line"><span class="function">QDate <span class="title">QDateTime::date</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 得到对象中的时间</span></span><br><span class="line"><span class="function">QTime <span class="title">QDateTime::time</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数</span></span><br><span class="line"><span class="function">QString <span class="title">QDateTime::toString</span><span class="params">(<span class="type">const</span> QString &amp;format)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符重载 ==&gt; 日期时间对象的比较</span></span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>!=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&lt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="built_in">operator</span>&lt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>==(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> QDateTime::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> QDateTime &amp;other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="comment">// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QDateTime <span class="title">QDateTime::currentDateTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/aoxixi/article/details/84554222">QT中的 容器（container）</a></p>
<p><a href="https://blog.csdn.net/weixin_35638392/article/details/84197703">使用QContiguousCache管理内存</a></p>
<p><a href="https://blog.csdn.net/panchang199266/article/details/104632914">三十七、Qt缓存之QCache</a></p>
<h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h3 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h3><p>QList模板提供了一个列表，实际上是一个指针数组，当项目数小于1000时，可以实现快速的插入删除操作</p>
<p>QList<T> 是 Qt 的通用容器类之一。它将项目存储在一个列表中，该列表提供基于索引的快速访问和基于索引的插入和删除。<br>QList<T>、QLinkedList<T> 和 QVector<T> 提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。</p>
<p><strong>使用概述：</strong></p>
<ul>
<li>QVector 应该是您的默认首选。 QVector<T> 通常会比 QList<T> 提供更好的性能，因为 QVector<T> 总是将其项按顺序存储在内存中，其中 QList<T> 将在堆上分配它的项，除非 sizeof(T) &lt;&#x3D; sizeof(void *) 并且 T 已使用 Q_DECLARE_TYPEINFO 声明为 Q_MOVABLE_TYPE 或 Q_PRIMITIVE_TYPE。</li>
<li>然而，QList 在整个 Qt API 被大量使用，用于传递参数和返回值。 使用 QList可以很方便的与这些 API 进行交互。</li>
<li>如果您需要一个真正的链表，它保证常量时间内插入列表，并且使用迭代器指向项而不是索引，那么请使用QLinkedList。</li>
</ul>
<h4 id="公有函数"><a href="#公有函数" class="headerlink" title="公有函数"></a>公有函数</h4><ul>
<li>添加数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持流插入</span></span><br><span class="line"><span class="built_in">QList</span>&lt;<span class="type">int</span>&gt;()&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="number">4</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> QList&lt;T&gt; &amp;value)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">QList::iterator <span class="title">insert</span><span class="params">(QList::iterator before, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepend</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">T &amp;<span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">first</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">T &amp;<span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">last</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">constFirst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">constLast</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回下标为i的元素，如果下标i不合法，则返回defaultValue</span></span></span><br><span class="line"><span class="function">T <span class="title">value</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">T <span class="title">value</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T &amp;defaultValue)</span> <span class="type">const</span>  </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">T &amp;<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="keyword">operator</span>[]<span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回从位置pos开始的子列表。如果length为-1(默认)，则包含pos中的所有元素; </span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">mid</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> length = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QList::iterator <span class="title">erase</span><span class="params">(QList::iterator pos)</span></span></span><br><span class="line"><span class="function">QList::iterator <span class="title">erase</span><span class="params">(QList::iterator begin, QList::iterator end)</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除元素   </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeAll</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">removeOne</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeAt</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除元素并返回它，如果不使用返回值，removeAt()会更高效 </span></span></span><br><span class="line"><span class="function">T <span class="title">takeAt</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">T <span class="title">takeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">T <span class="title">takeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找&#x2F;替换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回value在列表中第一次出现的索引位置，从索引位置from向前搜索。 如果没有匹配的项，则返回-1。  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> T &amp;value, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回value在列表中最后一次出现的索引位置，从索引位置from反向搜索。如果from是-1(默认值)，则搜索从最后一项开始。如果没有匹配的项，则返回-1。     </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="type">const</span> T &amp;value, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//将索引位置为i的项替换为value</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果列表中包含值的出现，则返回true; 否则返回false。 该函数要求值类型具有operator==()的实现。     </span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>交换&#x2F;移动</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将索引位置from到索引位置to  </span></span><br><span class="line"><span class="comment">//[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;] move(1,4)-&gt; [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;B&quot;, &quot;F&quot;]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QList&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//交换下标i j的元素    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapItemsAt</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果列表第一项/后一项等于value,则返回true; 否则返回false。  </span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">endsWith</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//预分配空间大小    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>和其他容器互转</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSet&lt;T&gt; <span class="title">toSet</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">toStdList</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QVector&lt;T&gt; <span class="title">toVector</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] QList&lt;T&gt; <span class="title">fromSet</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;set)</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] QList&lt;T&gt; <span class="title">fromStdList</span><span class="params">(<span class="type">const</span> std::list&lt;T&gt; &amp;list)</span></span></span><br><span class="line"><span class="function">[<span class="type">static</span>] QList&lt;T&gt; <span class="title">fromVector</span><span class="params">(<span class="type">const</span> QVector&lt;T&gt; &amp;vector)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QStringList"><a href="#QStringList" class="headerlink" title="QStringList"></a>QStringList</h3><p>QStringList继承自QList<QString>。 它提供基于索引的快速访问以及快速插入和删除。 将字符串列表作为值参数传递既快速又安全。<br>        QList的所有功能也适用于QStringList。 例如，可以使用isEmpty()来测试列表是否为空，还可以调用append()、prepend()、insert()、replace()、removeAll()、removeAt()、removeFirst()、removeLast()和removeOne()等函数来修改QStringList。 此外，QStringList提供了一些方便的函数，使处理字符串列表更容易:  </p>
<ul>
<li>判断是否包含某个字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>过滤：返回包含子字符串str的所有字符串的列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QStringList <span class="title">filter</span><span class="params">(<span class="type">const</span> QString &amp;str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QStringList <span class="title">filter</span><span class="params">(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QStringList <span class="title">filter</span><span class="params">(<span class="type">const</span> QRegExp &amp;rx)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QStringList <span class="title">filter</span><span class="params">(<span class="type">const</span> QRegularExpression &amp;re)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从左往右查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> QRegExp &amp;rx, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(QStringView str, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(QLatin1String str, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(QRegExp &amp;rx, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">indexOf</span><span class="params">(<span class="type">const</span> QRegularExpression &amp;re, <span class="type">int</span> from = <span class="number">0</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//从右往左查找    </span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="type">const</span> QRegExp &amp;rx, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(QStringView str, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(QLatin1String str, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(QRegExp &amp;rx, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="type">const</span> QRegularExpression &amp;re, <span class="type">int</span> from = <span class="number">-1</span>)</span> <span class="type">const</span>   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>连接：将QStringList中的所有字符串连接为一个字符串，每个元素由给定的分隔符(可以是空串)分隔。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//支持流插入 &lt;&lt;</span></span><br><span class="line"><span class="function">QString <span class="title">join</span><span class="params">(<span class="type">const</span> QString &amp;separator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QString <span class="title">join</span><span class="params">(QStringView separator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QString <span class="title">join</span><span class="params">(QLatin1String separator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QString <span class="title">join</span><span class="params">(QChar separator)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除：从QStringList中删除重复的元素。 返回已删除元素的数量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>替换：返回一个字符串列表，其中每个字符串在找到before文本时都将before文本替换为after文本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(<span class="type">const</span> QString &amp;before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span></span><br><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(QStringView before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span></span><br><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(<span class="type">const</span> QString &amp;before, QStringView after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span></span><br><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(QStringView before, <span class="type">const</span> QString &amp;after, Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span></span><br><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(<span class="type">const</span> QRegExp &amp;rx, <span class="type">const</span> QString &amp;after)</span></span></span><br><span class="line"><span class="function">QStringList &amp;<span class="title">replaceInStrings</span><span class="params">(<span class="type">const</span> QRegularExpression &amp;re, <span class="type">const</span> QString &amp;after)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>排序：升序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Qt::CaseSensitivity cs = Qt::CaseSensitive)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a>QLinkedList</h3><p>单链表</p>
<h3 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a>QVector</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回vector底层数组指针。只要不重新分配vector对象，指针就保持有效。 这个函数在将vector传递给接受普通c++数组的函数时非常有用。    </span></span><br><span class="line"><span class="function">T *<span class="title">data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//将value赋给向量中的所有项。 如果size不同于-1(默认值)，则vector的大小将被调整为size之前的大小。</span></span></span><br><span class="line"><span class="function">QVector&lt;T&gt; &amp;<span class="title">fill</span><span class="params">(<span class="type">const</span> T &amp;value, <span class="type">int</span> size = <span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QStack"><a href="#QStack" class="headerlink" title="QStack"></a>QStack</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QStack&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function">T &amp;<span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QQueue"><a href="#QQueue" class="headerlink" title="QQueue"></a>QQueue</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除队头并返回它  </span></span><br><span class="line"><span class="function">T <span class="title">dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将值t加到队尾    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回队头的引用</span></span></span><br><span class="line"><span class="function">T &amp;<span class="title">head</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">head</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(QQueue&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h3><p>QMap&lt;Key, T&gt; 是 Qt 的通用容器类之一。 它存储(键，值)对，并提供与键关联的值的快速查找。<br>        QMap 和 QHash 提供非常相似的功能。 区别在于：</p>
<ul>
<li>QHash 提供比 QMap 更快的平均查找速度。</li>
<li>在迭代 QHash 时，项目是任意排序的。 使用 QMap，项目总是按键排序。</li>
<li>QHash 的键类型必须提供 operator&#x3D;&#x3D;() 和全局 qHash(Key) 函数。 QMap 的键类型必须提供 operator&lt;() 指定总顺序。 从 Qt 5.8.1 开始，使用指针类型作为键也是安全的，即使底层 operator&lt;() 不提供全序。</li>
</ul>
<h4 id="公有函数-1"><a href="#公有函数-1" class="headerlink" title="公有函数"></a>公有函数</h4><ul>
<li>添加数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入新的键值对，如果已经有一个键为key的项，则该项的值将被value替换；如果有多个键为key的项，则最近插入的项的值将被value替换。  </span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">insert</span><span class="params">(QMap::const_iterator pos, <span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入新的键值对，如果在map中已经有一个具有相同键的项，这个函数将创建一个新的项    </span></span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">insertMulti</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">insertMulti</span><span class="params">(QMap::const_iterator pos, <span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T &amp;<span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">first</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> Key &amp;<span class="title">firstKey</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">const</span> Key <span class="title">key</span><span class="params">(<span class="type">const</span> T &amp;value, <span class="type">const</span> Key &amp;defaultKey = Key())</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">keys</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">T &amp;<span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">last</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> Key &amp;<span class="title">lastKey</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个列表，该列表包含映射中的所有键。 在映射中出现多次的键在返回的列表中只出现一次。      </span></span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">uniqueKeys</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">//将其他map中的所有项目插入到该map中。      </span></span></span><br><span class="line"><span class="function">QMap&lt;Key, T&gt; &amp;<span class="title">unite</span><span class="params">(<span class="type">const</span> QMap&lt;Key, T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="title">value</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;defaultValue = T())</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">values</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">values</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">T &amp;<span class="keyword">operator</span>[]<span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="keyword">operator</span>[]<span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">erase</span><span class="params">(QMap::iterator pos)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">T <span class="title">take</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 返回两个迭代器</span></span></span><br><span class="line"><span class="comment"><span class="function">迭代器1：是指向当前 map 容器中第一个大于或等于 key 的键值对的迭代器（lowerBound()）。</span></span></span><br><span class="line"><span class="comment"><span class="function">迭代器2：是指向当前 map 容器中第一个大于 key 的键值对的迭代器。（upperBound()）</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function">QPair&lt;QMap::iterator, QMap::iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QPair&lt;QMap::const_iterator, QMap::const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QMap::const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">lowerBound</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QMap::const_iterator <span class="title">lowerBound</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMap::iterator <span class="title">upperBound</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QMap::const_iterator <span class="title">upperBound</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QMultiMap"><a href="#QMultiMap" class="headerlink" title="QMultiMap"></a>QMultiMap</h3><ul>
<li>插入和替换：插入新的键值对。  <ul>
<li>如果已经有一个键为key的项，则该项的值将被value替换。 </li>
<li>如果有多个键为key的项，则最近插入的项的值将被value替换。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> QMap&lt;Key, T&gt;::<span class="function">iterator <span class="title">replace</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h3 id="QHash"><a href="#QHash" class="headerlink" title="QHash"></a>QHash</h3><ul>
<li>添加数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QHash::iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">QHash::iterator <span class="title">insertMulti</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Key <span class="title">key</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> Key <span class="title">key</span><span class="params">(<span class="type">const</span> T &amp;value, <span class="type">const</span> Key &amp;defaultKey)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">keys</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">QList&lt;Key&gt; <span class="title">uniqueKeys</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QHash&lt;K, V&gt; &amp;<span class="title">unite</span><span class="params">(<span class="type">const</span> QHash&lt;K, V&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="title">value</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T <span class="title">value</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;defaultValue)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">values</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">values</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QHash::iterator <span class="title">erase</span><span class="params">(QHash::const_iterator pos)</span></span></span><br><span class="line"><span class="function">QHash::iterator <span class="title">erase</span><span class="params">(QHash::iterator pos)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QPair&lt;QHash::iterator, QHash::iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QPair&lt;QHash::const_iterator, QHash::const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">T <span class="title">take</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QHash::iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">QHash::const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h3 id="QMultiHash"><a href="#QMultiHash" class="headerlink" title="QMultiHash"></a>QMultiHash</h3><p><code>继承自QHash</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> QHash&lt;Key, T&gt;::<span class="function">iterator <span class="title">replace</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span> <span class="comment">//班级</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grade</span>(<span class="type">int</span> number, <span class="type">const</span> QString&amp; GradeName)</span><br><span class="line">        :<span class="built_in">number</span>(number),<span class="built_in">name</span>(GradeName)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> QDebug <span class="keyword">operator</span>&lt;&lt;(QDebug out, <span class="type">const</span> Grade&amp; stu);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Grade&amp; left, <span class="type">const</span> Grade&amp; right);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Grade&amp; stu, uint seed = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> number;     <span class="comment">//班级号</span></span><br><span class="line">    QString name;   </span><br><span class="line">&#125;;</span><br><span class="line">QDebug <span class="keyword">operator</span>&lt;&lt;(QDebug out, <span class="type">const</span> Grade&amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; stu.number &lt;&lt;<span class="string">&quot;,&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Grade&amp; left, <span class="type">const</span> Grade&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> (left.number == right.number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Grade&amp; stu, uint seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stu.number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QHash&lt;Grade, QString&gt; hash;</span><br><span class="line">    hash.<span class="built_in">insert</span>(<span class="built_in">Grade</span>(<span class="number">1403</span>, <span class="string">&quot;安卓&quot;</span>), <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    hash.<span class="built_in">insert</span>(<span class="built_in">Grade</span>(<span class="number">1406</span>, <span class="string">&quot;苹果&quot;</span>), <span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="QSet"><a href="#QSet" class="headerlink" title="QSet"></a>QSet</h3><ul>
<li>添加数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSet::iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QList&lt;T&gt; <span class="title">values</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QList&lt;T&gt; <span class="title">toList</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QSet::iterator <span class="title">erase</span><span class="params">(QSet::const_iterator pos)</span></span></span><br><span class="line"><span class="function">QSet::iterator <span class="title">erase</span><span class="params">(QSet::iterator pos)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T &amp;value)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;other)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">QSet::const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> T &amp;value)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QSet::iterator <span class="title">find</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>交集，差集，并集</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并集：ohter集合中不在这个集合中的每一项都被插入到这个集合中。 返回对该集合的引用。      </span></span><br><span class="line"><span class="function">QSet&lt;T&gt; &amp;<span class="title">unite</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//差集：从该集合中删除包含在ohter集合中的所有项。 返回对该集合的引用。  </span></span></span><br><span class="line"><span class="function">QSet&lt;T&gt; &amp;<span class="title">QSet::subtract</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//交集：从该集合中删除ohter集合中不包含的所有项。 返回对该集合的引用。      </span></span></span><br><span class="line"><span class="function">QSet&lt;T&gt; &amp;<span class="title">intersect</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果该集合与ohter集合至少有一个共同项，则返回true。      </span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersects</span><span class="params">(<span class="type">const</span> QSet&lt;T&gt; &amp;other)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="8，算法"><a href="#8，算法" class="headerlink" title="8，算法"></a>8，算法</h2><p>直接使用STL中的算法</p>
<h2 id="QtGlobal"><a href="#QtGlobal" class="headerlink" title="QtGlobal"></a>QtGlobal</h2><p>Qt类的头文件都会包含该头文件，所以不用再显式定义了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">qAbs</span><span class="params">(<span class="type">const</span> T &amp;t)</span>	<span class="comment">//求绝对值</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回value限定在min至max范围之内的值</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">qBound</span><span class="params">(<span class="type">const</span> T &amp;min, <span class="type">const</span> T &amp;val, <span class="type">const</span> T &amp;max)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果p1和p2近似相等，返回true</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">qFuzzyCompare</span><span class="params">(<span class="type">double</span> p1, <span class="type">double</span> p2)</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">qFuzzyCompare</span><span class="params">(<span class="type">float</span> p1, <span class="type">float</span> p2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果浮点数约等于0，返回true    </span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">qFuzzyIsNull</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">qFuzzyIsNull</span><span class="params">(<span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回无穷大的数    </span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">qInf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//求最大值和最小值</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">qMax</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">qMin</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//四舍五入到最近的整数</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">qRound64</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">qRound64</span><span class="params">(<span class="type">float</span> d)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qRound</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qRound</span><span class="params">(<span class="type">float</span> d)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获得Qt版本    </span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">qVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h2 id="QtMath"><a href="#QtMath" class="headerlink" title="QtMath"></a>QtMath</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">qAcos</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qAsin</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qAtan2</span><span class="params">(qreal y, qreal x)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qAtan</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qCeil</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qCos</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function"><span class="comment">//角度转弧度    </span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">qDegreesToRadians</span><span class="params">(<span class="type">float</span> degrees)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">qDegreesToRadians</span><span class="params">(<span class="type">double</span> degrees)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qExp</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qFabs</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qFloor</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qLn</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">quint32 <span class="title">qNextPowerOfTwo</span><span class="params">(quint32 value)</span></span></span><br><span class="line"><span class="function">quint64 <span class="title">qNextPowerOfTwo</span><span class="params">(quint64 value)</span></span></span><br><span class="line"><span class="function">quint32 <span class="title">qNextPowerOfTwo</span><span class="params">(qint32 value)</span></span></span><br><span class="line"><span class="function">quint64 <span class="title">qNextPowerOfTwo</span><span class="params">(qint64 value)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qPow</span><span class="params">(qreal x, qreal y)</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">qRadiansToDegrees</span><span class="params">(<span class="type">float</span> radians)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">qRadiansToDegrees</span><span class="params">(<span class="type">double</span> radians)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qSin</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qSqrt</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function">qreal <span class="title">qTan</span><span class="params">(qreal v)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h1 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h1><p>简单来说，一个操作要对应一个资源的运动。</p>
<ol>
<li>信号的本质</li>
</ol>
<p>信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。</p>
<p>因此根据上述的描述我们得到一个结论：信号的本质就是事件，比如：</p>
<ul>
<li>按钮单击、双击</li>
<li>窗口刷新</li>
<li>鼠标移动、鼠标按下、鼠标释放</li>
<li>键盘输入</li>
</ul>
<p>那么在Qt中信号是通过什么形式呈现给使用者的呢？</p>
<ul>
<li>我们对哪个窗口进行操作, 哪个窗口就可以捕捉到这些被触发的事件。</li>
<li>对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号。</li>
<li>信号的呈现形式就是函数， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数， 通知使用者。</li>
</ul>
<p><code>在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。</code></p>
<h2 id="1-槽的本质"><a href="#1-槽的本质" class="headerlink" title="1. 槽的本质"></a>1. 槽的本质</h2><p>槽（Slot）就是对信号响应的函数。槽就是一个函数，与一般的C++函数是一样的，可以定义在类的任何部分（public、private或 protected），可以具有任何参数，可以被重载，也可以被直接调用(但是不能有默认参数)。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p>
<p>举个简单的例子：</p>
<p>女朋友说：“我肚子饿了！”，于是我带她去吃饭。</p>
<p>上边例子中相当于女朋友发出了一个信号， 我收到了信号并其将其处理掉了。</p>
<ul>
<li>女朋友 -&gt; 发送信号的对象, 信号内容: 我饿了</li>
<li>我 -&gt; 接收信号的对象并且处理掉了这个信号, 处理动作: 带她去吃饭</li>
</ul>
<p><code>在Qt中槽函数的所有者也是某个类的实例对象。</code></p>
<p>写信：发件人    信的内容      收件人  收到信做事情</p>
<h3 id="1-1-信号和槽的关系"><a href="#1-1-信号和槽的关系" class="headerlink" title="1.1 信号和槽的关系"></a>1.1 信号和槽的关系</h3><p>在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起，好比牛郎和织女想要相会必须要有喜鹊为他们搭桥一样。</p>
<p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection  <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, 								</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *signal, 								</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, 							</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, 								</span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数:</strong><ul>
<li><strong>sender</strong>: 发出信号的对象</li>
<li><strong>signal</strong>: sender对象的信号，信号是一个函数</li>
<li><strong>receiver</strong>: 信号接收者</li>
<li><strong>method</strong>: receiver对象的槽函数, 当检测到sender发出了signal信号, receiver对象调用method方法</li>
</ul>
</li>
</ul>
<p><code> connect函数相对于做了信号处理动作的注册,调用conenct连接信号与槽时，sender对象的信号并没有产生, 因此receiver对象的method也不会被调用,method槽函数本质是一个回调函数, 调用的时机是信号产生之后。 调用槽函数是Qt框架来执行的,connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功</code>。</p>
<h2 id="2-标准信号槽使用"><a href="#2-标准信号槽使用" class="headerlink" title="2. 标准信号槽使用"></a>2. 标准信号槽使用</h2><h3 id="2-1-标准信号-槽"><a href="#2-1-标准信号-槽" class="headerlink" title="2.1 标准信号&#x2F;槽"></a>2.1 标准信号&#x2F;槽</h3><p>在Qt提供的很多类中都可以对用户触发的某些特定事件进行检测,  当事件被触发后就会产生对应的信号, 这些信号都是Qt类内部自带的, 因此称之为标准信号。</p>
<p>同样的，在Qt的很多类内部为我了提供了很多功能函数，并且这些函数也可以作为触发的信号的处理动作，有这类特性的函数在Qt中称之为标准槽函数。</p>
<p>系统自带的信号和槽通常如何查找呢，这个就需要利用帮助文档了，在帮助文档中比如我们上面的按钮的点击信号，在帮助文档中输入QPushButton，首先我们可以在<code>Contents</code>中寻找关键字 <code>signals</code>，信号的意思，但是我们发现并没有找到，这时候我们应该看当前类从父类继承下来了哪些信号，因此我们去他的父类QAbstractButton中就可以找到该关键字，点击signals索引到系统自带的信号有如下几个</p>
<h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><blockquote>
<p>功能实现： 点击窗口上的按钮, 关闭窗口</p>
<ul>
<li>按钮: 信号发出者 -&gt; <code>QPushButton</code></li>
<li>窗口: 信号的接收者和处理者 -&gt; <code>QWidget</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单击按钮发出的信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractButton::clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭窗口的槽函数</span></span></span><br><span class="line"><span class="function">[slot] <span class="type">bool</span> <span class="title">QWidget::close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单击按钮关闭窗口</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;closewindow, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-自定义信号槽使用"><a href="#3-自定义信号槽使用" class="headerlink" title="3. 自定义信号槽使用"></a>3. 自定义信号槽使用</h2><blockquote>
<p>Qt框架提供的信号槽在某些特定场景下是无法满足我们的项目需求的，因此我们还设计自己需要的的信号和槽，同样还是使用connect()对自定义的信号槽进行连接。</p>
</blockquote>
<p>如果想要使用自定义的信号和槽, 首先要编写新的类并且让其继承Qt的某些标准类,我们自己编写的类想要在Qt中使用使用信号槽机制, 那么必须要满足的如下条件: </p>
<ul>
<li>这个类必须从QObject类或者是其子类进行派生</li>
<li>在定义类的第一行头文件中加入 Q_OBJECT 宏</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-1-自定义信号"><a href="#3-1-自定义信号" class="headerlink" title="3.1 自定义信号"></a>3.1 自定义信号</h3><ul>
<li><p>信号是类的成员函数</p>
</li>
<li><p>返回值是 void 类型</p>
</li>
<li><p>参数可以随意指定, 信号也支持重载</p>
</li>
<li><p>信号需要使用 signals 关键字进行声明, 使用方法类似于public等关键字</p>
</li>
<li><p>信号函数只需要声明, 不需要定义(没有函数体实现)</p>
</li>
<li><p>在程序中发送自定义信号: 发送信号的本质就是调用信号函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">emit <span class="title">mysignals</span><span class="params">()</span></span>;	<span class="comment">//发送信号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="color:red;font-size:13px;">emit是一个空宏，没有特殊含义，仅用来表示这个语句是发射一个信号，不写当然可以，但是不推荐。</span></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例: 信号重载</span></span><br><span class="line"><span class="comment">// Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testsignal</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//qRegisterMetaType</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>信号参数的作用是数据传递, 谁调用信号函数谁就指定实参，实参最终会被传递给槽函数</p>
<h3 id="3-2-自定义槽"><a href="#3-2-自定义槽" class="headerlink" title="3.2 自定义槽"></a>3.2 自定义槽</h3><blockquote>
<p>槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>返回值是 void 类型</li>
<li>槽函数也支持重载<ul>
<li>槽函数参数个数, 需要看连接的信号的参数个数</li>
<li>槽函数的参数是用来接收信号发送的数据的, 信号的参数就是需要发送的数据</li>
<li>举例:<ul>
<li>信号函数: void testsig(int a, double b);</li>
<li>槽函数:   void testslot(int a, double b);</li>
</ul>
</li>
<li>总结:<ul>
<li>槽函数的参数应该和对应的信号的参数个数, 类型一一对应</li>
<li>信号的参数可以大于等于槽函数的参数个数，未被槽函数接受的数据会被忽略<ul>
<li>信号函数: void testsig(int a, double b);</li>
<li>槽函数:   void testslot(int a);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>槽函数的类型:</strong></p>
<ul>
<li>成员函数<ul>
<li>普通成员函数</li>
<li>静态成员函数</li>
</ul>
</li>
<li>全局函数</li>
<li>lambda表达式(匿名函数)</li>
</ul>
<ol start="4">
<li>槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写)<ul>
<li>public slots:</li>
<li>private slots:</li>
<li>protected slots:</li>
</ul>
</li>
</ol>
<p>场景举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 女朋友饿了, 我请她吃饭</span></span><br><span class="line"><span class="comment">// class GirlFriend</span></span><br><span class="line"><span class="comment">// class OneSelf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GirlFriend</span>(QObject*parent = <span class="literal">nullptr</span>):<span class="built_in">QObject</span>(parent)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OneSelf</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OneSelf</span>(QObject*parent = <span class="literal">nullptr</span>):<span class="built_in">QObject</span>(parent)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goEat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;goEat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">goEatFood</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;goEatFood&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onHungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;宝贝饿了呀，多喝热水哟~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onBtnClicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GirlFriend *girl;</span><br><span class="line">    OneSelf* self;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>widget.cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    girl = <span class="keyword">new</span> <span class="built_in">GirlFriend</span>(<span class="keyword">this</span>);</span><br><span class="line">    self = <span class="keyword">new</span> <span class="built_in">OneSelf</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//连接槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::onHungry);</span><br><span class="line">	<span class="comment">//连接普通成员函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEat);</span><br><span class="line">	<span class="comment">//连接静态成员函数</span></span><br><span class="line">    <span class="built_in">connect</span>(girl,&amp;GirlFriend::hungry,self,&amp;OneSelf::goEatFood);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按下就饿了&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//通过widget间接发送girl的hungry信号    </span></span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::onBtnClicked);</span><br><span class="line">     <span class="comment">//连接信号，直接发送girl的hungry信号   </span></span><br><span class="line">    <span class="comment">//connect(btn,&amp;QPushButton::clicked,girl,&amp;GirlFriend::hungry);    </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onBtnClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit girl-&gt;<span class="built_in">hungry</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-信号槽拓展"><a href="#4-信号槽拓展" class="headerlink" title="4. 信号槽拓展"></a>4. 信号槽拓展</h2><h3 id="4-1-信号槽使用拓展"><a href="#4-1-信号槽使用拓展" class="headerlink" title="4.1 信号槽使用拓展"></a>4.1 信号槽使用拓展</h3><ul>
<li><p>一个信号可以连接多个槽函数, 发送一个信号有多个处理动作</p>
<ul>
<li>需要写多个<code>connect</code>连接</li>
<li>信号的接收者可以是一个对象, 也可以是多个对象</li>
</ul>
</li>
<li><p>一个槽函数可以连接多个信号, 多个不同的信号, 处理动作是相同的</p>
<ul>
<li>写多个<code>connect</code>就可以</li>
</ul>
</li>
<li><p>信号可以连接信号</p>
<ul>
<li><p>信号接收者可以不出来接收的信号, 继续发出新的信号 -&gt; 传递了数据, 并没有进行处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;one&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton*btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;two&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//点击btn按钮，会让btn2按钮发出clicked信号</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,btn2,&amp;QPushButton::clicked);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(btn2,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::onClicked);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;okok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>信号槽是可以断开的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-信号槽的连接方式"><a href="#4-2-信号槽的连接方式" class="headerlink" title="4.2 信号槽的连接方式"></a>4.2 信号槽的连接方式</h3><ul>
<li><p>Qt5的连接方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法:</span></span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    	<span class="type">const</span> QObject *sender, PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">		Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender, &amp;QObject::signal, </span><br><span class="line">        <span class="type">const</span> QObject *receiver, &amp;QObject::method);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>Qt4的连接方式</p>
<blockquote>
<p>这种旧的信号槽连接方式在Qt5中是支持的, 但是不推荐使用, 因为这种方式在进行信号槽连接的时候, 信号槽函数通过宏<code>SIGNAL</code>和<code>SLOT</code>转换为字符串类型。</p>
<p>因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测， 如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Qt4的信号槽连接方式</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="type">const</span> QObject *sender,<span class="built_in">SIGNAL</span>(信号函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)),</span><br><span class="line">        <span class="type">const</span> QObject *receiver,<span class="built_in">SLOT</span>(槽函数名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="comment">// Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">   	<span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hungury</span><span class="params">(QString somthing)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>基于上面写的信号与槽，我们来处理如下逻辑: 我饿了, 我要吃东西</p>
<ul>
<li><p><strong>分析</strong>: 信号的发出者是我自己, 信号的接收者也是我自己</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Me m;</span><br><span class="line"><span class="comment">// Qt4处理方式  注意不要把信号与槽的名字写错了，因为是转为字符串写错了不会报错，但是连接会失败</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>()), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;m, <span class="built_in">SIGNAL</span>(<span class="built_in">eat</span>(QString)), &amp;m, <span class="built_in">SLOT</span>(<span class="built_in">hungury</span>(QString)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qt5处理方式</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);	<span class="comment">// error:no matching member function for call to &#x27;connect&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么Qt4的方式没有错误，Qt5的方式却有问题了呢？</strong></p>
<ul>
<li>Qt4的方式在传信号和槽的时候用了宏进行强转，而且都带了参数，不会有二义性问题产生</li>
<li>Qt5中，信号和槽都有重载，此事connect函数根本就不知道你要使用的是重载中的哪一个，所以只能报错咯！</li>
</ul>
</li>
<li><p><strong>如何解决Qt5中的信号和槽重载中的二义性问题呢？</strong></p>
<ul>
<li><p>一，通过函数指针解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号</span></span><br><span class="line"><span class="built_in">void</span> (Me::*funchungury)() = &amp;Me::hungury;</span><br><span class="line"><span class="built_in">void</span> (Me::*funchungury_QString)(QString) = &amp;Me::hungury;</span><br><span class="line"><span class="comment">//槽</span></span><br><span class="line"><span class="built_in">void</span> (Me::*funceat)() = &amp;Me::eat;</span><br><span class="line"><span class="built_in">void</span> (Me::*funceat_QString)(QString) = &amp;Me::eat;</span><br><span class="line"><span class="comment">//有参连接</span></span><br><span class="line"><span class="built_in">connect</span>(me,funchungury_QString,me,funceat_QString);</span><br><span class="line"><span class="comment">//无参连接</span></span><br><span class="line"><span class="built_in">connect</span>(me,funchungury,me,funceat);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>二，通过Qt提供的重载类(QOverload)解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参连接</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,QOverload&lt;QString&gt;::<span class="built_in">of</span>(&amp;MyButton::hungury),<span class="keyword">this</span>,QOverload&lt;QString&gt;::<span class="built_in">of</span>(&amp;MyButton::eat));</span><br><span class="line"><span class="comment">//无参连接</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,QOverload&lt;&gt;::<span class="built_in">of</span>(&amp;MyButton::hungury),<span class="keyword">this</span>,QOverload&lt;&gt;::<span class="built_in">of</span>(&amp;MyButton::eat));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug</li>
<li>Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生</li>
<li>当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响</li>
<li>当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针</li>
</ul>
</li>
</ul>
<h3 id="4-3-Lambda表达式"><a href="#4-3-Lambda表达式" class="headerlink" title="4.3 Lambda表达式"></a>4.3 Lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;touch me&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton*btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;天王盖地虎&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁止用&amp;引用捕获临时变量，因为函数结束变量会销毁，在lambda中使用会产生错误</span></span><br><span class="line"><span class="comment">//应该使用按值捕获 = </span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span>  <span class="type">int</span> flag = <span class="literal">false</span>;	<span class="comment">//可以这样用</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;小鸡顿蘑菇&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;天王盖地虎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flag = !flag;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Lambda表达式是C++11最重要也是最常用的特性之一，是现代编程语言的一个特点，简洁，提高了代码的效率并且可以使程序更加灵活，Qt是完全支持c++语法的， 因此在Qt中也可以使用Lambda表达式。</p>
<p>Lambda表达式就是一个匿名函数， 语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br><span class="line">	- capture: 捕获列表</span><br><span class="line">    - params: 参数列表</span><br><span class="line">    - opt: 函数选项</span><br><span class="line">    - ret: 返回值类型</span><br><span class="line">    - body: 函数体</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 示例代码-&gt;匿名函数的调用:</span></span><br><span class="line"><span class="type">int</span> ret = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于Lambda表达式的细节介绍:</p>
<ol>
<li>捕获列表: 捕获一定范围内的变量<ul>
<li><code>[] </code>- 不捕捉任何变量</li>
<li><code>[&amp;] </code>- 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (<code>按引用捕获</code>)</li>
<li><code>[=] </code>-  捕获外部作用域中所有变量, 并作为副本在函数体内使用 (<code>按值捕获</code>)<ul>
<li>拷贝的副本在匿名函数体内部是只读的</li>
</ul>
</li>
<li><code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li>
<li><code>[bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li><code>[&amp;bar]</code> - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li><code>[this]</code> - 捕获当前类中的this指针<ul>
<li>让lambda表达式拥有和当前类成员函数同样的访问权限</li>
<li>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项</li>
</ul>
</li>
</ul>
</li>
<li>参数列表: 和普通函数的参数列表一样</li>
<li>opt 选项 –&gt;  <code>可以省略</code><ul>
<li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li>
</ul>
</li>
<li>返回值类型:<ul>
<li>标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略</li>
</ul>
</li>
<li>函数体:<ul>
<li>函数的实现，这部分不能省略，但函数体可以为空。</li>
</ul>
</li>
</ol>
<h1 id="QWidget槽函数"><a href="#QWidget槽函数" class="headerlink" title="QWidget槽函数"></a>QWidget槽函数</h1><p><strong>show,hide,setVisible,setHidden,close 小结</strong></p>
<ul>
<li>0，在Qt中如果一定要自己释放对象，官方推荐使用<code>[slot] void QObject::deleteLater()</code>来释放对象</li>
<li>1，<code>[slot] void setVisible(bool visible)</code> 设置Widget可见或不可见</li>
<li>2，<code>slot] void QWidget::setHidden(bool *hidden*)</code> 1号的马甲</li>
<li>3，<code>[slot] void QWidget::show()</code> 1号的马甲</li>
<li>4，<code>[slot] void QWidget::hide()</code>  1号的马甲</li>
<li>5，<code>[slot] bool QWidget::close()</code> 看情况调用4号或者0号(该部件是否有父部件)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">呵呵，<span class="built_in">show</span>()、<span class="built_in">hide</span>()、<span class="built_in">setVisible</span>()、<span class="built_in">setHidden</span>() 这<span class="number">4</span>个函数让人看得眼花缭乱。怎么办？</span><br><span class="line">看看代码吧：</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setVisible</span><span class="params">(<span class="type">bool</span> visible)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setHidden</span><span class="params">(<span class="type">bool</span> hidden)</span> </span>&#123; <span class="built_in">setVisible</span>(!hidden); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">setVisible</span>(<span class="literal">true</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123; <span class="built_in">setVisible</span>(<span class="literal">false</span>); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码很清楚：这四个东西之中，只有 setVisible 是独立的，其他三个都是它的马甲！<br>setVisible 的作用是什么呢？顾名思义，使得一个Widget可见或不可见。<br><strong>要点</strong>：不可见，是Widget不在界面上显示，但不代表对象被析构！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[1]创建关闭自己的按钮</span></span><br><span class="line">QPushButton* closeBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;closeSelf&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(closeBtn,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::close);</span><br><span class="line"><span class="comment">//点击右上角关闭按钮会销毁窗口</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>,&amp;QObject::destroyed,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;this destroyed&quot;</span>;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[2]创建子窗口</span></span><br><span class="line">QWidget* subWidget = <span class="keyword">new</span> QWidget;</span><br><span class="line">subWidget-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;subWidget&quot;</span>);</span><br><span class="line">subWidget-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//subWidget-&gt;setAttribute(Qt::WidgetAttribute::WA_DeleteOnClose);   //点击关闭按钮时销毁窗口        </span></span><br><span class="line"><span class="built_in">connect</span>(subWidget,&amp;QWidget::destroyed,<span class="keyword">this</span>,[=]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;subWidget destroyed&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//[3]创建关闭子窗口的按钮</span></span><br><span class="line">QPushButton*closeSubWidgetBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;closeSubWidget&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">closeSubWidgetBtn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(closeSubWidgetBtn,&amp;QPushButton::clicked,subWidget,[=]()&#123;</span><br><span class="line">    subWidget-&gt;<span class="built_in">close</span>();</span><br><span class="line">    subWidget-&gt;<span class="built_in">deleteLater</span>();   <span class="comment">//推荐这样销毁对象</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;subWidget;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//[4]创建显示子窗口的按钮</span></span><br><span class="line">QPushButton*showSubWidgetBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;showSubWidget&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">showSubWidgetBtn-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(showSubWidgetBtn,&amp;QPushButton::clicked,subWidget,&amp;QWidget::show);             </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QPoint <span class="title">mapFrom</span><span class="params">(<span class="type">const</span> QWidget *parent, <span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapFromParent</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapTo</span><span class="params">(<span class="type">const</span> QWidget *parent, <span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapToGlobal</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">QPoint <span class="title">mapToParent</span><span class="params">(<span class="type">const</span> QPoint &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这几个函数都是转换相对坐标系用的. <strong>用另一个坐标系统的坐标值, 来表达当前坐标系统中某个坐标所指向的某个点,</strong></p>
<p>记住: 一定要先确<strong>两个坐标系统</strong>再确定<strong>一个点</strong></p>
</li>
<li><p><strong>相对坐标</strong>：获取自己相对于父控件的位置 QWidget::pos()</p>
</li>
<li><p><strong>绝对坐标</strong>：将当前控件的相对位置转换为屏幕绝对位置 QWidget::mapToGlobal()</p>
</li>
<li><p><strong>绝对坐标转为相对坐标</strong>：将绝对位置对应到控件的相对位置 QWidget::mapFromGlobal()</p>
</li>
</ul>
<h2 id="设置窗口标志"><a href="#设置窗口标志" class="headerlink" title="设置窗口标志"></a>设置窗口标志</h2><ul>
<li>用Qt写一个窗口，如果继承QDialog，那窗口就只有关闭按钮，如果继承QWidget，那么就有关闭，最大化，最小化三个按钮，怎样才能让关闭按钮可用，而最大化和最小化按钮不可用呢？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅仅显示关闭按钮，添加一个帮助按钮?</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(Qt::WindowType::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint);</span><br><span class="line"><span class="comment">//从窗口标志中移除帮助按钮标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() &amp; ~Qt::WindowContextHelpButtonHint);</span><br><span class="line"><span class="comment">//移除标志或单纯添加一个标志，可以用一下简单的函数	true为设置，false为移除</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setWindowFlag</span>(Qt::WindowContextHelpButtonHint,<span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>更多标志详见<a href="#%E9%99%84%E5%BD%95%E4%B8%80">附录一 </a></li>
</ul>
<h2 id="设置窗口状态"><a href="#设置窗口状态" class="headerlink" title="设置窗口状态"></a>设置窗口状态</h2><ul>
<li>将窗口状态设置为windowState。 窗口状态是<a href="#%E9%99%84%E5%BD%95%E4%BA%8C">附录二</a>中状态的组合。</li>
<li>如果窗口不可见(即isVisible()返回false)，窗口状态将在调用show()时生效。 对于可见窗口，更改是立即的。 例如，要在全屏模式和普通模式之间切换，请使用以下代码:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">w-&gt;<span class="built_in">setWindowState</span>(w-&gt;<span class="built_in">windowState</span>() ^ Qt::WindowFullScreen);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>为了恢复和激活最小化的窗口(同时保持其最大化和&#x2F;或全屏状态)，使用以下方法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">w-&gt;<span class="built_in">setWindowState</span>((w-&gt;<span class="built_in">windowState</span>() &amp; ~Qt::WindowMinimized) | Qt::WindowActive);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>调用这个函数将隐藏小部件。 必须调用show()使小部件再次可见，在某些窗口系统中，Qt::WindowActive不是立即的，在某些情况下可能会被忽略。</li>
</ul>
<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><ul>
<li>setAttribute用来设置小部件的属性，testAttribute查看是否设置了某种属性。</li>
</ul>
<p><strong>常用属性</strong></p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>值(十进制)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Qt::WA_AcceptDrops</td>
<td>78</td>
<td>允许来自拖放操作的数据被拖放到小部件上(参见QWidget::setAcceptDrops())</td>
</tr>
<tr>
<td>Qt::WA_AlwaysShowToolTips</td>
<td>84</td>
<td>为非活动窗口启用工具提示</td>
</tr>
<tr>
<td>Qt::WA_CustomWhatsThis</td>
<td>47</td>
<td>表示小部件希望在“这是什么?”模式下继续正常运行。 这是由小部件的作者设置的。</td>
</tr>
<tr>
<td>Qt::WA_DeleteOnClose</td>
<td>55</td>
<td>使Qt在小部件接受关闭事件时删除该小部件</td>
</tr>
<tr>
<td>Qt::WA_MouseTracking</td>
<td>2</td>
<td>指示小部件启用了鼠标跟踪。 参见QWidget:: mouseTracking</td>
</tr>
<tr>
<td>Qt::WA_TranslucentBackground</td>
<td>120</td>
<td>指示小部件应该有一个半透明的背景，也就是说，小部件的任何非透明区域都将是半透明的，因为小部件将有一个alpha通道。 设置此标志将导致设置WA_NoSystemBackground。 在Windows上，小部件还需要设置Qt:: framesswindowhint窗口标志。 该标志由小部件的作者设置或清除。</td>
</tr>
</tbody></table>
<h1 id="Qt最常用控件"><a href="#Qt最常用控件" class="headerlink" title="Qt最常用控件"></a>Qt最常用控件</h1><p>其实用多了也就那样。</p>
<h4 id="按钮抽象基类-QAbstractButton"><a href="#按钮抽象基类-QAbstractButton" class="headerlink" title="按钮抽象基类(QAbstractButton)"></a>按钮抽象基类(QAbstractButton)</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h5><p>QAbstractButton类是按钮部件的抽象基类，提供了按钮所共有的功能。</p>
<p>QAbstractButton类实现了一个抽象按钮，并且让它的子类来指定如何处理用户的动作，并指定如何绘制按钮。</p>
<p>QAbstractButton提供了点击和勾选按钮。QRadioButton和QCheckBox类只提供了勾选按钮，QPushButton和QToolButton提供了点击按钮，如果需要的话，它们还可以提供切换行为。</p>
<p>任何按钮，都可以显示一个包含文本和图标的标签。</p>
<ul>
<li>setText(const QString&amp;) 设置文本</li>
<li>setIcon(const QIcon&amp;)    设置图标</li>
</ul>
<h5 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a><strong>信号与槽</strong></h5><p><strong>signals</strong></p>
<ul>
<li><em>clicked，pressed，released信号</em></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton*btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Touch Me&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按钮按下释放之后会触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;clicked&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//按钮按下触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::pressed,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;pressed&quot;</span>;&#125;);</span><br><span class="line"><span class="comment">//按钮释放触发</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::released,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;released&quot;</span>;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><em>toggled信号</em>：每当切换按钮(toggleButton)改变其状态时，就会发出此信号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">btn-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);	<span class="comment">//设置按钮可选中</span></span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::toggled,<span class="keyword">this</span>,[=]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;toggled&quot;</span>&lt;&lt;btn-&gt;<span class="built_in">isChecked</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>slots</strong></p>
<ul>
<li>void animateClick(int msec &#x3D; 100)  定时自动点击按钮</li>
<li>void click()  自动点击按钮</li>
<li>void setIconSize(const QSize &amp;size)  设置图标大小，较小的图标可能会设置无效</li>
<li>void setChecked(bool) 设置是否选中按钮(checkable必须被启用)</li>
<li>void toggle()  切换按钮的选中状态</li>
</ul>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >int void setAutoExclusive(bool)</span><br /><span style="font-size:13px">可选中按钮是否独占， 在独占按钮组(同一父对象为同一组)中，任何时候只能选中一个按钮</span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAutoRepeat(bool)</span><br /><span style="font-size:13px">如果启用，按钮按下不松开，pressed()、released()和clicked()信号会定期发出</span></td>
</tr>
<tr>
<td align="center">3</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAutoRepeatDelay(int)</span><br /><span style="font-size:13px">如果启用了autoRepeat，那么autoRepeatDelay将定义自动重复生效前的初始延迟(以毫秒为单位)。  </span></td>
</tr>
<tr>
<td align="center">4</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAutoRepeatInterval(int)</span><br /><span style="font-size:13px">如果启用了autoRepeat，则autoRepeatInterval定义了自动重复间隔的长度，以毫秒为单位。 </span></td>
</tr>
<tr>
<td align="center">5</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setCheckable(bool)</span><br /><span style="font-size:13px">设置按钮是否能够被选中，默认是不能被选中的</span></td>
</tr>
<tr>
<td align="center">6</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setDown(bool)</span><br /><span style="font-size:13px">设置按钮是否被按下</span></td>
</tr>
<tr>
<td align="center">7</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setIcon(const QIcon &amp;icon)</span><br /><span style="font-size:13px">设置图标</span></td>
</tr>
<tr>
<td align="center">8</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setShortcut(const QKeySequence &amp;key)</span><br /><span style="font-size:13px">设置快捷键</span></td>
</tr>
<tr>
<td align="center">9</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setText(const QString &amp;text)</span><br /><span style="font-size:13px">设置文本</span></td>
</tr>
</tbody></table>
<h4 id="1，按钮-PushButton"><a href="#1，按钮-PushButton" class="headerlink" title="1，按钮(PushButton)"></a>1，按钮(PushButton)</h4><p>最常用的控件之一，应用场景十分广泛。</p>
<h5 id="信号与槽-1"><a href="#信号与槽-1" class="headerlink" title="信号与槽"></a>信号与槽</h5><p><strong>signals</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<p><strong>slots</strong></p>
<p><code>void showMenu()	如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</code></p>
<h5 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >int void setAutoDefault(bool)</span><br /><span style="font-size:13px">设为自动默认按钮，按下Enter键时会自动按下按钮</span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setDefault(bool)</span><br /><span style="font-size:13px">设为自动默认按钮，按下Enter键时会自动按下按钮</span></td>
</tr>
<tr>
<td align="center">3</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setFlat(bool)</span><br /><span style="font-size:13px">去掉按钮的边框，让PushButton按钮跟背景色融为一体，在点击按钮时，会出现原来按钮背景。  </span></td>
</tr>
<tr>
<td align="center">4</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setMenu(QMenu *menu)</span><br /><span style="font-size:13px">设置菜单。 这将把按钮变成一个菜单按钮，在某些样式中，它将在按钮文本的右侧产生一个小三角形。  </span></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMenu* menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="string">&quot;Menu&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;大家好&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;我是顽石老师&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line"><span class="built_in">connect</span>(menu,&amp;QMenu::triggered,<span class="keyword">this</span>,[=](QAction*act)</span><br><span class="line">&#123;</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(act-&gt;<span class="built_in">text</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/btn_0.gif"></p>
<h4 id="2，工具按钮-ToolButton"><a href="#2，工具按钮-ToolButton" class="headerlink" title="2，工具按钮(ToolButton)"></a>2，工具按钮(ToolButton)</h4><p>QToolButton是一个特殊的Button, 提供快速访问特定的命令或选项。与普通命令按钮不同, QToolButton通常不显示文本标签, 而是显示图标。一般用在toolBar上</p>
<h5 id="信号与槽-2"><a href="#信号与槽-2" class="headerlink" title="信号与槽"></a>信号与槽</h5><p><strong>signals</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<p><code>void triggered(QAction *action) 按钮绑定的菜单动作被触发 </code> </p>
<p><strong>slots</strong></p>
<p><code>void setDefaultAction(QAction *action)	如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</code></p>
<p><code>void setToolButtonStyle(Qt::ToolButtonStyle style) 设置工具按钮是否仅显示图标、仅显示文本，还是图标旁边/下面的文本。 </code></p>
<p><code>void showMenu()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QToolButton*toolbtn = <span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">toolbtn-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">toolbtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//设置图标</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setIcon</span>(<span class="built_in">style</span>()-&gt;<span class="built_in">standardIcon</span></span><br><span class="line">                 (QStyle::StandardPixmap::SP_FileIcon));</span><br><span class="line"><span class="comment">//设置文字显示位置</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setToolButtonStyle</span></span><br><span class="line">    (Qt::ToolButtonStyle::ToolButtonTextUnderIcon);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/image-20210814134543856.png" alt="image-20210814134543856"></p>
<h5 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >int void setArrowType(Qt::ArrowType type)</span><br /><img src="/assets/image-20210814134847896.png" alt="image-20210814134847896"><span style="font-size:13px">此属性用于保存按钮是否显示箭头而不是普通图标</span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAutoRaise(bool enable)</span><br /><img src="assets/btn_1.gif" style="zoom: 67%;" /><span style="font-size:13px">去掉边框和背景，鼠标在按钮上面时，显示选中效果，按下时有下沉效果</span></td>
</tr>
<tr>
<td align="center">3</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setMenu(QMenu *menu)</span><br /><span style="font-size:13px">设置弹出菜单  </span></td>
</tr>
<tr>
<td align="center">4</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setPopupMode(QToolButton::ToolbuttonPopupMode mode)</span><br /><span style="font-size:13px">描述如何将弹出菜单与工具按钮一起使用，默认设置为DelayedPopup </span></td>
</tr>
</tbody></table>
<h6 id="弹出菜单"><a href="#弹出菜单" class="headerlink" title="弹出菜单"></a>弹出菜单</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMenu*menu = <span class="keyword">new</span> QMenu;</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;C语言&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line">toolbtn-&gt;<span class="built_in">setMenu</span>(menu);</span><br><span class="line"><span class="comment">//设置弹出模式，DelayedPopup延时弹出 MenuButtonPopup在右侧显示一个箭头  InstantPopup立即弹出</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::DelayedPopup);</span><br><span class="line"><span class="comment">//设置按钮菜单之后，右下角有一个小箭头，去掉箭头</span></span><br><span class="line">toolbtn-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QToolButton::menu-indicator &#123;image: none;&#125;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3，单选按钮-RadioButton"><a href="#3，单选按钮-RadioButton" class="headerlink" title="3，单选按钮(RadioButton)"></a>3，单选按钮(RadioButton)</h4><p>QRadioButton部件提供了一个带有文本标签的单选按钮。</p>
<p>QRadioButton是一个可以切换选中（checked）或未选中（unchecked）状态的选项按钮。单选框通常呈现给用户一个“多选一”的选择。也就是说，在一组单选框中，一次只能选中一个单选框。</p>
<h5 id="信号与槽-3"><a href="#信号与槽-3" class="headerlink" title="信号与槽"></a>信号与槽</h5><p><strong>signals</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<p><strong>slots</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<h5 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h5><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setCheckState(Qt::CheckState state)</span><br /><span style="font-size:13px"> 将复选框的复选状态设置为state。 如果不需要三状态支持，还可以使用QAbstractButton::setChecked()，它接受布尔值。   </span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setTristate(bool)</span><br /><span style="font-size:13px">该属性保存复选框是否是三状态复选框，默认为false，即复选框只有两个状态</span></td>
</tr>
</tbody></table>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><ul>
<li>同一组(同一父对象)的单选按钮一次只能选中一个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QRadioButton*radiobtn = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;男&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QRadioButton*radiobtn1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;女&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//设置默认选中</span></span><br><span class="line">radiobtn-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/btn_2.gif"></p>
<ul>
<li>同一组同时选中多个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QGroupBox* exampleGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;esample&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QLabel*label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;你喜欢以下哪些宠物？&quot;</span>);</span><br><span class="line">exampleGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">QRadioButton *dogbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">QRadioButton *catbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">QRadioButton *snakebtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;蛇&quot;</span>);</span><br><span class="line">QRadioButton *pigbtn =  <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line"></span><br><span class="line">dogbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">catbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">snakebtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line">pigbtn-&gt;<span class="built_in">setAutoExclusive</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">QVBoxLayout* layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(dogbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(catbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(snakebtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(pigbtn);</span><br><span class="line"></span><br><span class="line">exampleGroup-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/btn_4.gif"></p>
<ul>
<li>不同组的单选按钮可以同时选中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QGroupBox* sexGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;性别&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QGroupBox* viewpointGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;观点&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">sexGroup-&gt;<span class="built_in">move</span>(<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line">viewpointGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">QRadioButton*radiobtn = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;男&quot;</span>,sexGroup);</span><br><span class="line">QRadioButton*radiobtn1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;女&quot;</span>,sexGroup);</span><br><span class="line"></span><br><span class="line">QRadioButton*radiobtn2 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;好&quot;</span>,viewpointGroup);</span><br><span class="line">QRadioButton*radiobtn3 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;坏&quot;</span>,viewpointGroup);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* sexLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">sexLayout-&gt;<span class="built_in">addWidget</span>(radiobtn);</span><br><span class="line">sexLayout-&gt;<span class="built_in">addWidget</span>(radiobtn1);</span><br><span class="line"></span><br><span class="line">QHBoxLayout* viewpointLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">viewpointLayout-&gt;<span class="built_in">addWidget</span>(radiobtn2);</span><br><span class="line">viewpointLayout-&gt;<span class="built_in">addWidget</span>(radiobtn3);</span><br><span class="line"></span><br><span class="line">sexGroup-&gt;<span class="built_in">setLayout</span>(sexLayout);</span><br><span class="line">viewpointGroup-&gt;<span class="built_in">setLayout</span>(viewpointLayout);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/btn_3.gif"></p>
<h4 id="4，复选框-CheckBox"><a href="#4，复选框-CheckBox" class="headerlink" title="4，复选框(CheckBox)"></a>4，复选框(CheckBox)</h4><p>QCheckBox提供了一个带文本标签的复选框。</p>
<p>QCheckBox（复选框）和QRadioButton（单选框）都是选项按钮。这是因为它们都可以在开（选中）或者关（未选中）之间切换。区别是对用户选择的限制：单选框定义了“多选一”的选择，而复选框提供的是“多选多”的选择。</p>
<p>尽管在技术上可以通过复选框来实现单选框的行为，反之亦然，但还是强烈建议使用众所周知的约定。</p>
<h5 id="信号与槽-4"><a href="#信号与槽-4" class="headerlink" title="信号与槽"></a>信号与槽</h5><p><strong>signals</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类 </code></p>
<p><code>void stateChanged(int state)</code> 当复选框的状态发生变化时，即当用户选中或取消选中它时，就会发出这个信号。  </p>
<p><strong>slots</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<h5 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QGroupBox* exampleGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="keyword">this</span>);</span><br><span class="line">exampleGroup-&gt;<span class="built_in">move</span>(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">QLabel*label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;你喜欢以下哪些宠物？&quot;</span>);</span><br><span class="line">QCheckBox *dogbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;狗&quot;</span>);</span><br><span class="line">QCheckBox *catbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">QCheckBox *snakebtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;蛇&quot;</span>);</span><br><span class="line">QCheckBox *pigbtn =  <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;猪&quot;</span>);</span><br><span class="line"></span><br><span class="line">QVBoxLayout* layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(dogbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(catbtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(snakebtn);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(pigbtn);</span><br><span class="line"></span><br><span class="line">exampleGroup-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/btn_5.gif"></p>
<h4 id="5，行编辑器-LineEdit"><a href="#5，行编辑器-LineEdit" class="headerlink" title="5，行编辑器(LineEdit)"></a>5，行编辑器(LineEdit)</h4><h5 id="信号与槽-5"><a href="#信号与槽-5" class="headerlink" title="信号与槽"></a>信号与槽</h5><p><strong>signals</strong></p>
<p><code>Inherits:QAbstractButton 继承自父类</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span>					<span class="comment">//清除行编辑的内容</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">()</span> <span class="type">const</span>				<span class="comment">//将选中的文本复制到剪贴板(如果有的话)，并且echoMode()是Normal</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span>						<span class="comment">//剪切</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paste</span><span class="params">()</span>					<span class="comment">//粘贴</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">redo</span><span class="params">()</span>						<span class="comment">//撤销</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectAll</span><span class="params">()</span>				<span class="comment">//选中所有</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span>						<span class="comment">//反撤销</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>slots</strong></p>
<p><code>void showMenu()	如果有菜单，弹出菜单，否则啥也不做(这个槽貌似没啥用)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个信号在光标移动时发出。前一个位置由oldPos给出，新位置由newPos给出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cursorPositionChanged</span><span class="params">(<span class="type">int</span> oldPos, <span class="type">int</span> newPos)</span></span></span><br><span class="line"><span class="function"><span class="comment">//编辑完成，按下Return或Enter键或行编辑失去焦点时将发出此信号</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">editingFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//当用户按下一个不被认为是可接受输入的键时，就会发出这个信号。 例如，如果一个按键导致验证器的validate()调用返回Invalid。 另一种情况是试图输入超过行编辑的最大长度的字符。    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputRejected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//编不编辑，当按下Return或Enter键时都发出此信号，失去焦点不会发</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">returnPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//这个信号在选择改变时发出  </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//每当文本发生变化时，就会发出这个信号。与texttedited()不同，调用setText()改变文本，此信号也会发出。  </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">textChanged</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span></span><br><span class="line"><span class="function"><span class="comment">//只要文本被编辑，就会发出这个信号。     </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">textEdited</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h5 id="设置显示模式"><a href="#设置显示模式" class="headerlink" title="设置显示模式"></a>设置显示模式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setEchoMode</span>(QLineEdit::EchoMode::Password);</span><br><span class="line">QLineEdit::Normal				<span class="comment">//显示输入的字符，这是默认值。  </span></span><br><span class="line">QLineEdit::NoEcho				<span class="comment">//不要显示任何东西</span></span><br><span class="line">QLineEdit::Password				<span class="comment">//显示与平台相关的密码掩码字符，而不是实际输入的字符。  </span></span><br><span class="line">QLineEdit::PasswordEchoOnEdit	<span class="comment">//在编辑时显示已输入的字符，完成显示掩码字符</span></span><br><span class="line">    </span><br><span class="line">edit-&gt;<span class="built_in">setClearButtonEnabled</span>(<span class="literal">true</span>);	<span class="comment">//启用清除按钮</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/lineedit_1.gif"></p>
<h5 id="设置输入掩码"><a href="#设置输入掩码" class="headerlink" title="设置输入掩码"></a>设置输入掩码</h5><table>
<thead>
<tr>
<th>掩码字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>ASCII字母字符是必须的，A-Z，a-z</td>
</tr>
<tr>
<td>a</td>
<td>ASCII 字母字符是允许的但不是必须的</td>
</tr>
<tr>
<td>N</td>
<td>ASCII字母字符是必须的，A-Z，a-z， 0-9</td>
</tr>
<tr>
<td>n</td>
<td>ASCII 字母字符是允许的但不是必须的</td>
</tr>
<tr>
<td>X</td>
<td>任何字符都可以，是必须需要的</td>
</tr>
<tr>
<td>x</td>
<td>任何字符都允许的，但不是必须需要的</td>
</tr>
<tr>
<td>9</td>
<td>ASCII 数字是必须要的，0-9</td>
</tr>
<tr>
<td>0</td>
<td>ASCII 数字是允许的，但不是必须要的</td>
</tr>
<tr>
<td>D</td>
<td>ASCII  数字是必须要的，1-9</td>
</tr>
<tr>
<td>d</td>
<td>ASCII 数字是允许的，但不是必须要的</td>
</tr>
<tr>
<td>#</td>
<td>ASCII 数字是或加减符号允许的，但不是必须要的</td>
</tr>
<tr>
<td>H</td>
<td>十六进制数据字符是必须要的，A-F, a-f, 0-9</td>
</tr>
<tr>
<td>h</td>
<td>十六进制数据字符是允许的，但不是必须要的</td>
</tr>
<tr>
<td>B</td>
<td>二进制数据字符是必须要的，0-1</td>
</tr>
<tr>
<td>b</td>
<td>二进制数据字符是允许的，但不是必须要的</td>
</tr>
<tr>
<td>&gt;</td>
<td>所有的字符字母都都大写的</td>
</tr>
<tr>
<td>&lt;</td>
<td>所有的字符字幕都是小写的</td>
</tr>
<tr>
<td>!</td>
<td>关闭大小写</td>
</tr>
<tr>
<td>;c</td>
<td>终止输入掩码并将空白字符设置为c</td>
</tr>
<tr>
<td>\</td>
<td>使用 <code>\</code> 去转义上面的字符，如果再需要显示上述字符的时候</td>
</tr>
</tbody></table>
<ul>
<li>输入日期</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setText</span>(QDate::<span class="built_in">currentDate</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">edit-&gt;<span class="built_in">setInputMask</span>(<span class="string">&quot;9999-99-99&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>输入秘钥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setInputMask</span>(<span class="string">&quot;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="设置验证器"><a href="#设置验证器" class="headerlink" title="设置验证器"></a>设置验证器</h5><ul>
<li>只能输入整数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">-90</span>,<span class="number">90</span>,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>只能输入浮点数，但是浮点数验证器不能限制范围，可以随便输入</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">edit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QDoubleValidator</span>(<span class="number">-90.0</span>,<span class="number">90.0</span>,<span class="number">3</span>,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="添加动作"><a href="#添加动作" class="headerlink" title="添加动作"></a>添加动作</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QLineEdit::addAction</span><span class="params">(QAction *action, QLineEdit::ActionPosition position)</span></span></span><br><span class="line"><span class="function">QAction *<span class="title">QLineEdit::addAction</span><span class="params">(<span class="type">const</span> QIcon &amp;icon, QLineEdit::ActionPosition position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLineEdit *edit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">edit-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;://images/user.png&quot;</span>),QLineEdit::ActionPosition::LeadingPosition);</span><br><span class="line">QAction *delAct = edit-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;://images/delete.png&quot;</span>),QLineEdit::ActionPosition::TrailingPosition);</span><br><span class="line"><span class="built_in">connect</span>(delAct,&amp;QAction::triggered,[]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;delAct&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/image-20210824162943231.png" alt="image-20210824162943231"></p>
<h4 id="6，标签-Label"><a href="#6，标签-Label" class="headerlink" title="6，标签(Label)"></a>6，标签(Label)</h4><p>QLabel小部件提供文本或图像显示</p>
<h6 id="信号与槽-6"><a href="#信号与槽-6" class="headerlink" title="信号与槽"></a>信号与槽</h6><p><strong>signals</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户点击链接时会发出此信号。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkActivated</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当用户将鼠标悬停在链接上时会发出此信号。    </span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkHovered</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>slots</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMovie</span><span class="params">(QMovie *movie)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">double</span> num)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPicture</span><span class="params">(<span class="type">const</span> QPicture &amp;picture)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h6 id="公有函数-2"><a href="#公有函数-2" class="headerlink" title="公有函数"></a>公有函数</h6><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAlignment(<em>Qt::Alignment</em>)</span><br /><span style="font-size:13px">设置对齐方式   </span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setBuddy(QWidget *<em>buddy</em>)</span><br /><span style="font-size:13px">将此标签的好友设置为buddy。当用户按下此标签指示的快捷键时，键盘焦点将转移到标签的好友小部件。伙伴机制仅适用于包含文本的 QLabel，其中一个字符以与号“&amp;”为前缀。  </span></td>
</tr>
<tr>
<td align="center">3</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setIndent(<em>int</em>)</span><br /><span style="font-size:13px">设置label的文本缩进，以像素为单位   </span></td>
</tr>
<tr>
<td align="center">4</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setMargin(<em>int</em>)</span><br /><span style="font-size:13px">设置边距     </span></td>
</tr>
<tr>
<td align="center">5</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setOpenExtrenalLinks(<em>bool open</em>)</span><br /><span style="font-size:13px">设置是否自动打开超链接   </span></td>
</tr>
<tr>
<td align="center">6</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setScaledContents(<em>bool</em>)</span><br /><span style="font-size:13px">设置内容缩放，确定标签是否将其内容缩放以填充所有可用空间。    </span></td>
</tr>
<tr>
<td align="center">7</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setSelection(<em>int start,int len</em>)</span><br /><span style="font-size:13px">设置对齐方式   </span></td>
</tr>
<tr>
<td align="center">8</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setTextFormat(<em>Qt::TextFormat</em>)</span><br /><span style="font-size:13px">设置标签文本格式   </span></td>
</tr>
<tr>
<td align="center">9</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setTextInteractionFlags(<em>Qt::TextInteractionFlags flag</em>)</span><br /><span style="font-size:13px">设置对齐方式   </span></td>
</tr>
<tr>
<td align="center">10</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setWordWrap(<em>bool on</em>)</span><br /><img src="/assets/image-20210823163631731.png" alt="image-20210823163631731"><span style="font-size:13px">设置是否在需要时自动换行   </span></td>
</tr>
</tbody></table>
<h6 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h6><ul>
<li>显示文本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;我是萌萌哒的小可爱&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignmentFlag::AlignCenter);</span><br><span class="line">label-&gt;<span class="built_in">setFixedWidth</span>(<span class="number">100</span>);  <span class="comment">//设置固定的宽度</span></span><br><span class="line">label-&gt;<span class="built_in">setWordWrap</span>(<span class="literal">true</span>);   <span class="comment">//当文本超过固定的宽度之后，自动换行</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>设置超链接：QLabel支持html文本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;a href=\&quot;www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">connect</span>(label,&amp;QLabel::linkHovered,<span class="keyword">this</span>,[=](<span class="type">const</span> QString&amp; link)&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;linkHovered&quot;</span>&lt;&lt;link;&#125;);    </span><br><span class="line"><span class="built_in">connect</span>(label,&amp;QLabel::linkActivated,<span class="keyword">this</span>,[=](<span class="type">const</span> QString&amp; link)&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;linkActivated&quot;</span>&lt;&lt;link;&#125;);</span><br><span class="line"><span class="comment">//设置自动打开超链接，而不是发出信号自己处理，这个设置之后会自动在浏览器打开连接</span></span><br><span class="line">label-&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>设置伙伴</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel* nameLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;&amp;Name&quot;</span>,<span class="keyword">this</span>);   </span><br><span class="line">QLineEdit * nameEdit = <span class="keyword">new</span> QLineEdit;           </span><br><span class="line">nameLabel-&gt;<span class="built_in">setBuddy</span>(nameEdit);                  </span><br><span class="line">                                                </span><br><span class="line">QLabel* phoneLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;电话(&amp;P)&quot;</span>,<span class="keyword">this</span>); </span><br><span class="line">QLineEdit* phoneEdit = <span class="keyword">new</span> QLineEdit;           </span><br><span class="line">phoneLabel-&gt;<span class="built_in">setBuddy</span>(phoneEdit);                </span><br><span class="line">                                                </span><br><span class="line">QGridLayout* layout = <span class="keyword">new</span> QGridLayout;          </span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(nameLabel,<span class="number">0</span>,<span class="number">0</span>);               </span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(nameEdit,<span class="number">0</span>,<span class="number">1</span>);                </span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(phoneLabel,<span class="number">1</span>,<span class="number">0</span>);              </span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(phoneEdit,<span class="number">1</span>,<span class="number">1</span>);               </span><br><span class="line">                                                </span><br><span class="line"><span class="built_in">setLayout</span>(layout);                              </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="F:/C++/QT%20%E9%A1%BD%E7%9F%B3/06%20%E6%9C%80%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/assets/label_1.gif"></p>
<ul>
<li>显示图片</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;://images/label_img.jpg&quot;</span>));</span><br><span class="line"><span class="comment">//如上所示，显示的图片是固定的大小，如何让图片按我们想要的大小显示呢？</span></span><br><span class="line"><span class="comment">//1，设置Label的大小，如果有布局，会随着布局动态变化</span></span><br><span class="line">label-&gt;<span class="built_in">setFixedSize</span>(<span class="number">340</span>,<span class="number">180</span>);</span><br><span class="line"><span class="comment">//2，设置内容缩放</span></span><br><span class="line">label-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>显示Gif动图</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">QMovie *movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;F:/MyCode/QtCode/QtCourse/DisplayWidgets/images/label_gif.gif&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setMovie</span>(movie);</span><br><span class="line">movie-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7，分组框-GroupBox"><a href="#7，分组框-GroupBox" class="headerlink" title="7，分组框(GroupBox)"></a>7，分组框(GroupBox)</h4><h6 id="信号与槽-7"><a href="#信号与槽-7" class="headerlink" title="信号与槽"></a>信号与槽</h6><p><strong>signals</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">(<span class="type">bool</span> checked = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toggled</span><span class="params">(<span class="type">bool</span> on)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>slots</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setChecked</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h6 id="公有函数-3"><a href="#公有函数-3" class="headerlink" title="公有函数"></a>公有函数</h6><table>
<thead>
<tr>
<th align="center">序号</th>
<th>函数&amp;描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setAlignment(<em>Qt::Alignment</em>)</span><br /><span style="font-size:13px">设置对齐方式   </span></td>
</tr>
<tr>
<td align="center">2</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setCheckAble(bool <em>checkable</em>)</span><br /><span style="font-size:13px">该分组框是否可以被选择  </span></td>
</tr>
<tr>
<td align="center">3</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setflat(bool <em>flat</em>)</span><br /><span style="font-size:13px">分组框通常由顶部有标题的包围框组成。 如果启用此属性，则大多数样式只绘制框架的顶部部分; 否则，将绘制整个框架。     </span></td>
</tr>
<tr>
<td align="center">4</td>
<td><span style = "font-size:18px;color:rgb(0,102,0)" >void setTitle(const QString&amp; <em>title</em>)</span><br /><span style="font-size:13px">设置分组框的标题   </span></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QGroupBox* groupBox = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="keyword">this</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">resize</span>(<span class="number">320</span>,<span class="number">320</span>);</span><br><span class="line">groupBox-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;我是分组框&quot;</span>);</span><br><span class="line"><span class="comment">//groupBox-&gt;setAlignment(Qt::AlignCenter);</span></span><br><span class="line"><span class="comment">//groupBox-&gt;setFlat(true);</span></span><br><span class="line"></span><br><span class="line">groupBox-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(groupBox,&amp;QGroupBox::clicked,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;clicked&quot;</span>;&#125;);</span><br><span class="line"><span class="built_in">connect</span>(groupBox,&amp;QGroupBox::toggled,<span class="keyword">this</span>,[]()&#123;<span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;toggled&quot;</span>;&#125;);</span><br><span class="line"></span><br><span class="line">QList&lt;QCheckBox*&gt; checkBoxs;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    checkBoxs.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="built_in">QString</span>(<span class="string">&quot;checkBox%1&quot;</span>).<span class="built_in">arg</span>(i),groupBox));</span><br><span class="line">    checkBoxs[i]-&gt;<span class="built_in">move</span>(<span class="number">10</span>,i*<span class="number">40</span>+<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">groupBox-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Designer设计师的使用"><a href="#Designer设计师的使用" class="headerlink" title="Designer设计师的使用"></a>Designer设计师的使用</h1><p>用Qt给我们提供的<code>Qt Designer</code>（界面设计师），拖拖拽拽就可以直观的创建出程序大体的界面。把这个用好了很重要，Qt实现功能可以靠AI完成的。</p>
<h3 id="1-1-创建带UI文件的项目"><a href="#1-1-创建带UI文件的项目" class="headerlink" title="1.1 创建带UI文件的项目"></a>1.1 创建带UI文件的项目</h3><ul>
<li>双击.ui文件打开设计师界面</li>
<li>设计师面板介绍<ul>
<li>组件面板：窗口左侧是界面设计组件面板，分为多个组，如Layouts、Buttons、Display Widgets等，界面设计的常见组件都可以在组件面板里找到。</li>
<li>中间主要区域是待设计的窗体。如果要将某个组件放置到窗体上时，从组件面板上拖放一个组件到窗体上即可。例如，先放一个 Label 和一个 Push Button 到窗体上。</li>
<li>Signals 和 Slots 编辑器与 Action 编辑器是位于待设计窗体下方的两个编辑器。Signals 和Slots 编辑器用于可视化地进行信号与槽的关联，Action 编辑器用于可视化设计 Action。</li>
<li>布局和界面设计工具栏：窗口上方的一个工具栏，工具栏上的按钮主要实现布局和界面设计。</li>
<li>对象浏览器（Object Inspector）：窗口右上方是 Object Inspector，用树状视图显示窗体上各组件之间的布局包含关系，视图有两列，显示每个组件的对象名称（ObjectName）和类名称。</li>
<li>属性编辑器（Property Editor）：窗口右下方是属性编辑器，是界面设计时最常用到的编辑器。属性编辑器显示某个选中的组件或窗体的各种属性及其取值，可以在属性编辑器里修改这些属性的值。</li>
</ul>
</li>
</ul>
<h3 id="1-2-UI设计器使用"><a href="#1-2-UI设计器使用" class="headerlink" title="1.2 UI设计器使用"></a>1.2 UI设计器使用</h3><h4 id="1，转到槽"><a href="#1，转到槽" class="headerlink" title="1，转到槽"></a>1，转到槽</h4><ul>
<li><p>递归搜索给定对象的所有子对象，并将来自它们的匹配信号连接到遵循以下形式的对象槽：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">void on_&lt;<span class="selector-tag">object</span> name&gt;_&lt;signal name&gt;(&lt;signal parameters&gt;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们假设我们的对象有一个 QPushButton 类型的子对象，对象名为 button1。 捕捉按钮的 clicked() 信号的插槽是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">void on_button1_clicked();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>如果对象本身具有正确设置的对象名称，则其自身的信号也连接到其各自的插槽。</p>
</li>
</ul>
<h4 id="2，自定义控件-提升为"><a href="#2，自定义控件-提升为" class="headerlink" title="2，自定义控件(提升为)"></a>2，自定义控件(提升为)</h4><h3 id="1-3-UI设计师原理"><a href="#1-3-UI设计师原理" class="headerlink" title="1.3 UI设计师原理"></a>1.3 UI设计师原理</h3><p>就算我们不编写一行程序语句，都能实现界面功能，Qt 是怎么实现的呢？</p>
<p>为了搞清楚Widget类的定义，以及界面功能的实现原理，先将项目进行编译。编译后在项目目录下会自动生成一个文件 ui_widget.h，这样对于一个窗口，就有 4 个文件了，各文件的功能说明见下表。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>widget.h</td>
<td>定义Widget类的头文件</td>
</tr>
<tr>
<td>widget.cpp</td>
<td>Widget 类的功能实现源文件</td>
</tr>
<tr>
<td>widget.ui</td>
<td>界面文件，由UI设计器自动生成，存储了窗体上各个组件的属性设置和布局</td>
</tr>
<tr>
<td>ui_widget.h</td>
<td>编译后，根据窗体上的组件及其属性、信号与槽的关联等自动生成的一个类的定义文件，类的名称是Ui_Widget</td>
</tr>
</tbody></table>
<p>下面分别分析各个文件的内容及其功能，以及它们是如何联系在一起工作，实现界面的创建与显示的。</p>
<h4 id="Widget-h"><a href="#Widget-h" class="headerlink" title="Widget.h"></a>Widget.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>namespace申明</strong></p>
<p>代码中有如下的一个 namespace 声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是声明了一个名为 Ui 的命名空间（namespace），包含一个类 Widget。但是这个类 Widget 并不是本文件里定义的类 Widget，而是 ui_widget.h 文件里定义的类，用于描述界面组件的。这个声明相当于一个外部类型声明（具体要看完 ui_widget.h 文件内的解释之后才能搞明白）。</p>
</li>
<li><p><strong>private指针定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Ui::Widget *ui;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个指针是用前面声明的 namespace Ui 里的 Widget 类定义的，所以指针 ui 是指向可视化设计的界面，后面会看到要访问界面上的组件，都需要通过这个指针 ui。</p>
</li>
</ul>
<h4 id="Widget-cpp"><a href="#Widget-cpp" class="headerlink" title="Widget.cpp"></a>Widget.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意到，在这个文件的头文件包含部分自动加入了如下一行内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个就是 Qt 编译生成的与 UI 文件 widget.ui 对应的类定义文件。</p>
</li>
<li><p>在构造函数初始化参数列表里有这么一段代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其意义是：执行父类 QWidget 的构造函数，创建一个 Ui::Widget 类的对象 ui。这个 ui 就是 Widget 的 private 部分定义的指针变量 ui。</p>
</li>
<li><p>构造函数里只有一行代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它是执行了 Ui::Widget 类的 setupUi() 函数，这个函数实现窗口的生成与各种属性的设置、信号与槽的关联（后面会具体介绍）。</p>
</li>
<li><p>析构函数只是简单地delete用 new 创建的指针 ui。</p>
</li>
<li><p>所以，在 ui_widget.h 文件里有一个 namespace 名称为 Ui，里面有一个类 Widget 是用于描述可视化设计的窗体，且与 widget.h 里定义的类同名。在 Widget 类里访问 Ui::Widget 类的成员变量或函数需要通过 Widget 类里的 ui 指针，如同构造函数里执行 ui-&gt;setupUi( this) 函数那样。</p>
</li>
</ul>
<h4 id="Widget-ui"><a href="#Widget-ui" class="headerlink" title="Widget.ui"></a>Widget.ui</h4><p>widget.ui 是界面定义文件，是一个 XML 文件，定义了窗口上的所有组件的属性设置、布局，及其信号与槽函数的关联等。用UI设计器可视化设计的界面都由 Qt 自动解析，并以 XML 文件的形式保存下来。在设计界面时，只需在 UI 设计器里进行可视化设计即可，而不用管 widget.ui 文件是怎么生成的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;ui version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"> &lt;<span class="keyword">class</span>&gt;Widget&lt;/<span class="keyword">class</span>&gt;</span><br><span class="line"> &lt;widget <span class="keyword">class</span>=<span class="string">&quot;QWidget&quot;</span> name=<span class="string">&quot;Widget&quot;</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;geometry&quot;</span>&gt;</span><br><span class="line">   &lt;rect&gt;</span><br><span class="line">    &lt;x&gt;<span class="number">0</span>&lt;/x&gt;</span><br><span class="line">    &lt;y&gt;<span class="number">0</span>&lt;/y&gt;</span><br><span class="line">    &lt;width&gt;<span class="number">800</span>&lt;/width&gt;</span><br><span class="line">    &lt;height&gt;<span class="number">600</span>&lt;/height&gt;</span><br><span class="line">   &lt;/rect&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;windowTitle&quot;</span>&gt;</span><br><span class="line">   &lt;string&gt;Widget&lt;/string&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> &lt;/widget&gt;</span><br><span class="line"> &lt;resources/&gt;</span><br><span class="line"> &lt;connections/&gt;</span><br><span class="line">&lt;/ui&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ui-Widget-h"><a href="#ui-Widget-h" class="headerlink" title="ui_Widget.h"></a>ui_Widget.h</h4><p>ui_widget.h 是在对 widget.ui 文件编译后生成的一个文件，ui_widget.h 会出现在编译后的目录下，或与 widget.ui 同目录（与项目的 shadow build 编译设置有关）。</p>
<p>文件 ui_widget.h 并不会出现在 Qt Creator 的项目文件目录树里，当然，可以手工将 ui_widget.h 添加到项目中。方法是在项目文件目录树上，右击项目名称节点，在调出的快捷菜单中选择“Add Existing Files…”，找到并添加 ui_widget.h 文件即可。</p>
<p>注意，ui_widget.h 是对 widget.ui 文件编译后自动生成的，widget.ui 又是通过 UI 设计器可视化设计生成的。所以，对 ui_widget.h 手工进行修改没有什么意义，所有涉及界面的修改都应该直接在UI 设计器里进行。所以，ui_widget.h 也没有必要添加到项目里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UI_WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UI_WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ui_Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupUi</span><span class="params">(QWidget *Widget)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Widget-&gt;<span class="built_in">objectName</span>().<span class="built_in">isEmpty</span>())</span><br><span class="line">            Widget-&gt;<span class="built_in">setObjectName</span>(QString::<span class="built_in">fromUtf8</span>(<span class="string">&quot;Widget&quot;</span>));</span><br><span class="line">        Widget-&gt;<span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">retranslateUi</span>(Widget);</span><br><span class="line"></span><br><span class="line">        QMetaObject::<span class="built_in">connectSlotsByName</span>(Widget);</span><br><span class="line">    &#125; <span class="comment">// setupUi</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">retranslateUi</span><span class="params">(QWidget *Widget)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Widget-&gt;<span class="built_in">setWindowTitle</span>(QCoreApplication::<span class="built_in">translate</span>(<span class="string">&quot;Widget&quot;</span>, <span class="string">&quot;Widget&quot;</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125; <span class="comment">// retranslateUi</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> Ui_Widget &#123;&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Ui</span></span><br><span class="line"></span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UI_WIDGET_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看 ui_widget.h 文件的内容，发现它主要做了以下的一些工作：</p>
<ul>
<li><p>1，定义了一个类 Ui_Widget，用于封装可视化设计的界面。</p>
</li>
<li><p>2，自动生成了界面各个组件的类成员变量定义。在 public 部分为界面上每个组件定义了一个指针变量，变量的名称就是设置的 objectName。比如，在窗体上放置了一个 QLabel 和一个 QPushButton 并命名后，自动生成的定义是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel *LabDemo;</span><br><span class="line">QPushButton *btnClose;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义了 setupUi() 函数，这个函数用于创建各个界面组件，并设置其位置、大小、文字内容、字体等属性，设置信号与槽的关联。setupUi() 函数体的第一部分是根据可视化设计的界面内容，用 C++ 代码创建界面上各组件，并设置其属性。</p>
<p>接下来，setupUi() 调用了函数 retranslateUi(Widget)，用来设置界面各组件的文字内容属性，如标签的文字、按键的文字、窗体的标题等。将界面上的文字设置的内容独立出来作为一个函数 retranslateUi()，在设计多语言界面时会用到这个函数。</p>
<p>setupUi() 函数的第三部分是设置信号与槽的关联：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMetaObject::<span class="built_in">connectSlotsByName</span>(Widget);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该代码是设置槽函数的关联方式，用于将 UI 设计器自动生成的组件信号的槽函数与组件信号相关联。</p>
<p>所以，在Widget 的构造函数里调用 ui-&gt;setupUI(this)，就实现了窗体上组件的创建、属性设置、信号与槽的关联。</p>
</li>
<li><p>定义 namespace Ui，并定义一个从Ui_Widget 继承的类Widget。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> Ui_Widget &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>提示：ui_widget.h 文件里实现界面功能的类是 Ui_Widget。再定义一个类 Widget 从 Ui_Widget 继承而来，并定义在 namespace Ui 里，这样 Ui:: Widget 与 widget.h 里的类 Widget 同名，但是用 namespace 区分开来。所以，界面的 Ui:: Widget 类与文件 widget.h 里定义的 Widget 类实际上是两个类，但是 Qt 的处理让用户感觉不到 Ui:: Widget 类的存在，只需要知道在 Widget 类里用 ui 指针可以访问可视化设计的界面组件就可以了</p>
<h3 id="1-4-用Ui文件生成头文件"><a href="#1-4-用Ui文件生成头文件" class="headerlink" title="1.4 用Ui文件生成头文件"></a>1.4 用Ui文件生成头文件</h3><ul>
<li><p>1，打开终端，并切换工作目录到.ui文件所在的目录。</p>
</li>
<li><p>2，输入如下命令，可以看到ui_widget.h文件就生成出来了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">uic widget<span class="selector-class">.ui</span> -o ui_widget<span class="selector-class">.h</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-使用ui-widget-h"><a href="#1-5-使用ui-widget-h" class="headerlink" title="1.5 使用ui_widget.h"></a>1.5 使用ui_widget.h</h3><p>一句话，要让ui designer设计出来的界面显示出来，只要能设法调用Ui_widget类的setupUi函数就行了。</p>
<p><strong>三步即可完成</strong></p>
<ul>
<li><p>1，前置声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">namespace</span> Ui </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>2，类中定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget* ui;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>3，申请内存，设置ui</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    ,<span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)	<span class="comment">//给ui指针分配内存</span></span><br><span class="line">&#123;</span><br><span class="line">        ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);	<span class="comment">//给当前窗口this，设置ui界面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>OBS使用</title>
    <url>/2024/06/15/OBS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OBS介绍"><a href="#OBS介绍" class="headerlink" title="OBS介绍"></a>OBS介绍</h1><p>简单来说就是电脑用来录视频和直播推流的。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://soft.pot-player.cn/obslive/index.html?source=baidu&unitid=9997128588&unit=obs&e_creative=96329725458&bd_vid=5960687864941317209">OBS Live直播录屏软件 | OBS Live (pot-player.cn)</a></p>
<h3 id="自动配置向导"><a href="#自动配置向导" class="headerlink" title="自动配置向导"></a>自动配置向导</h3><p>首次启动OBS Studio时，会提示运行如下图所示的自动配置向导</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/86aa4322aebf2964797ca2a8297a537d.png"></p>
<p>也可以手动设置</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d61d2595f576844f4078db8a92aa2d3d.png"></p>
<p>该向导将自动测试你的系统，并尝试进行合适的设置，这包括直播或录屏，分辨率，<a href="https://so.csdn.net/so/search?q=%E6%AF%94%E7%89%B9%E7%8E%87&spm=1001.2101.3001.7020">比特率</a>，编码器，流提供程序等。你也可以在以后手动修改设置.</p>
<p>第一个设置【基本（画布）分辨率 】的初始值是【使用当前】，一般是你屏幕的当前分辨率。如果这里设定的分辨率小于屏幕分辨率，比如你的屏幕分辨率为1920 * 1080，这里设定的分辨率为1280 * 720，那么录屏的时候会通过隐藏屏幕的多余部分而以1280 * 720分辨率进行录制。对于此选项，强烈建议选择【使用当前】选项。</p>
<p>第二个设置【FPS每秒帧数】的初始值是【60或30，但尽可能选择60】，建议不影响性能的情况下直接选择【使用当前】</p>
<h2 id="视频设置"><a href="#视频设置" class="headerlink" title="视频设置"></a>视频设置</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1bcbfc18ee573269eef34af8a0906a95.png"></p>
<p>以前我用1650都可以用的。录屏这样设置就可以。</p>
<h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><p>首先需要设置场景和源，你可以从OBS Studio底部区域的两个面板添加场景和源。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/120b90089d32ac8b7f37036877ed128c.png"></p>
<p>简单来说，电脑屏幕从上往下看，场景在上面的先播放，场景可以添加很多东西，比如图片、摄像头、截图、字幕等等。比如：</p>
<ul>
<li>显示器捕获:录制整个显示器范围的屏幕</li>
<li>游戏捕获:录制游戏</li>
<li>窗口捕获录制指定程序窗口的视频</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01765caa69d279ca6444e6e91dbe42f1.png"></p>
<p>右边是声音设置，可以设置音频播放源和麦克风输入</p>
<p>还有其他的，只要认识字就会用的。</p>
<p>还可以设置快捷键进行录屏和停止录屏。</p>
<p>记得设置好保存的文件路径，别忘了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9889a4425874aebd2269936eebeca5a8.png"></p>
<h2 id="直播推流"><a href="#直播推流" class="headerlink" title="直播推流"></a>直播推流</h2><p><strong>设置推流地址</strong></p>
<p>其中服务可以选择你要直播的软件的名字</p>
<p>服务器和推流码在你直播的软件的直播设置里面，对着输入就行。</p>
<p><img src="http://www.obsproject.com.cn/upfile/2023/02/1676292625584.png"></p>
<h2 id="直播画面设置（很重要）"><a href="#直播画面设置（很重要）" class="headerlink" title="直播画面设置（很重要）"></a>直播画面设置（很重要）</h2><p>视频比特率： 对于1080p的直播或录制，一个常见的起点是3000kbps到6000kbps。你可以根据具体情况进行微调。如果你有更大的带宽，你可以选择更高的比特率以提高视频质量。</p>
<p>最大比特率： 设置一个适当的最大比特率，以确保在网络条件变差时，不会导致过多的帧丢失。通常可以将最大比特率设置为比目标比特率稍高一些，例如目标比特率的1.2到1.5倍。</p>
<p>分辨率： 对于1080p，设置分辨率为1920x1080。</p>
<p>帧率： 常见的帧率是30fps，但如果你的内容不是非常动态，也可以考虑使用更低的帧率，比如24fps，以降低内存占用。</p>
<p>软件编码： 如果你的计算机性能足够，可以使用软件编码器（如x264），这样可以更好地控制视频质量。如果性能受限，可以考虑硬件编码器（如NVENC或AMD VCE）。</p>
<p>X264就够了，Nvenc可能会导致打游戏将帧率。</p>
<p><img src="http://www.obsproject.com.cn/upfile/2023/02/1676292679541.png"></p>
<p>推荐一个可以直播打csgo的设置：我用的3060ti G6X</p>
<p>视频比特率：4000kbps</p>
<p>最大比特率：5000kbps</p>
<p>分辨率：1920x1080</p>
<p>帧率：60fps</p>
<p>编码器：x264（软件编码）</p>
<p>比特率推荐：打FPS游戏需要更高的比特率和帧率，也就是要好一点的电脑配置，起码我的3060ti会不卡。</p>
<p><img src="https://picture.gptkong.com/20240623/1816e15ba726604678abd89555c74827ba.png"></p>
]]></content>
      <categories>
        <category>视频，OBS</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>OBS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSGO技巧</title>
    <url>/2023/11/24/cs1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="csgo技巧"><a href="#csgo技巧" class="headerlink" title="csgo技巧"></a>csgo技巧</h1><p>csgo上分建议：要么组队玩，要么玩悠闲，要么不要玩cs，对于普通人来说纯纯坐牢，因为CSGO对电脑配置、网络配置、队友技术、外挂管制、臭鱼烂虾组队要求很高，一个不注意，玩这个游戏你就很烦。</p>
<h2 id="1-枪法"><a href="#1-枪法" class="headerlink" title="1.枪法"></a>1.枪法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设备：cpu&gt;显示器=显卡&gt;鼠标&gt;鼠标垫&gt;键盘</span><br><span class="line">帧数：200+-  cpu打csgo到200hz就够了</span><br><span class="line">显示器：165hz</span><br><span class="line">鼠标重量：66克  最好是蓝牙的轻质量鼠标</span><br><span class="line">灵敏度：800 dpi * 1倍=800 edpi 取消鼠标加速（edpi太高，手指和手腕玩久了痛，我改了低一点的edpi，适应了一个月，刚开始技术下滑，也可能是当时显示器60Hz太low了，还有更新英伟达驱动导致CPU和gpu拉满的bug，现在舒服的狠捏，还换了新显示器，驱动bug也弄掉了更舒服。手腕不痛，预瞄也轻松，以前edpi高，手指要很用力控制准心才能准确定位）主要还是用低灵敏度手腕不会疼。</span><br><span class="line">显卡驱动：显卡不好就别随意更新，一堆bug会导致cpu或者gpu拉满。</span><br><span class="line">键盘：NiZ plum 静电容键盘（无要求）</span><br><span class="line">准心：十字架，绿色可轻可重，随意</span><br><span class="line">预瞄：靠手速和手感</span><br><span class="line">急停：只按一个键，禁止w+a/d，不方便急停</span><br><span class="line">枪法：先瞄准，再急停，不瞄到他你就不要松开a或者d就是了。   有一种练习是站着不动、靠反应来爆头、 打多个击杀（练习定位）</span><br></pre></td></tr></table></figure>

<h2 id="2-游戏理解："><a href="#2-游戏理解：" class="headerlink" title="2.游戏理解："></a>2.游戏理解：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csgo是一个以枪法、道具为辅，帮队友击杀为主的团队游戏</span><br><span class="line">拿信息、控好枪线、站位、身位、枪法、道具、运气</span><br><span class="line">优先培养个人能力：</span><br><span class="line">	枪法：地图熟练程度+预瞄+急停+控制身位+定位击杀</span><br><span class="line">	站位：找掩体（不能站在掩体近点，除非一打多没办法），先预瞄peek，再拉，</span><br><span class="line">	道具：进攻时用来减少对面打你的枪线，防守时可以用来阻碍或者增加对面、拉出来时即将面对的枪线，主要的道具会丢就行，大部分看情况给队友道具，尤其是闪。</span><br><span class="line">	枪线：有意识的去思考并熟练掌握枪线</span><br><span class="line">其次培养团队能力：</span><br><span class="line">	拿信息：前期做默认控图拿信息</span><br><span class="line">	辅助：看队友位置的情况，去其他地方帮队友补充枪线，控制好地图或者帮队友丢一个好闪去拿击杀。或者丢一个没人架的点的火和烟防止别人拉来干队友</span><br><span class="line">	沟通：在预瞄+急停够熟练的时候，就开始练习多看小地图，和队友沟通，构造多个优势站位，至少能保证自己出去不会被好几个人打死（防守的时候，你和队友是站互补站位，你打死一个，另一个人虽然可能不是直接架你的，但是他站在能架很多人的地方，能把你补掉）</span><br></pre></td></tr></table></figure>

<h2 id="3-看demo（视频回放）"><a href="#3-看demo（视频回放）" class="headerlink" title="3.看demo（视频回放）"></a>3.看demo（视频回放）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地图控制权(重要）：</span><br><span class="line">T：先做好默认拿信息，拿信息的人身为控制好，不能被人秒了，不然不如不拿信息，一步一步拿下地图重要位置的控制权，能杀就杀，至少双人成行。</span><br><span class="line"></span><br><span class="line">CT：做默认，看中路，拿信息，第一时间知道别人要打哪，叫队友给道具等队友回防，切忌一个人上，不如等队友一起。</span><br><span class="line"></span><br><span class="line">残局等对面给机会，漏假脚步让别抓你，或者给个假打烟，再根据站位控制，创造多个1v1的机会</span><br><span class="line"></span><br><span class="line">自己和队友位置：两个人一起，可以爆， 反清闪， 前压火， 后面的补枪，</span><br><span class="line"></span><br><span class="line">开局丢火是必要的，防rush，被rush了就最好先保命再等队友交道具再打</span><br><span class="line"></span><br><span class="line">为啥被人薄纱：预瞄不好，没有丢前压火，反清闪。防rush用烟，火，闪，或者是电脑cpu不行，显示器刷新率低，以及网络波动。</span><br><span class="line"></span><br><span class="line">可以开枪掩盖跳下来的脚步</span><br><span class="line"></span><br><span class="line">走暗处，不要走有太阳的地方，会漏影子的</span><br><span class="line"></span><br><span class="line">拿烟灭火不要从火中间灭，要从火的边缘灭，这样不会挡住出去的视野。</span><br><span class="line"></span><br><span class="line">残局为啥输：</span><br><span class="line">1.被人看见好几个队友后立马转点，别人看见后会重点回防的，可以转点冲人少的包点，还能骗对面道具</span><br><span class="line"></span><br><span class="line">2.和队友架点不要重复，对面出来了，另一个人是有时间去帮忙补枪的   </span><br><span class="line"></span><br><span class="line">3.残局走路一定要预瞄好而且不能漏脚步，不然你刚走别人就偷屁股了，直接干啦干死你。</span><br><span class="line">4.残局要么不漏脚步，要么给假的脚步然后回头干他。</span><br><span class="line"></span><br><span class="line">5.回防另一边的时候，可以先漏脚步，然后架一下看看有没有人，防止有人趁你回防干拉你。</span><br><span class="line"></span><br><span class="line">6.对狙：正常是对不过的，特别是枪线1打多的时候，最好是给道具打，或者repeak，也可以转点。如果是站在高点的狙，可以走到近点在peak</span><br><span class="line"></span><br><span class="line">7.残局进行1v1要去枪线多的地方蹲人，因为对面就一个人，实际枪线只有一个，你的枪线越多，越可能抓timing抓到他。</span><br><span class="line"></span><br><span class="line">8.要了解该地图残局的搜点顺序，同时控制好枪线，比如米拉吉刚搜完跳台和警家，就该去跳台打不到的三明治，在三明治搜包点和二楼以及二楼下，搜完再去短箱前方，防止a2楼和跳台能同时打你，各个地图各个包点的残局搜点顺序可以先去了解一下，防止残局不知道怎么办只会保枪。</span><br><span class="line"></span><br><span class="line">搜点：靠左搜右，靠右搜左，丢火清老6位，跟队友上的话，队友是大腿就自己去当炮灰拿信息或者给他丢道具打辅助，两人一起上可以补枪。</span><br><span class="line"></span><br><span class="line">不要静步摸点，要预瞄好，远离近点的障碍物，再repeek或者大拉</span><br><span class="line"></span><br><span class="line">CT补防：队友包点掉一个，最好要及时回防补一个，不能回去就守好另一个包点。</span><br><span class="line"></span><br><span class="line">进攻的时候，要两个人的站位，要可以架到一个地方的敌人或者自己给道具，把一对多的枪线尽量变成一对一。需要多和队友沟通。</span><br><span class="line"></span><br><span class="line">防守的时候也是要两个人的站位，一个人架一个点位，另一个人能帮忙补枪或者给反清道具防止多个人出来干你。</span><br><span class="line">给闪可以掩盖下二楼的声音。</span><br></pre></td></tr></table></figure>

<h2 id="4-道具"><a href="#4-道具" class="headerlink" title="4.道具"></a>4.道具</h2><p>网上学就行了，基础的就ok，自己也有总结，保存好，忘了再看。</p>
<h2 id="5启动器命令"><a href="#5启动器命令" class="headerlink" title="5启动器命令"></a>5启动器命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 启动器：</span><br><span class="line"> -worlwide   -high、</span><br><span class="line"></span><br><span class="line"> 控制台：//cs1的，cs2自查</span><br><span class="line"> net_graphheight 60  默认高度（从屏幕底部向上60个像素）</span><br><span class="line">viewmodel_recoil 0  取消武器射击上抬</span><br><span class="line">cl_bob_lower_amt 5 (5是不晃动，21是晃动）手臂晃动</span><br><span class="line">r_drawtracers_firstperson 1 设置弹道</span><br><span class="line">net_graph 1 开启显示网速fps等 0</span><br><span class="line">net_graphproportionalfont 1     可以改成0.5；，这样就能够将字体大小调小</span><br><span class="line">net_graphpos 0 左下角显示网络延迟</span><br><span class="line"></span><br><span class="line">跑图：</span><br><span class="line"></span><br><span class="line">将跑图的h.cfg文件名改好习惯的名字后放入到SteamLibrary\steamapps\common\Counter-Strike Global Offensive\csgo\game\csgo\cfg中</span><br><span class="line"></span><br><span class="line">在游戏中进入机器人练习房间后，在控制台内输入exec （cfg文件名) 即可 </span><br></pre></td></tr></table></figure>





<h2 id="手感"><a href="#手感" class="headerlink" title="手感"></a>手感</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">眼睛不能盯着准心看，手感会越来越差，应该盯着整个屏幕，准心只是在心中的准心在眼里得到肯定的回复。</span><br><span class="line"></span><br><span class="line">眼睛问题就是要么靠近点显示器，强迫自己融入地图场景，而不是专注准心、要么休息一下晚点再打。</span><br><span class="line">最好吃饱喝足、休息好之后再打csgo，因为csgo想要有手感，电脑配置、网络配置、身体状态都要好。</span><br><span class="line"></span><br><span class="line">手感不好可能是cpu不行，或者显示器刷新率低，又或者灵敏度不适用</span><br><span class="line"></span><br><span class="line">身体状态要好，经常练一下枪找手感。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="手枪局"><a href="#手枪局" class="headerlink" title="手枪局"></a>手枪局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在过转角的地方可以选择跳过去躲爆头线</span><br><span class="line"></span><br><span class="line">对枪可以蹲下来躲爆头线，也可以左右晃动</span><br><span class="line"></span><br><span class="line">开局可以丢诱饵弹假打的</span><br><span class="line"></span><br><span class="line">开局可以起烟+闪+一个P250给队友，“送他们走”</span><br></pre></td></tr></table></figure>

<h2 id="开局"><a href="#开局" class="headerlink" title="开局"></a>开局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输了没钱就必须e，不然下把、下下把还得没钱都得输。</span><br><span class="line"></span><br><span class="line">有钱必须买满道具。</span><br><span class="line"></span><br><span class="line">当CT钱少可以起半甲+烟闪雷、而T只能全甲或者e</span><br><span class="line"></span><br><span class="line">开局不要随意丢道具，队友要就给，不然留着。</span><br><span class="line"></span><br><span class="line">明确打法比如：对面喜欢rush 就给信息火，捏雷或者闪打反清、</span><br><span class="line"></span><br><span class="line">没有rush就要去主动拿信息，叫队友给闪或者烟又或者repeek看一眼，尽量别掉点、</span><br><span class="line"></span><br><span class="line">又或者队友想凶一点，捏闪给队友，帮他拿信息或者杀人、</span><br></pre></td></tr></table></figure>



<h2 id="残局"><a href="#残局" class="headerlink" title="残局"></a>残局</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">残局不要轻易下包，容易形成明对暗被抓timing或者被知道位置打不过</span><br><span class="line"></span><br><span class="line">残局不要漏脚步：回防的时候漏会被附近的敌人知道，然后出来抓你背身（每时每刻都不该给被身给别人）、1v1的时候漏脚步，会被人预瞄锁死的。</span><br><span class="line"></span><br><span class="line">残局1v1可以漏假脚步然后回头反打。</span><br><span class="line"></span><br><span class="line">残局不要丢雷啦，丢雷老母，被抓timing就寄了。</span><br><span class="line">一打多的残局最好是选择保枪</span><br><span class="line"></span><br><span class="line">或者必须打的残局要熟悉该地图的残局搜点顺序、用以确定敌人位置做好定位预瞄。</span><br><span class="line"></span><br><span class="line">残局可以开枪掩蔽下落的声音</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSGO</category>
        <category>Steam</category>
      </categories>
      <tags>
        <tag>CSGO</tag>
        <tag>Steam</tag>
      </tags>
  </entry>
  <entry>
    <title>CSGO饰品交易规律</title>
    <url>/2023/11/26/cs2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="饰品交易规律总结"><a href="#饰品交易规律总结" class="headerlink" title="饰品交易规律总结"></a>饰品交易规律总结</h1><p>仅仅代表个人经验，请勿过度解读。</p>
<p>2023.11.12日cs2市场在售刀的总量为：18w</p>
<p>可以下跌5%就出。</p>
<p>燃的时候无脑入，但是不当接盘侠，不接最后一棒，</p>
<p>最好保障仓内仓外资金各一半。</p>
<h2 id="1-冷知识"><a href="#1-冷知识" class="headerlink" title="1.冷知识"></a>1.冷知识</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.能不买暗金就别买暗金：小赚的也不要碰，太难卖了，0.16暗金印花集跌的时候都卖不出去，最后低价换了略磨贴纸燃料喷射器AK，结果这把贴纸燃料喷射器卖了两个星期也没卖出去，反而印花集涨回去了，这波亏麻了。</span><br><span class="line"></span><br><span class="line">2.能不买贴纸枪就不买贴纸枪：贴纸枪和暗金的武器都一样不好出，除非是那种特别硬的贴纸，不然贼难搞。</span><br><span class="line">3.收藏品的下级涨的比例比上级高</span><br><span class="line"></span><br><span class="line">4.要涨的时候，原皮先涨、然后是热门涂装、崭新的涨的比其他磨损多。</span><br><span class="line"></span><br><span class="line">5.新箱子出来，有钱的就练红，没钱的就练粉、5/5出货！！！、磨损要拉开，5个0.01的、五个略磨的降低成本</span><br><span class="line"></span><br><span class="line">6.箱子稀有掉落第一天是暴涨、第二天就会回落的、但是总体会小涨。</span><br><span class="line">新箱子不要去炼暗金的物品、暗金掉落数量少、价格虚高很多、炼金配方收益小</span><br><span class="line"></span><br><span class="line">7.捡漏可以直接刷新uu市场、比直接查某个饰品有没有漏更好、漏都是即时的、去查是很难查到的、刷到啥看啥最好</span><br><span class="line"></span><br><span class="line">8.跌之前就不要轻易卖掉，大部分人都是第一波涨就出了，燃爆的时候能涨三波。等小跌的时候再出也不会亏多少，但是能保证在最高位附近卖掉。</span><br><span class="line"></span><br><span class="line">9.不卖给熟人，卖高了就算了，卖低了又少赚，cd到了更不方便</span><br><span class="line"></span><br><span class="line">10.大型比赛决赛前每个选手签名多多少少可以搞一点、胶囊的话，尤其是具有潜力的签名胶囊，buff每次价格都比直接7快钱去steam买还高</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-涨跌规律"><a href="#2-涨跌规律" class="headerlink" title="2.涨跌规律"></a>2.涨跌规律</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.大件在售减少的多+小件涨的多才算购买力高、能涨，只涨小件只能说大商在旁观。</span><br><span class="line"></span><br><span class="line">2.跌了不要着急卖，迟早涨回去的，又不是a1被削那种暴跌、而且短期涨不回去还可能跌的那种，除非短期内有涨的特别多的东西去买，否则捏手上就是了，卖出去换成资金不值得。</span><br><span class="line"></span><br><span class="line">3.M9、爪子、蝴蝶刀的原皮价格波动是涨和跌的标志之一。</span><br><span class="line"></span><br><span class="line">4.不要随便买弟弟皮肤、燃爆了的时候、蝴蝶的枯焦之色就涨几十块，不如熊刀短剑原皮一根毛：弟弟原皮刀&gt;热门枪皮&gt;热门刀型的弟弟涂装</span><br><span class="line"></span><br><span class="line">5.跌的时候可能会有人压价，而且不发货，故意制造崩盘，因此抄底应该在价格稳定后再抄。</span><br><span class="line"></span><br><span class="line">6.暴涨后要是跌，第一波cd那么不一定是最低价，反而是第一波cd的前两天会崩很多。</span><br><span class="line"></span><br><span class="line">7.长期看涨、行情好的时候，无脑抄底就是了，七天乐一定赚、甚至拿来倒steam余额可能赚更多</span><br><span class="line"></span><br><span class="line">8.价格和销售量，稳价格优先，在售上去了，销量少了还不要紧，价格稳住了就能稳，价格不稳，崩！</span><br><span class="line"></span><br><span class="line">9.大盘一般扫货3个星期，第四个星期开始拉盘出货。</span><br><span class="line"></span><br><span class="line">10.看最低点的波动情况或者看最高点的波动情况、以及M（5）、M（30）曲线的走势。</span><br><span class="line"></span><br><span class="line">11.颜色很紫的贴纸刚出来的时候多买点，倒狗喜欢炒颜色很紫的帖子。</span><br><span class="line"></span><br><span class="line">12.涨的时候先卖库存恰第一波，然后去买暗金的刀去方案别人的库存，恰第二波。</span><br><span class="line"></span><br><span class="line">13.贴纸的倒余额比例如果达到1至1.1，就要开始跌了，比例小于1的，属于正常的，可能会涨。</span><br><span class="line"></span><br><span class="line">14.一般月初燃、下旬开始跌</span><br></pre></td></tr></table></figure>



<h2 id="3-倒余额和余额套现的实际利润"><a href="#3-倒余额和余额套现的实际利润" class="headerlink" title="3.倒余额和余额套现的实际利润"></a>3.倒余额和余额套现的实际利润</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">余额和套现的实际利润（以倒余额比例为标准表达信息）</span><br><span class="line">倒余额比例		：		余额套现	     余额套现比例=倒余额比例*0.87</span><br><span class="line">	0.8		*0.87		0.696			经过一轮搬砖其利润为：(余额套现比例/倒余额比例)-1</span><br><span class="line">	0.85	...			0.7395			好点的情况一轮搬砖利润情况为：25%（8折倒余额，提现1倍）</span><br><span class="line">	0.9		...			0.783			</span><br><span class="line">	0.95	...			0.8265</span><br><span class="line">	1		...			0.87			如果一个饰品的倒余额比例越好，那么套现越不行</span><br><span class="line">	1.05	...			0.9135			反之倒余额比例越不好看，那么套现比例就高</span><br><span class="line">	1.1		...			0.957	</span><br><span class="line">	1.15	...			1.0005			</span><br><span class="line">	1.2		...			1.044</span><br><span class="line"></span><br><span class="line">计算例子：100元的枪皮，倒余额的比例是0.8，则其steam售价是100/0.8/0.87=143.67816；然后实际到手steam余额是125，也就是100倒了8折余额变成125，然后拿这125的steam余额买这8折的枪皮换成buff的人民币，大概是：125*（100/143.67816）=87.0000005568，那么套现比例是87/125=0.696</span><br><span class="line"></span><br><span class="line">倒余额当然比例越低越好，2023年9月倒余额正常情况最低大约0.8左右</span><br><span class="line"></span><br><span class="line">余额套现当然选择倒余额比例比较高的那种最好，2023年9月倒余额正常情况最高大约为1.1，也就是套现大概1的样子</span><br><span class="line"></span><br><span class="line">steam的余额上限是2000欧元，看情况需要两个或者多个steam可交易的号</span><br><span class="line"></span><br><span class="line">1000元经过倒余额和套现能赚的差价：（不考虑市场涨幅和跌幅，实际上市场涨的时候可以steam套现，市场跌的时候顶多进行倒余额，因为卖到steam市场不需要cd，套现需要7天多的cd，这样比例很可能不达期望）</span><br><span class="line">按照0.83倒余额，0.87套现，到手1048，差价为48元，差价比例为4.8%</span><br><span class="line">那么差价比例关系是：</span><br><span class="line">套现比例/倒余额比例=到手金额的倍率	到手金额倍率再减1就是经过这一轮的实际利润一般从4.8%-25%不等）</span><br><span class="line">0.87/0.83=1.048  	1.048-1=0.048，也就是4.8%</span><br><span class="line"></span><br><span class="line">倒余额的饰品短期内一定不适合拿来套现，套现的饰品短期内一定不适合倒余额</span><br></pre></td></tr></table></figure>

<h2 id="4-倒余额规律"><a href="#4-倒余额规律" class="headerlink" title="4.倒余额规律"></a>4.倒余额规律</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.倒余额倒好了就不要随意动余额了。跌的时候多倒一些，这个时候倒余额比例高。</span><br><span class="line"></span><br><span class="line">1.倒余额比例最低要求0.8，然后能卖到0.78就卖0.78，有压价的就最低0.8卖</span><br><span class="line"></span><br><span class="line">2.一般几千块钱的刀倒余额比例比较低，列如2023.09.07日的爪子多普勒有0.81的比例、双栖久经甚至0.74，不过容易压价，而且很少有人买，卖的话最低0.8的底线，建议不要买那种几千块钱的饰品倒余额，太难卖了。</span><br><span class="line"></span><br><span class="line">3.一般几十块钱、几百块钱的小饰品倒余额比例0.9左右，如果有8折的，切记，只买一件或者两件，因为这类小饰品波动大，有可能你刚在buff买，很多人和你一样，然后在steam压价售出，那比例就没有0.8了</span><br><span class="line"></span><br><span class="line">4.计算倒余额比例：</span><br><span class="line">****************************************************************************************</span><br><span class="line">人民币售价/（steam售价*0.87）=人民币售价/欧元兑人民币汇率/steam售价/0.87=倒余额比例</span><br><span class="line">****************************************************************************************</span><br><span class="line">比如 3000CNY的手套，steam卖500欧元，那么比例是：3000/7.83/500/0.87 = 0.8232</span><br><span class="line"></span><br><span class="line">5.在buff或者uu买饰品的时候可以边砍价边求购，或者直接买了，然后挂steam快点卖掉。</span><br><span class="line"></span><br><span class="line">6.给了buff售价（CNY）和steam售价（欧元），求倒余额比例：比例x=buff人民币售价/steam欧元售价/汇率/0.87</span><br><span class="line"></span><br><span class="line">7.倒余额看运气捡漏，然后挂steam卖，大件虽然比例好，但是不容易卖掉。</span><br><span class="line">*****************************************************************************************</span><br><span class="line">8.市场不景气的时候倒余额比例会比较好看，因为steam价格变化波动比较慢，buff先跌，而steam可能没变，但是这时候买一个就行，买多了，别人压价的，知道这个饰品倒余额不错的人不止我们一个人。</span><br><span class="line">*****************************************************************************************</span><br><span class="line"></span><br><span class="line">9.普通人买贴纸想赚钱的话，倒余额比例0.8几的帖纸不能屯，没有倒狗护盘的，倒狗的项目的贴纸它的倒余额比例在1附近</span><br><span class="line"></span><br><span class="line">10.市场燃的时候，可以买贴纸、枪皮倒余额，容易在steam卖掉</span><br><span class="line"></span><br><span class="line">11.市场跌的时候，要等跌停，这个时候可以多买点贴纸倒余额，因为跌不下去了嘛，steam价格甚至会涨上去，这个时候按照0.8或者0.78的比例便宜卖，就能有多少能卖多少。</span><br><span class="line"></span><br><span class="line">12.steam市场倒余额的饰品价格越高，销量越低，越久远的东西，销量也越低，所以倒余额必须在今年热门的便宜贴纸中，选出倒余额比例好的饰品，然后在涨或者跌停的时候大量倒余额。满足要求的贴纸大多数是几块钱或者十几块的，不是签名的闪耀或者全息贴纸。</span><br><span class="line"></span><br><span class="line">13.倒余额推荐买比例高的枪皮，或者便宜的刀子、手套，因为倒余额比例高的一般都是没有销量的东西，所以干脆不买贴纸，直接买几百块钱的枪皮、刀、手套即可，然后看运气几天卖掉，切记买几千的枪、手套、刀倒余额、本来就难卖，价格贵了更难卖了。</span><br><span class="line"></span><br><span class="line">14.比赛的决赛在打完前，可以uu或者buff买要燃的mvp选手的贴纸，然后挂steam卖掉能恰一波倒余额的米，能买多少就买多少。</span><br><span class="line"></span><br><span class="line">15.第一次倒余额，就踩坑了，买了两个两个傻逼手套挂了6天，压根没人买，唯一的垃圾弟弟折叠刀也是惨遭压价卖不出去，1.4w的钱七天后uu取出来换其他类型的饰品倒余额，这里推荐10-250以内的热门枪皮，比如黑色魅影、合纵、活色生香等等，然后就是800以内的弟弟刀、弟弟手套，也要热门的，主要是看steam市场的销量如何，倒余额的第三天下午2个小时不到倒了steam余额66欧元（而且全是不超过78折），还差一个久经合纵（晚上7点卖了）卖34欧元还没卖出去。要是加上弟弟手套一天倒1500多人民币不是问题的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*******************************************************************************</span><br><span class="line">16.出新箱子之后的一个星期备好余额，新箱子炼金最好在一个月内从steam买，buff价格更高，套现比例甚至1.2，也就是100的皮肤价值120，但是cs到了就不知道了，这个时候用余额买材料炼金最划算。</span><br><span class="line">********************************************************************************</span><br></pre></td></tr></table></figure>





<h2 id="5-套现规律"><a href="#5-套现规律" class="headerlink" title="5.套现规律"></a>5.套现规律</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.套现在燃的时候套现，这个时候套现比例高，其他时候最好不要动余额，我第一次倒余额就犯错了，倒完余额立马选饰品套现，吃大亏了。过了半年才知道是我套现时机不对。</span><br><span class="line"></span><br><span class="line">1.普通套现要求倒余额比例最低1.05，也就是套现0.9135，一般小物品有0.9135倍的套现，捡漏可以有0.95或者更高的套现比例</span><br><span class="line">****************************************************************************************</span><br><span class="line">2.市场涨的时候可以进行大规模套现，可以直接在steam买也可以在steam求购，推荐求购steam市场的贴纸，这个时候就不管签名还是不签名了，只要套现比例好，市场燃的时候就能在buff/uu卖个好价钱</span><br><span class="line">求购有两个好处：</span><br><span class="line">A.不用一个一个去买，求购挂上去等别人丢就行，</span><br><span class="line">B.市场好的时候，steam挂求购到能保证套现比例0.95或以上</span><br><span class="line"></span><br><span class="line">3.市场跌的时候，尽量少进行steam余额套现操作，因为七天交易cd，很多饰品比例很不稳定（某些）。但是市场跌停（也就是跌之后buff小涨或者横盘了，这个时候steam价格还没波动多少的）的时候买那些套现比例好的贴纸，然后捏着等涨就行（不限量，要求选好签名贴纸或者武器箱，能买多少就买多少）。</span><br><span class="line">***************************************************************************************</span><br><span class="line">4.套现按照到余额的比例来选，倒余额的比例大于等于1.1的饰品套现，小饰品买少，大饰品看运气求购到就行。</span><br><span class="line"></span><br><span class="line">5.steam求购的套现比例：</span><br><span class="line">x元求购到，卖y元 y/x=比例</span><br><span class="line"></span><br><span class="line">6.求购一些求购比例高的物品，比如稀有手套、纪念品等等，套现比例甚至超过1，挂着求购就行，时不时看一看价格变化，以免求购比例降低了。贵重饰品倒余额比例大概是1.15上下，求购的时候按照这个比例求购是求购不到的，steam求购顶的很厉害，求购套现比例都比1低，所以不推荐steam求购大件，小件可以慢慢求购套现。</span><br><span class="line"></span><br><span class="line">7.套现比例比到余额比例更重要，当然差值很小，实际上两个比例都选最好的就行，两个比例都很重要。</span><br><span class="line"></span><br><span class="line">8.遇到倒余额比例1.1以上的套现饰品只需要买一个就行，买多了没用，小金额的可以多买几个，切记买多，应该注意买的种类要多，这样套现才稳、快。</span><br><span class="line"></span><br><span class="line">9.大多数都是几块钱、几十块钱的小饰品套现比例比较高（倒余额比例大概要有1.1），饰品交易要经历七天cd的套现，套现高的小饰品少买，风险大。</span><br><span class="line"></span><br><span class="line">10.在steam市场进行求购，计算好求购价钱，挂着等人丢就行，注意饰品价格不能波动太多，尤其是市场跌的时候。</span><br><span class="line">0.9135*求购价x=buff或者uu售价，所以求购价x 应该为buff售价/0.9135/汇率</span><br><span class="line"></span><br><span class="line">11.套现的时候steam挂的求购价计算：和10内容类似</span><br><span class="line">套现比例0.95=卖出的价格/欧元兑人民币汇率/steam求购买入的价格，</span><br><span class="line">****************************************************************************************</span><br><span class="line">即：steam求购价=buff的人民币售价/欧元兑汇率/想要的套现比例0.9135起</span><br><span class="line">***************************************************************************************</span><br><span class="line">12.套现得会挑饰品，八天cd很长很长，不好说最后一天价格怎么变化，可以在200以内的倒余额比例为1以上（套现就是0.87以上）的贴纸和胶囊跌的时候大量买入，等cd到了或者等一段时间涨的时候卖，因此建议倒余额比例为1以上的贴纸在跌停的时候，可以购买大量的，然后价格不错的时候出掉即可。********************************************************************************</span><br><span class="line"></span><br><span class="line">13.套现选贴纸的规律：一.它的倒余额比例在1附近	二.它的价格要超过50元，然后越便宜越好，因为倒狗的贴纸越贵越难炒	三.最好是签名贴纸	四.满足前三点的签名帖子几乎全是是导购的项目（可以拿来当项目），而且那些当过项目但是大倒狗抛弃了的贴纸也不要买，一直小跌，根本没希望涨的。	五.量不能太大，签名帖纸量少好炒，所以全息mouze为什么满足前三点却不能套现，mouze量太大了，价格不容易上去。六.至于什么时候卖掉，steam买了后一个月内在燃的时候（买入价的1.1倍就可以出了，贪一点可以1.2或者更高）卖掉，不然等开始跌了，卖是卖不出去的，你只能赶紧丢求购。</span><br><span class="line"></span><br><span class="line">14.热门饰品的套现比例都很高，但是一般就只有1左右，所以套现想多套一点，就只能选今年热门或者说倒狗在炒的贴纸，一般是全息的好看的贴纸，价格在120以内、比例1以上的、能无脑入。然后捏两个星期或者一个星期就可以出了。</span><br><span class="line"></span><br><span class="line">15.小规模套现可以买热门贴纸然后套现、大规模的敢赌就买签名贴纸，风险和收益并存，稳一点就拿武器箱套现。武器箱是最稳的，cd一到，就可以找个好价格（最低steam买入价*0.86）全部卖掉了，然后进行下一轮搬砖，就是武器箱收益只有10%（0.86/0.78=110%，收益大概10%出头，因为小饰品倒余额是不超过78折的）</span><br><span class="line"></span><br><span class="line">16.套现的要求：量大，steam在售量、交易量要很大很大，然后steam求购说实在的根本求购不到，必须要直接买，所以说看好哪个套现的贴纸和胶囊，想要大量套现的话，必须直接买几百个，然后等七天后看价格再卖出去。9-14日大概是6块钱的武器箱、2块钱的胶囊等等。这就是短期套现的情况。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSGO</category>
        <category>Steam</category>
      </categories>
      <tags>
        <tag>CSGO</tag>
        <tag>Steam</tag>
      </tags>
  </entry>
  <entry>
    <title>CSGO倒余额脚本/cfg</title>
    <url>/2024/01/23/cs3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="buff倒余额比例脚本"><a href="#buff倒余额比例脚本" class="headerlink" title="buff倒余额比例脚本"></a>buff倒余额比例脚本</h1><p>把以下内容复制到js文件中，在猴油或者脚本猫中添加js脚本，打开buff即可查看了。</p>
<p>&#x2F;&#x2F; &#x3D;&#x3D;UserScript&#x3D;&#x3D;<br>&#x2F;&#x2F; @name         CSGO饰品价格对比脚本_Steam挂刀助手版<br>&#x2F;&#x2F; @connect      *<br>&#x2F;&#x2F; @version      2.2.5<br>&#x2F;&#x2F; @description  将各个CSGO饰品交易平台的价格放在一起显示，省去打开多个网页的繁琐操作！该版本原作者为RookieHong，因饰品平台接口网页已更新过原版本不适用，因此大地球就更新了下，有问题可在公众号（Steam挂刀助手）反馈给我，感谢大家支持。 支持平台：BUFF、C5、IGXE、悠悠有品<br>&#x2F;&#x2F; @updater      大地球<br>&#x2F;&#x2F; @origin_author RookieHong<br>&#x2F;&#x2F; @grant        GM_xmlhttpRequest<br>&#x2F;&#x2F; @match        <a href="https://www.c5game.com/csgo">https://www.c5game.com/csgo</a>*<br>&#x2F;&#x2F; @match        <a href="https://www.igxe.cn/market/csgo">https://www.igxe.cn/market/csgo</a>*<br>&#x2F;&#x2F; @match        <a href="https://buff.163.com/market/csgo">https://buff.163.com/market/csgo</a>*<br>&#x2F;&#x2F; @match        <a href="https://www.v5fox.com/csgo">https://www.v5fox.com/csgo</a>*<br>&#x2F;&#x2F; @match        <a href="https://www.youpin898.com/market/csgo?gameId=730">https://www.youpin898.com/market/csgo?gameId=730</a>*<br>&#x2F;&#x2F; @match        <a href="http://www.898yp.com/market/csgo?gameId=730">http://www.898yp.com/market/csgo?gameId=730</a>*<br>&#x2F;&#x2F; @require      <a href="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js">https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js</a><br>&#x2F;&#x2F; @namespace <a href="https://greasyfork.org/users/209766">https://greasyfork.org/users/209766</a><br>&#x2F;&#x2F; @license GNU GPLv3<br>&#x2F;&#x2F; &#x3D;&#x3D;&#x2F;UserScript&#x3D;&#x3D;</p>
<p>&#x2F;&#x2F;UUYP接口更新 Cookie需定时登陆自己账号更新(大概15天一次)<br>function GetUUYPCookie(){<br>    var UUYPCookie &#x3D; “<a href="https://www.youpin898.com/market/csgo?gameId=730">https://www.youpin898.com/market/csgo?gameId=730</a>“<br>    return UUYPCookie<br>}</p>
<p>&#x2F;&#x2F; 防止点击价格列表时触发重叠的物品点击事件<br>function stopBubbling(e) {<br>    e &#x3D; window.event || e;<br>    if (e.stopPropagation) {<br>        e.stopPropagation();      &#x2F;&#x2F;阻止事件 冒泡传播<br>    } else {<br>        e.cancelBubble &#x3D; true;   &#x2F;&#x2F;ie兼容<br>    }<br>}</p>
<p>&#x2F;&#x2F;去除名字中的所有空格<br>function Trim(str) {<br>    return str.replace(&#x2F;\s*&#x2F;g, “”);<br>}</p>
<p>&#x2F;&#x2F;用来替代GM_addStyle的方法<br>function addStyle(cssStr) {<br>    try {<br>        let node &#x3D; document.createElement(‘style’);<br>        node.textContent &#x3D; cssStr;<br>        document.querySelector(‘:root’).appendChild(node);<br>    } catch (e) { }<br>}</p>
<p>&#x2F;&#x2F;生成表单内容的json结构体<br>$.fn.serializeObject &#x3D; function () {<br>    var o &#x3D; {};<br>    var a &#x3D; this.serializeArray();<br>    $.each(a,<br>        function () {<br>            if (o[this.name] !&#x3D;&#x3D; undefined) {<br>                if (!o[this.name].push) {<br>                    o[this.name] &#x3D; [o[this.name]];<br>                }<br>                o[this.name].push(this.value || ‘’);<br>            } else {<br>                o[this.name] &#x3D; this.value || ‘’;<br>            }<br>        });<br>    return o;<br>};</p>
<p>&#x2F;&#x2F;IGXE上的生成下一页链接的函数<br>function IGXE_gen_url(url, params) {<br>    var new_params &#x3D; {};<br>    var new_params_length &#x3D; 0;<br>    for (var key in params) {<br>        if (params[key]) {<br>            new_params[key] &#x3D; params[key];<br>            new_params_length +&#x3D; 1;<br>        }<br>    }<br>    if (new_params_length &lt;&#x3D; 0) {<br>        return url;<br>    }</p>
<p> return url + ‘?’ + jQuery.param(new_params);</p>
<p>};</p>
<p>$(document).ready(function () {<br>    var myScriptStyle &#x3D; ‘.myTitle {font-weight: bold;} <br>                    .mySum {color: #429605;}<br>                    .myPrice{color: #0b84d3;}<br>                    .c5li{margin: 0px!important;white-space: nowrap; font-size: 12px; list-style-type:none;}<br>                    .igli{padding:4px; font-size: 12px; white-space: nowrap; list-style-type:none;}<br>                    .buffli{ width:auto!important; height: auto!important; float:none!important; margin: 0px!important; padding:4px!important; font-size: 12px; white-space: nowrap; border: inherit!important; border-radius: 0!important; background: #959595!important; }<br>                    .buffli a{background: #959595!important; text-align: left!important;}<br>                    .v5li {padding: 4px; font-size: 12px; white-space: nowrap; list-style-type:none;}<br>                    .youpinli{padding:4px; font-size: 12px; white-space: nowrap; list-style-type:none;}’; &#x2F;&#x2F; list-style-type:none;是为了去掉列表元素前面的小点，即::marker<br>    myScriptStyle &#x3D; myScriptStyle + ‘&#x2F;* 容器 <div> - 需要定位下拉内容 <em>&#x2F;<br>.dropdown {<br>    position: relative;<br>    display: inline-block;<br>}<br><br>&#x2F;</em> 下拉内容 (默认隐藏) <em>&#x2F;<br>.c5-dropdown-content {<br>    display: none;<br>    position: absolute;<br>    background-color: #1c2734!important;<br>    min-width: 160px;<br>    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);<br>    z-index: 9999;<br>}<br><br>&#x2F;</em> 下拉菜单的链接 <em>&#x2F;<br>.c5-dropdown-content a {<br>    color: white;<br>    padding: 12px 16px;<br>    text-decoration: none;<br>    display: block;<br>}<br><br>&#x2F;</em> 鼠标移上去后修改下拉菜单链接颜色 <em>&#x2F;<br>.c5-dropdown-content a:hover {background-color: #313d4d!important;}<br><br>&#x2F;</em> 下拉内容 (默认隐藏) <em>&#x2F;<br>.igxe-dropdown-content {<br>    display: none;<br>    position: absolute;<br>    background-color: #1c2734!important;<br>    min-width: 160px;<br>    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);<br>    z-index: 9999;<br>}<br><br>&#x2F;</em> 下拉菜单的链接 <em>&#x2F;<br>.igxe-dropdown-content a {<br>    color: white;<br>    padding: 12px 16px;<br>    text-decoration: none;<br>    display: block;<br>}<br><br>&#x2F;</em> 鼠标移上去后修改下拉菜单链接颜色 <em>&#x2F;<br>.igxe-dropdown-content a:hover {background-color: #313d4d!important;}<br><br>&#x2F;</em> 下拉内容 (默认隐藏) <em>&#x2F;<br>.buff-dropdown-content {<br>    display: none;<br>    position: absolute;<br>    background-color: #1c2734!important;<br>    min-width: 160px;<br>    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);<br>    z-index: 9999;<br>}<br><br>&#x2F;</em> 下拉菜单的链接 <em>&#x2F;<br>.buff-dropdown-content a {<br>    color: white;<br>    padding: 12px 16px;<br>    text-decoration: none;<br>    display: block;<br>}<br><br>&#x2F;</em> 鼠标移上去后修改下拉菜单链接颜色 <em>&#x2F;<br>.buff-dropdown-content a:hover {background-color: #f2efef!important;}<br><br>&#x2F;</em> 下拉内容 (默认隐藏) <em>&#x2F;<br>.v5-dropdown-content {<br>    display: none;<br>    position: absolute;<br>    background-color: #1c2734!important;<br>    min-width: 160px;<br>    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);<br>    z-index: 9999;<br>}<br><br>&#x2F;</em> 下拉菜单的链接 <em>&#x2F;<br>.v5-dropdown-content a {<br>    color: white;<br>    padding: 12px 16px;<br>    text-decoration: none;<br>    display: block;<br>}<br><br><br>&#x2F;</em> 鼠标移上去后修改下拉菜单链接颜色 <em>&#x2F;<br>.v5-dropdown-content a:hover {background-color: #313d4d!important;}<br><br>&#x2F;</em> 下拉内容 (默认隐藏) <em>&#x2F;<br>.youpin-dropdown-content {<br>    display: none;<br>    position: absolute;<br>    background-color: #1c2734!important;<br>    min-width: 160px;<br>    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);<br>    z-index: 9999;<br>}<br><br>&#x2F;</em> 下拉菜单的链接 <em>&#x2F;<br>.youpin-dropdown-content a {<br>    color: white;<br>    padding: 12px 16px;<br>    text-decoration: none;<br>    display: block;<br>}<br>&#x2F;</em> 鼠标移上去后修改下拉菜单链接颜色 *&#x2F;<br>.youpin-dropdown-content a:hover {background-color: #313d4d!important;}’;<br>    addStyle(myScriptStyle);</p>
<p>if (location.href.indexOf(‘c5game.com’) &gt; 0) {<br>    c5();<br>}<br>else if (location.href.indexOf(‘igxe.cn’) &gt; 0) {<br>    igxe();<br>}<br>else if (location.href.indexOf(‘buff.163.com’) &gt; 0) {<br>    buff();<br>}<br>else if (location.href.indexOf(‘v5fox.com’) &gt; 0) {<br>    v5fox();<br>}<br>else if (location.href.indexOf(‘youpin898.com’) &gt; 0) {<br>    youpin();<br>}<br>else if (location.href.indexOf(‘898yp.com’) &gt; 0) {<br>    youpin();<br>}</p>
<p>});</p>
<p>function addC5(c5URL, li, itemName) {<br>    GM_xmlhttpRequest({<br>        method: ‘GET’,<br>        url: c5URL,<br>        onload: function (response) {<br>            var doc &#x3D; (new DOMParser).parseFromString(response.responseText, ‘text&#x2F;html’);<br>            var body &#x3D; doc.querySelector(‘body’);<br>            var items &#x3D; $(body).find(‘.list’).find(‘.li-btm’);<br>            var hasNextPage &#x3D; $(body).find(‘.el-pager’).find(‘.li’).length &#x3D;&#x3D; 0 ? false : true;<br>            for (var i &#x3D; 0; i &lt; items.length; i++) {<br>                var name &#x3D; $(items[i]).find(‘h4’).text();<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var price &#x3D; $(items[i]).find(‘.price’).text().replace(‘￥’,’’).replace(‘ ‘,’’);<br>                    var url &#x3D; ‘<a href="https://www.c5game.com/csgo?keyword=">https://www.c5game.com/csgo?keyword=</a>‘ + name + ‘&amp;page&#x3D;1’;<br>                    var sum &#x3D; $(items[i]).find(‘.count’).text().replace(‘件在售’,’’).replace(‘ ‘,’’);<br>                    &#x2F;&#x2F;sum &#x3D; sum.substring(0, sum.length - 3);<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">C5</span>‘ + ‘在售：<span class="mySum">‘ + sum + ‘</span>售价：<span class="myPrice">‘ + price + ‘</span></a>‘);<br>                    return price;<br>                }<br>            }<br>            if (!hasNextPage) $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">C5：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);  &#x2F;&#x2F;若没有下一页则可以判断没有该物品的数据<br>            else {<br>                var cur_page &#x3D; $(body).find(‘.pagination’).find(‘.active’).find(‘a’).text();<br>                var next_page &#x3D; cur_page + 1;<br>                var url &#x3D; ‘<a href="https://www.c5game.com/csgo?keyword=">https://www.c5game.com/csgo?keyword=</a>‘ + itemName + ‘&amp;page&#x3D;’ + next_page;<br>                addC5(url, li, itemName);<br>            }<br>        }<br>    })<br>}</p>
<p>function addIGXE(igxeURL, li, itemName) {<br>    GM_xmlhttpRequest({<br>        method: ‘GET’,<br>        url: igxeURL,<br>        onload: function (response) {<br>            var doc &#x3D; (new DOMParser).parseFromString(response.responseText, ‘text&#x2F;html’);<br>            var body &#x3D; doc.querySelector(‘body’);<br>            var items &#x3D; $(body).find(“.list”).find(‘a’);<br>            var hasNextPage &#x3D; $(body).find(‘.paginate .btn-next’).disabled;   &#x2F;&#x2F;判断是否有下一页<br>            for (var i &#x3D; 0; i &lt; items.length; i++) {<br>                var name &#x3D; $(items[i]).find(‘div.name’).text().trim();<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var url &#x3D; ‘<a href="https://www.igxe.cn/">https://www.igxe.cn</a>‘ + $(items[i]).attr(‘href’);<br>                    var sum &#x3D; $(items[i]).find(‘div.stock’).text().trim().substring(3);<br>                    var price &#x3D; $(items[i]).find(‘div.price’).text().trim().replace(“￥”,””);<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">IGXE</span>‘ + ‘在售：<span class="mySum">‘ + sum + ‘</span>售价：<span class="myPrice">‘ + price + ‘</span></a>‘);<br>                    return price;<br>                }<br>            }<br>            if (!hasNextPage) $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">IGXE：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);  &#x2F;&#x2F;若没有下一页则可以判断没有该物品的数据<br>            else {  &#x2F;&#x2F;走igxe网站的流程到下一页查询<br>                var page_no &#x3D; parseInt($(body).find(‘.paginate .el-pager .active’).textContent) + 1<br>                var url_param &#x3D; $(body).find(‘#params_form’).serializeObject(); &#x2F;&#x2F;params_form是网站上的一个隐藏元素，存放各种表单信息<br>                url_param[‘page_no’] &#x3D; page_no; &#x2F;&#x2F;把里面的page_no项换成下一页<br>                url_param[‘_t’] &#x3D; new Date().getTime(); &#x2F;&#x2F;得到当前时间戳<br>                url &#x3D; ‘<a href="https://www.igxe.cn/market/csgo?sort=3&keyword=">https://www.igxe.cn/market/csgo?sort=3&amp;keyword=</a>‘ + itemName + ‘&amp;page_no&#x3D;’ + page_no.toString();<br>                addIGXE(url, li, itemName); &#x2F;&#x2F;递归调用该函数直到找到该物品<br>            }<br>        }<br>    });<br>}</p>
<p>function addBUFF(buffURL, li, itemName) {<br>    GM_xmlhttpRequest({<br>        method: ‘GET’,<br>        url: buffURL,<br>        onload: function (response) {<br>            var data &#x3D; $.parseJSON(response.responseText);<br>            if (‘error’ in data) {<br>                $(li).html(‘<a href="https://buff.163.com/?game=csgo" style="padding: 0px"><span class="myTitle">BUFF：</span><span style="color: #FF0000">需要登录BUFF！</span></a>‘);<br>                return;<br>            }<br>            data &#x3D; data.data;<br>            for (var i &#x3D; 0; data.items !&#x3D; ‘undefined’ &amp;&amp; i &lt; data.items.length; i++) {<br>                var name &#x3D; data.items[i].name;<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var url &#x3D; ‘<a href="https://buff.163.com/market/goods?goods_id=">https://buff.163.com/market/goods?goods_id=</a>‘ + data.items[i].id + ‘&amp;from&#x3D;market#tab&#x3D;selling’;<br>                    var sum &#x3D; data.items[i].sell_num;<br>                    var price &#x3D;  data.items[i].sell_min_price;<br>                    var steamPrice &#x3D; data.items[i].goods_info.steam_price_cny;<br>                    var PricePercent &#x3D; parseFloat(price &#x2F; (steamPrice &#x2F; 1.15)).toFixed(2);<br>                    &#x2F;&#x2F;(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">BUFF<span>‘ + ‘比例：’+ PricePercent +  ‘</span>售价：<span class="myPrice">‘ + price +  ‘ 在售：<span class="mySum">‘ + sum + ‘</span> </a>‘<br>                    &#x2F;&#x2F;    );<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">BUFF  <span>‘ +  ‘ 在售：<span class="mySum">‘ + sum + ‘  售价：<span class="myPrice">‘ + price + ‘</span> </a>‘<br>                               + ‘<a href="' + url + '" style="padding: 0px"><span style="color:#FFFF00" class="myTitle">BUFF<span style="color:#FFFF00">‘ + ‘  挂刀比例：’+ PricePercent +  ‘</span> </a>‘);<br>                    return [price,steamPrice];<br>                }<br>            }<br>            var total_pages &#x3D; data.total_page;<br>            var cur_page &#x3D; data.page_num;<br>            if (cur_page &gt;&#x3D; total_pages) $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">BUFF：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);<br>            else {<br>                var next_page &#x3D; cur_page + 1;<br>                var url &#x3D; ‘<a href="https://buff.163.com/api/market/goods?game=csgo&page_num=">https://buff.163.com/api/market/goods?game=csgo&amp;page_num=</a>‘ + next_page + ‘&amp;search&#x3D;’ + itemName.trim() + ‘&amp;_&#x3D;’ + (new Date()).valueOf().toString();<br>                addBUFF(url, li, itemName);<br>            }<br>        }<br>    });<br>}</p>
<p>function addV5(v5URL, li, itemName) {<br>    GM_xmlhttpRequest({<br>        method: ‘GET’,<br>        url: v5URL,<br>        onload: function (response) {<br>            var doc &#x3D; (new DOMParser).parseFromString(response.responseText, ‘text&#x2F;html’);<br>            var body &#x3D; doc.querySelector(‘body’);<br>            var items &#x3D; $(body).find(“.list-box”).find(‘a’);<br>            var hasNextPage &#x3D; $(body).find(‘.laypage_next’).length &#x3D;&#x3D; 0 ? false : true;   &#x2F;&#x2F;判断是否有下一页<br>            for (var i &#x3D; 0; i &lt; items.length; i++) {<br>                var name &#x3D; $(items[i]).find(‘div.list-item-top’).find(‘div.list-text-box’).find(‘h5’).text().trim();<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var url &#x3D; ‘<a href="https://www.v5fox.com/">https://www.v5fox.com</a>‘ + $(items[i]).attr(‘href’);<br>                    var sum &#x3D; $(items[i]).find(‘div.list-item-bot’).find(‘div.r’).text().trim();<br>                    var price &#x3D; $(items[i]).find(‘div.list-item-top’).find(‘div.list-text-box’).find(‘p’).find(‘span’).text().trim();<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">V5FOX：</span>‘ + ‘在售：<span class="mySum">‘ + sum + ‘</span>售价：<span class="myPrice">‘ + price + ‘</span></a>‘);<br>                    return;<br>                }<br>            }<br>            if (!hasNextPage) $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">V5FOX：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);<br>            else {<br>                var cur_page &#x3D; $(‘.laypage_curr’).text();<br>                var next_page &#x3D; cur_page + 1;<br>                var url &#x3D; ‘<a href="https://www.v5fox.com/csgo/0-0?keyword=">https://www.v5fox.com/csgo/0-0?keyword=</a>‘ + itemName + ‘&amp;pageNum&#x3D;’ + next_page;<br>                addV5(url, li, itemName);<br>            }<br>        }<br>    });<br>}</p>
<p>function addyoupin_buy(youpin_url, li, itemName) {<br>    var pageIndex &#x3D; 1<br>    var data_str &#x3D; <code>&#123;\&quot;listType\&quot;:\&quot;30\&quot;,\&quot;gameId\&quot;:\&quot;730\&quot;,\&quot;keyWords\&quot;:\&quot;$&#123;itemName&#125;\&quot;,\&quot;stickers\&quot;:&#123;&#125;,\&quot;stickersIsSort\&quot;:false,\&quot;pageIndex\&quot;:$&#123;pageIndex&#125;,\&quot;pageSize\&quot;:20,\&quot;sortType\&quot;:\&quot;0\&quot;,\&quot;listSortType\&quot;:\&quot;2\&quot;&#125;</code>;<br>    console.log(data_str)<br>    GM_xmlhttpRequest({<br>        method: ‘POST’,<br>        url: ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘,<br>        data: data_str,<br>        headers: {<br>            “User-Agent”: “Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko&#x2F;20100101 Firefox&#x2F;110.0”,<br>            “Accept”: “application&#x2F;json, text&#x2F;plain, <em>&#x2F;</em>“,<br>            “Accept-Language”: “zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2”,<br>            “Content-Type”: “application&#x2F;json”,<br>            “AppType”: “1”,<br>            “Authorization”: GetUUYPCookie(),<br>            “Sec-Fetch-Dest”: “empty”,<br>            “Sec-Fetch-Mode”: “cors”,<br>            “Sec-Fetch-Site”: “same-site”<br>                },<br>        onload: function (response) {<br>            console.log(response)<br>            response &#x3D; JSON.parse(response.response);<br>            var items &#x3D; response.Data;<br>            if (items &#x3D;&#x3D; null) {<br>                $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">悠悠出售：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);<br>                return;<br>            }<br>            for (var i &#x3D; 0; i &lt; items.length; i++) {<br>                var item &#x3D; items[i];<br>                var name &#x3D; item.CommodityName;<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var url &#x3D; ‘<a href="http://www.youpin898.com/goodInfo?id=">http://www.youpin898.com/goodInfo?id=</a>‘ + item.Id;<br>                    var sum &#x3D; item.OnSaleCount;<br>                    var price &#x3D; item.Price;<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">UUYP</span>‘ + ‘在售：<span class="mySum">‘ + sum + ‘</span>售价：<span class="myPrice">‘ + price + ‘</span></a>‘);<br>                    return price;<br>                }<br>            }<br>        }<br>    });<br>}</p>
<p>function addyoupin_lease(youpin_url, li, itemName) {<br>    var pageIndex &#x3D; 1<br>    var data_str &#x3D; <code>&#123;\&quot;listType\&quot;:\&quot;30\&quot;,\&quot;gameId\&quot;:\&quot;730\&quot;,\&quot;keyWords\&quot;:\&quot;$&#123;itemName&#125;\&quot;,\&quot;pageIndex\&quot;:$&#123;pageIndex&#125;,\&quot;pageSize\&quot;:20,\&quot;sortType\&quot;:\&quot;0\&quot;,\&quot;listSortType\&quot;:\&quot;2\&quot;&#125;</code>;<br>    GM_xmlhttpRequest({<br>        method: ‘POST’,<br>        url: ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘,<br>        data: data_str,<br>        headers: {<br>                “User-Agent”: “Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko&#x2F;20100101 Firefox&#x2F;110.0”,<br>                “Accept”: “application&#x2F;json, text&#x2F;plain, <em>&#x2F;</em>“,<br>                “Accept-Language”: “zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2”,<br>                “Content-Type”: “application&#x2F;json”,<br>                “AppType”: “1”,<br>                “Authorization”: GetUUYPCookie(),<br>                “Sec-Fetch-Dest”: “empty”,<br>                “Sec-Fetch-Mode”: “cors”,<br>                “Sec-Fetch-Site”: “same-site”<br>        },<br>        onload: function (response) {<br>            response &#x3D; JSON.parse(response.response);<br>            var items &#x3D; response.Data;<br>            if (items &#x3D;&#x3D; null) {<br>                $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">UUYP出租：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);<br>                return;<br>            }<br>            for (var i &#x3D; 0; i &lt; items.length; i++) {<br>                var item &#x3D; items[i];<br>                var name &#x3D; item.CommodityName;<br>                if (Trim(name) &#x3D;&#x3D; Trim(itemName)) {<br>                    var url &#x3D; ‘<a href="http://www.youpin898.com/goodInfo?id=">http://www.youpin898.com/goodInfo?id=</a>‘ + item.Id;<br>                    var sum &#x3D; item.OnLeaseCount;<br>                    var short_price &#x3D; item.LeaseUnitPrice;<br>                    var long_price &#x3D; item.LongLeaseUnitPrice;<br>                    &#x2F;&#x2F;var shortPricePercent &#x3D; parseFloat(short_price * 8 *365 &#x2F; 16 &#x2F; &#x2F; steamPrice).toFixed(2);<br>                    &#x2F;&#x2F;var longPricePercent &#x3D; parseFloat(price &#x2F; steamPrice).toFixed(2);<br>                    $(li).html(‘<a href="' + url + '" style="padding: 0px"><span class="myTitle">悠悠</span>‘ + ‘出租：<span class="mySum">‘ + sum + ‘</span>短租：<span class="myPrice">¥’ + short_price + ‘/天</span>长租：<span class="myPrice">¥’ + long_price + ‘/天</span></a>‘);<br>                    return;<br>                }<br>            }<br>            $(li).html(‘<a href="javascript:return false;" style="padding: 0px"><span class="myTitle">悠悠出租：</span><span style="color: #FF0000">查找不到数据！</span></a>‘);<br>        }<br>    });<br>}</p>
<p>function c5() {<br>    console.log(“–start–”);</p>
<p>$(‘.list’).on(‘mouseenter’, ‘div:not(.el-col)’, function () { &#x2F;&#x2F; 选择不包含c5li类的li，否则会嵌套触发事件<br>    if ($(this).find(‘li’).length &gt; 0) {<br>        $(this).find(‘li’).css(‘max-height’, ‘none’);<br>        $(this).find(‘li’).css(‘overflow’, ‘visible’);<br>        return;<br>    }</p>
<p>​    $(this).attr(‘mouseover’, ‘true’);   &#x2F;&#x2F;当前鼠标在该物品上<br>​    &#x2F;&#x2F;新创建一个列表来存放各个饰品网站的相同物品数据<br>​    &#x2F;&#x2F; var list &#x3D; $(‘<ul class="rm-menu rm-css-animate rm-menu-expanded" aria-hidden="false" style="max-height: 0px; display: block; overflow: hidden; padding: 0px; position: absolute; z-index: 999999; left:-0.125em; top: -1px;"></ul>‘);<br>​    var list &#x3D; $(‘<ul class="c5-dropdown-content" style="max-height: 0px; display: block; overflow: hidden; padding: 0px; position: absolute; z-index: 999999; left:-0.125em; top: -1px;"></ul>‘);<br>​    var itemName &#x3D; $(this).find(‘h4’)[0].outerText; &#x2F;&#x2F;获取该物品的名字<br>​    &#x2F;&#x2F;var itemName &#x3D; $(this).find(‘h4’)[0].textContent;</p>
<p>​    var youpinURL &#x3D; ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘<br>​    var youpin_buyLi &#x3D; $(‘<li class="rm-menu-item c5li" style="height: 25px;"><span class="myTitle">悠悠出售：</span><span>载入中…</li>‘);<br>​    $(list).append(youpin_buyLi);<br>​    addyoupin_buy(youpinURL, youpin_buyLi, itemName);  &#x2F;&#x2F;获取悠悠有品上出售的数据</p>
<p>​    var buffURL &#x3D; ‘<a href="https://buff.163.com/api/market/goods?game=csgo&page_num=1&search=">https://buff.163.com/api/market/goods?game=csgo&amp;page_num=1&amp;search=</a>‘ + itemName.trim() + ‘&amp;_&#x3D;’ + (new Date()).valueOf().toString();<br>​    var buffLi &#x3D; $(‘<li class="rm-menu-item c5li" style="height: 25px;"><span class="myTitle">BUFF：</span><span>载入中…</li>‘);<br>​    $(list).append(buffLi);<br>​    addBUFF(buffURL, buffLi, itemName);  &#x2F;&#x2F;获取BUFF上的数据</p>
<p>​    &#x2F;&#x2F;var v5URL &#x3D; ‘<a href="https://www.v5fox.com/csgo/0-0?keyword=">https://www.v5fox.com/csgo/0-0?keyword=</a>‘ + itemName;<br>​    &#x2F;&#x2F;var v5Li &#x3D; $(‘<li class="rm-menu-item c5li" style="height: 25px;"><span class="myTitle">V5FOX：</span><span>载入中…</li>‘);<br>​    &#x2F;&#x2F;$(list).append(v5Li);<br>​    &#x2F;&#x2F;addV5(v5URL, v5Li, itemName);  &#x2F;&#x2F;获取V5FOX上的数据</p>
<p>​    if ($(this).attr(‘mouseover’) &#x3D;&#x3D; ‘true’) {   &#x2F;&#x2F;若鼠标还在该物品上就不隐藏刚创建的列表<br>​        $(list).css(‘max-height’, ‘none’);<br>​        $(list).css(‘overflow’, ‘visible’);<br>​    }<br>​    $(this).append(list);<br>​    $(‘.csgo-list li’).css(‘overflow’, ‘visible’); &#x2F;&#x2F; 这个css属性如果不修改则字不能溢出显示<br>});</p>
<p>&#x2F;&#x2F;$(‘.list’).on(‘mouseleave’, ‘div:not(.el-col)’, function () { &#x2F;&#x2F; 选择不包含c5li类的li，否则会嵌套触发事件<br>$(‘.list’).on(‘mouseleave’, ‘el-col’, function () { &#x2F;&#x2F; 选择不包含c5li类的li，否则会嵌套触发事件<br>    if ($(this).find(‘li’).length &gt; 0) {<br>        $(this).find(‘li’).css(‘max-height’, ‘0px’);<br>        $(this).find(‘li’).css(‘overflow’, ‘hidden’);<br>        $(this).attr(‘mouseover’, ‘false’);<br>    }<br>});</p>
<p>}</p>
<p>function igxe() {<br>    $(‘.list’).on(‘mouseenter’, ‘a.item’, function () {<br>        if ($(this).find(‘div.igxe-dropdown-content’).length &gt; 0) {<br>            $(this).find(‘div.igxe-dropdown-content’).css(‘display’, ‘block’);<br>            return;<br>        }</p>
<p>​    $(this).css({<br>​        display: ‘inline - block’<br>​    });<br>​    $(this).attr(‘mouseover’, ‘true’);   &#x2F;&#x2F;当前鼠标在该物品上</p>
<p>​    var list &#x3D; $(‘<ul class="igxe-dropdown-content"></ul>‘);<br>​    var itemName &#x3D; $(this).find(‘div.name’).text();</p>
<p>​    &#x2F;&#x2F;var c5URL &#x3D; ‘<a href="https://www.c5game.com/csgo/default/result.html?k=">https://www.c5game.com/csgo/default/result.html?k=</a>‘ + itemName + ‘&amp;page&#x3D;1’;<br>​    var c5URL &#x3D; ‘<a href="https://www.c5game.com/csgo?keyword=">https://www.c5game.com/csgo?keyword=</a>‘ + itemName + ‘&amp;page&#x3D;1’;<br>​    console.log(c5URL)<br>​    var c5Li &#x3D; $(‘<li class="igli"><span class="myTitle">C5：</span><span>载入中…</li>‘);<br>​    $(list).append(c5Li);<br>​    addC5(c5URL, c5Li, itemName);  &#x2F;&#x2F;获取C5上的数据</p>
<p>​    var buffURL &#x3D; ‘<a href="https://buff.163.com/api/market/goods?game=csgo&page_num=1&search=">https://buff.163.com/api/market/goods?game=csgo&amp;page_num=1&amp;search=</a>‘ + itemName.trim() + ‘&amp;_&#x3D;’ + (new Date()).valueOf().toString();<br>​    var buffLi &#x3D; $(‘<li class="igli"><span class="myTitle">BUFF：</span><span>载入中…</li>‘);<br>​    $(list).append(buffLi);<br>​    addBUFF(buffURL, buffLi, itemName);  &#x2F;&#x2F;获取BUFF上的数据</p>
<p>​    var youpinURL &#x3D; ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘<br>​    var youpin_buyLi &#x3D; $(‘<li class="igli" style="height: 25px;"><span class="myTitle">悠悠出售：</span><span>载入中…</li>‘);<br>​    $(list).append(youpin_buyLi);<br>​    addyoupin_buy(youpinURL, youpin_buyLi, itemName);  &#x2F;&#x2F;获取悠悠有品上出售的数据</p>
<p>​      </p>
<p>​    if ($(this).attr(‘mouseover’) &#x3D;&#x3D; ‘true’) {   &#x2F;&#x2F;若鼠标还在该物品上就不隐藏刚创建的列表<br>​        $(list).css(‘display’, ‘block’);<br>​    }<br>​    $(this).append(list);<br>});</p>
<p>$(‘.list’).on(‘mouseleave’, ‘a.item’, function () {<br>    if ($(this).find(‘ul.igxe-dropdown-content’).length &gt; 0) {<br>        $(this).find(‘ul.igxe-dropdown-content’).css(‘display’, ‘none’);<br>        return;<br>    }<br>    $(this).attr(‘mouseover’, ‘false’);<br>});</p>
<p>}</p>
<p>function buff() {<br>    $(‘#j_market_card’).on(‘mouseenter’, ‘#j_list_card li:not([class])’, function () {<br>        if ($(this).find(‘div.buff-dropdown-content’).length &gt; 0) {<br>            $(this).find(‘div.buff-dropdown-content’).css(‘display’, ‘block’);<br>            return;<br>        }</p>
<p>​    $(this).css({<br>​        display: ‘inline - block’<br>​    });<br>​    $(this).attr(‘mouseover’, ‘true’);   &#x2F;&#x2F;当前鼠标在该物品上</p>
<p>​    var list &#x3D; $(‘<div class="buff-dropdown-content"></div>‘);<br>​    var itemName &#x3D; $(this).find(‘a:first’).attr(‘title’);</p>
<p>​    var youpinURL &#x3D; ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘<br>​    var youpin_buyLi &#x3D; $(‘<li class="buffli" style="height: 25px;"><span class="myTitle">悠悠出售：</span><span>载入中…</li>‘);<br>​    $(list).append(youpin_buyLi);<br>​    addyoupin_buy(youpinURL, youpin_buyLi, itemName);  &#x2F;&#x2F;获取悠悠有品上出售的数据</p>
<p>​     </p>
<p>​    if ($(this).attr(‘mouseover’) &#x3D;&#x3D; ‘true’) {   &#x2F;&#x2F;若鼠标还在该物品上就不隐藏刚创建的列表<br>​        $(list).css(‘display’, ‘block’);<br>​    }<br>​    $(this).append(list);<br>});</p>
<p>$(‘#j_market_card’).on(‘mouseleave’, ‘#j_list_card li:not([class])’, function () {<br>    if ($(this).find(‘div.buff-dropdown-content’).length &gt; 0) {<br>        $(this).find(‘div.buff-dropdown-content’).css(‘display’, ‘none’);<br>        return;<br>    }<br>    $(this).attr(‘mouseover’, ‘false’);<br>});</p>
<p>}</p>
<p>function v5fox() {<br>    $(‘.list-box’).on(‘mouseenter’, ‘a.list-item’, function () {<br>        if ($(this).find(‘div.v5-dropdown-content’).length &gt; 0) {<br>            $(this).find(‘div.v5-dropdown-content’).css(‘display’, ‘block’);<br>            return;<br>        }</p>
<p>​    $(this).css({<br>​        display: ‘inline - block’<br>​    });<br>​    $(this).attr(‘mouseover’, ‘true’);   &#x2F;&#x2F;当前鼠标在该物品上</p>
<p>​    var list &#x3D; $(‘<div class="v5-dropdown-content"></div>‘);<br>​    var itemName &#x3D; $(this).attr(‘title’);</p>
<p>​        </p>
<p>​    var buffURL &#x3D; ‘<a href="https://buff.163.com/api/market/goods?game=csgo&page_num=1&search=">https://buff.163.com/api/market/goods?game=csgo&amp;page_num=1&amp;search=</a>‘ + itemName.trim() + ‘&amp;_&#x3D;’ + (new Date()).valueOf().toString();<br>​    var buffLi &#x3D; $(‘<li class="v5li"><a href="javascript:return false;" style="padding: 0px"><span class="myTitle">BUFF：</span><span>载入中…</a></li>‘);<br>​    $(list).append(buffLi);<br>​    addBUFF(buffURL, buffLi, itemName);  &#x2F;&#x2F;获取BUFF上的数据</p>
<p>​      </p>
<p>​    var youpinURL &#x3D; ‘<a href="https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList">https://api.youpin898.com/api/homepage/es/template/GetCsGoPagedList</a>‘<br>​    var youpin_buyLi &#x3D; $(‘<li class="v5li" style="height: 25px;"><span class="myTitle">悠悠出售：</span><span>载入中…</li>‘);<br>​    $(list).append(youpin_buyLi);<br>​    addyoupin_buy(youpinURL, youpin_buyLi, itemName);  &#x2F;&#x2F;获取悠悠有品上出售的数据</p>
<p>​       </p>
<p>​    if ($(this).attr(‘mouseover’) &#x3D;&#x3D; ‘true’) {   &#x2F;&#x2F;若鼠标还在该物品上就不隐藏刚创建的列表<br>​        $(list).css(‘display’, ‘block’);<br>​    }<br>​    $(this).append(list);<br>});</p>
<p>$(‘.list-box’).on(‘mouseleave’, ‘a.list-item’, function () {<br>    if ($(this).find(‘div.v5-dropdown-content’).length &gt; 0) {<br>        $(this).find(‘div.v5-dropdown-content’).css(‘display’, ‘none’);<br>        return;<br>    }<br>    $(this).attr(‘mouseover’, ‘false’);<br>});</p>
<p>}</p>
<p>function youpin() {<br>    $(‘.goods-list’).on(‘mouseenter’, ‘.good-box’, function () {<br>        if ($(this).find(‘div.youpin-dropdown-content’).length &gt; 0) {<br>            $(this).find(‘div.youpin-dropdown-content’).css(‘display’, ‘block’);<br>            return;<br>        }</p>
<p>​    $(this).css({<br>​        display: ‘inline - block’<br>​    });<br>​    $(this).attr(‘mouseover’, ‘true’);   &#x2F;&#x2F;当前鼠标在该物品上</p>
<p>​    var list &#x3D; $(‘<div class="youpin-dropdown-content"></div>‘);<br>​    var itemName &#x3D; $(this).attr(‘title’);</p>
<p>​        </p>
<p>​    var buffURL &#x3D; ‘<a href="https://buff.163.com/api/market/goods?game=csgo&page_num=1&search=">https://buff.163.com/api/market/goods?game=csgo&amp;page_num=1&amp;search=</a>‘ + itemName.trim() + ‘&amp;_&#x3D;’ + (new Date()).valueOf().toString();<br>​    var buffLi &#x3D; $(‘<li class="youpinli"><a href="javascript:return false;" style="padding: 0px"><span class="myTitle">BUFF：</span><span>载入中…</a></li>‘);<br>​    $(list).append(buffLi);<br>​    addBUFF(buffURL, buffLi, itemName);  &#x2F;&#x2F;获取BUFF上的数据</p>
<p>​      </p>
<p>​     </p>
<p>​    if ($(this).attr(‘mouseover’) &#x3D;&#x3D; ‘true’) {   &#x2F;&#x2F;若鼠标还在该物品上就不隐藏刚创建的列表<br>​        $(list).css(‘display’, ‘block’);<br>​    }<br>​    $(this).append(list);<br>});</p>
<p>$(‘.goods-list’).on(‘mouseleave’, ‘div.good-box’, function () {<br>    if ($(this).find(‘div.youpin-dropdown-content’).length &gt; 0) {<br>        $(this).find(‘div.youpin-dropdown-content’).css(‘display’, ‘none’);<br>        return;<br>    }<br>    $(this).attr(‘mouseover’, ‘false’);<br>});</p>
<p>}</p>
<h1 id="CSGO逆天改名"><a href="#CSGO逆天改名" class="headerlink" title="CSGO逆天改名"></a>CSGO逆天改名</h1><pre><code>快和多娜一起来干坏事吧~好舒服~啊

樱岛麻衣让射准点 不要搞得到处都是

不~带~套~更~持~久~

射到你马出彩

阳光射不到的地方，欧尼酱可以哦

掐着你脖子说爱你

来做我的小公主，只吃√8不吃苦

犬子随父征，父死子承枪

走开！女孩子是守不住B的！！

甜甜的女孩也有咸咸的地方

马走日，象走田，愿君如马，走哪日哪
</code></pre>
<h1 id="CS2跑图cfg"><a href="#CS2跑图cfg" class="headerlink" title="CS2跑图cfg"></a>CS2跑图cfg</h1><p>新建txt输入以下内容，再改文件后缀为.cfg即可，要放入csgo的cfg文件里。</p>
<p>sv_cheats 1                                                         &#x2F;&#x2F;作弊模式开启<br>god                                                                    &#x2F;&#x2F;无敌<br>sv_infinite_ammo 2                                             &#x2F;&#x2F;无限弹药<br>ammo_grenade_limit_total 5                               &#x2F;&#x2F;投掷物最大携带数量<br>mp_warmup_end                                                &#x2F;&#x2F;热身时间结束<br>mp_freezetime 0                                                 &#x2F;&#x2F;开局冻结时间<br>mp_roundtime 60                                               &#x2F;&#x2F;每局时间（分钟）<br>mp_roundtime_defuse 60                                   &#x2F;&#x2F;竞技模式回合时长60分钟<br>&#x2F;&#x2F;sv_grenade_trajectory_time 10<br>sv_grenade_trajectory_prac_trailtime 8                 &#x2F;&#x2F;投掷物回放轨迹显示时间<br>bind “-“ “ cl_sim_grenade_trajectory 10”              &#x2F;&#x2F;保存轨迹线 自定义时间<br>bind “x” “sv_rethrow_last_grenade”                    &#x2F;&#x2F; 投掷物重复丢<br>sv_showimpacts 2                                               &#x2F;&#x2F;显示着弹点<br>mp_limitteams 0                                                 &#x2F;&#x2F;队伍人数限制关闭<br>mp_autoteambalance 0                                      &#x2F;&#x2F;队伍平衡关闭<br>mp_maxmoney 60000                                         &#x2F;&#x2F;最大金钱<br>mp_startmoney 16000                                        &#x2F;&#x2F;启示资金<br>mp_buytime 9999&#x2F;&#x2F;购买时间<br>mp_buy_anywhere 1                                          &#x2F;&#x2F;任何地方购买<br>mp_restartgame 1                                             &#x2F;&#x2F;刷新<br>bot_stop 1                                                        &#x2F;&#x2F;bot静止<br>bind “p” “bot_place”                                         &#x2F;&#x2F; 按p放置bot<br>bind “n” “noclip”                                              &#x2F;&#x2F;按n飞天</p>
<p>&#x2F;&#x2F;投掷物准心绑定鼠标后侧键<br>&#x2F;&#x2F;bind “mouse5” “+crosshair_throw”	&#x2F;&#x2F;前侧键按住投掷物准心，松开还原（改动）<br>&#x2F;&#x2F;alias “+crosshair_throw” “exec crosshair_throw.cfg”<br>&#x2F;&#x2F;alias “-crosshair_throw” “exec crosshairp.cfg”</p>
]]></content>
      <tags>
        <tag>CSGO</tag>
        <tag>Steam</tag>
        <tag>Buff</tag>
      </tags>
  </entry>
  <entry>
    <title>制作鬼畜视频/特效视频等等</title>
    <url>/2024/04/13/CreateVideo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于时间限制，暂时先写一下这些视频是制作原理和使用的工具、步骤，然后根据原理是可以很快的制作出各位脑中想象的作品。但凡是个正常人，花点时间肯定能做出来的噢。不会有人知道怎么做，但是动手做不出来吧？</p>
<p>melodyne使用+电音</p>
<p>百万填词技巧</p>
<p>鬼畜技巧</p>
<p>AI换音</p>
<p>公众号管理</p>
<p>视频剪辑+关键帧+其他</p>
<h1 id="鬼畜视频"><a href="#鬼畜视频" class="headerlink" title="鬼畜视频"></a>鬼畜视频</h1><h2 id="原理如下："><a href="#原理如下：" class="headerlink" title="原理如下："></a>原理如下：</h2><p>分析好音频BGM的节拍，在每个节拍出添加自己需要的音频，然后通过调音软件进行调音，然后就完成了一个鬼畜的调音填词。工作量很大，技术要求也挺高的。</p>
<h2 id="具体步骤大致为："><a href="#具体步骤大致为：" class="headerlink" title="具体步骤大致为："></a>具体步骤大致为：</h2><h3 id="选曲"><a href="#选曲" class="headerlink" title="选曲"></a>选曲</h3><h3 id="填词"><a href="#填词" class="headerlink" title="填词"></a>填词</h3><h3 id="分析BGM的节拍"><a href="#分析BGM的节拍" class="headerlink" title="分析BGM的节拍"></a>分析BGM的节拍</h3><h3 id="使用AU-RX10-Vegas-medyne进行音频修改"><a href="#使用AU-RX10-Vegas-medyne进行音频修改" class="headerlink" title="使用AU+RX10+Vegas+medyne进行音频修改"></a>使用AU+RX10+Vegas+medyne进行音频修改</h3><h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><h1 id="AI换音视频"><a href="#AI换音视频" class="headerlink" title="AI换音视频"></a>AI换音视频</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用Sovits进行AI换音，很容易实现音源更换，什么活字印刷的动漫、AI剑魔等都可以这样换词换音，具体操作查看其它文档。</p>
<h1 id="百万填词"><a href="#百万填词" class="headerlink" title="百万填词"></a>百万填词</h1><p>步骤和鬼畜视频类似，工作量很大，视频效果很好。就是针对medyne和AU调整音频要求要高很多。</p>
<p>选曲</p>
<p>填词</p>
<p>分析BGM的节拍</p>
<p>使用AU+RX10+Vegas+medyne进行音频修改</p>
<p>成品</p>
]]></content>
      <categories>
        <category>视频</category>
        <category>鬼畜</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>鬼畜</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D笔记</title>
    <url>/2024/06/15/Unity3D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Unity3D笔记"><a href="#Unity3D笔记" class="headerlink" title="Unity3D笔记"></a>Unity3D笔记</h1><p>有许多bug解决过程，由于精力不够，有空再写了。</p>
<p>个人2D小游戏演示视频：<a href="https://www.bilibili.com/video/BV1YahveoEgS/?spm_id_from=333.999.top_right_bar_window_dynamic.content.click&vd_source=c3c474de41290d1ca95c9b0c44da623c">Unity-2D小游戏设计_哔哩哔哩bilibili</a></p>
<h2 id="1-如何优化move手感"><a href="#1-如何优化move手感" class="headerlink" title="1.如何优化move手感"></a>1.如何优化move手感</h2><p>区别在于：Input.GetAxis和Input.GetAxisRaw两个函数的返回值不一样，</p>
<p>Input.GetAxis：返回值 -1~1</p>
<p>Input.GetAxisRaw：返回值 -1，0，1</p>
<ul>
<li><strong>平滑处理</strong>: 如果你希望输入有更平滑的过渡（例如角色移动起来不要过于突然），那么使用 <code>Input.GetAxis</code> 更合适。</li>
<li><strong>即时反馈</strong>: 如果你需要即按即得的响应，那么 <code>Input.GetAxisRaw</code> 是更好的选择。</li>
</ul>
<p>总的来说，<code>Input.GetAxisRaw</code> 提供了更加直接和即时的输入数据，适用于需要快速和精确响应的场景，而 <code>Input.GetAxis</code> 则因其平滑处理在某些情况下更适合提供较好的用户体验。</p>
<pre><code>    private void Move()
    &#123;   
        //anim.SetFloat(&quot;speed&quot;, Mathf.Abs(moveX));//Mathf.Abs取绝对值
    moveX = Input.GetAxis(&quot;Horizontal&quot;);

    rb.velocity = new Vector2(moveX * playerSpeed, rb.velocity.y);
    if(facingRight==false&amp;&amp;moveX&gt;0)
        Flip();
    if(facingRight==true&amp;&amp;moveX&lt;0)
        Flip();
&#125;
</code></pre>
<h2 id="2-如何优化跳跃手感"><a href="#2-如何优化跳跃手感" class="headerlink" title="2.如何优化跳跃手感"></a>2.如何优化跳跃手感</h2><p>参考马里奥的跳跃，在人物跳跃上行的时候和下行的时候给人物的刚体添加力的作用，无论是增加重力、减少重力还是使用Addforce函数都可以。</p>
<p>用于对rigidbody组件对象添加力的作用。<br>其参数决定了添加力的作用方式，因此参数不同，其获得的效果（动量、动能）也不同。<br>另外unity重力加速度默认为9.81左右，随着物体的状况会有改变。</p>
<pre><code>     public float fallAddition=3f;//下落重力加成
    public float jumpAddition=0f;//跳跃重力加成
     -----------------------------------------------------------------------------
     if (rb.velocity.y &lt; -0.1f)
        &#123;
            rb.gravityScale = fallAddition;
        &#125;
        else if (rb.velocity.y &gt; 0.1f &amp;&amp; jumpHold)
        &#123;
            rb.gravityScale = jumpAddition;
            &#125;
    else if(rb.velocity.y &gt; 0.1f &amp;&amp; !isJump)
        rb.gravityScale = 1f;
</code></pre>
<h2 id="3-Unity-PS"><a href="#3-Unity-PS" class="headerlink" title="3.Unity+PS"></a>3.Unity+PS</h2><p>可以用ps制作游戏内的资源图片导入Unity里面就行。具体步骤和问题如下：</p>
<p>1.Ps使用取色器取色，然后设置空白图层，比如32*32的，然后用画笔设计自己需要的图案，最后导出到Assets文件下。</p>
<p>2.同样的，可以在网上找一些扣好的图（最好自己设计了）导入，加入刚体组件等等，</p>
<p>3.最后记得添加到对应的图层、添加相应的组件、父类。</p>
<h2 id="4-panel画布不显示在game窗口"><a href="#4-panel画布不显示在game窗口" class="headerlink" title="4.panel画布不显示在game窗口"></a>4.panel画布不显示在game窗口</h2><p>1.画布的layout是否和相机在同一个layout上，</p>
<p>2.可能是放置文字的位置被其他物品挡住了，用Unity3D的3D视角查看panel位置上是否有物品遮挡。</p>
<h2 id="5-多个动画使用enum进行优化"><a href="#5-多个动画使用enum进行优化" class="headerlink" title="5.多个动画使用enum进行优化"></a>5.多个动画使用enum进行优化</h2><p>主要思路：比如跑、跳、下坠、静止的四个动画在写在enum中，使用int类型的state标签好动画，在各个状态中自由更换动画，记得取消动画必须播放完这个选项。</p>
<p>还有一个好处，添加其他动画的时候也能在enum中直接添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private enum playerState &#123; Idle, Run, Jump, Fall ,DoubleJump&#125;;//枚举所有的角色状态</span><br><span class="line"></span><br><span class="line">void playerAnim()</span><br><span class="line">   &#123;</span><br><span class="line">       playerState states;</span><br><span class="line">       if (Mathf.Abs(moveX) &gt; 0.1f)</span><br><span class="line">       &#123;</span><br><span class="line">           states=playerState.Run;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">           states = playerState.Idle;</span><br><span class="line">       &#125;</span><br><span class="line">       if(rb.velocity.y &gt; 0.1f)</span><br><span class="line">       &#123;</span><br><span class="line">           states=playerState.Jump;</span><br><span class="line">       &#125;</span><br><span class="line">       else if(rb.velocity.y &lt; -0.1f)</span><br><span class="line">       &#123;</span><br><span class="line">           states=playerState.Fall;</span><br><span class="line">       &#125;</span><br><span class="line">       if (moveJump||jumpHold&amp;&amp;rb.velocity.y!=0&amp;&amp;jumpCount&lt;1)</span><br><span class="line">       &#123;</span><br><span class="line">           states = playerState.DoubleJump;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       anim.SetInteger(&quot;state&quot;, (int)states);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-根据layout图层查找这个图层有多少个物品"><a href="#6-根据layout图层查找这个图层有多少个物品" class="headerlink" title="6.根据layout图层查找这个图层有多少个物品"></a>6.根据layout图层查找这个图层有多少个物品</h2><p>比如根据这个查找boss数量，boss<code>具有</code>Empty<code>图层，你可以通过遍历场景中的所有游戏对象，检查它们是否具有附加在</code>Empty<code>图层上的特定组件或属性，来确定</code>boss&#96;的数量。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Countboss</span>()<span class="comment">//计算场景中在 empty 图层上的 boss 数量</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">int</span> bossCount = <span class="number">0</span>;</span><br><span class="line">            GameObject[] allObjects = UnityEngine.Object.FindObjectsOfType&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (GameObject obj <span class="keyword">in</span> allObjects)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 检查对象是否具有 BossComponent 组件并且在 Empty 图层上</span></span><br><span class="line">                <span class="keyword">if</span> ( obj.layer == LayerMask.NameToLayer(<span class="string">&quot;enemy&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    bossCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bossCount;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Enemy</span>()<span class="comment">//敌人</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Collider2D enemy =Physics2D.OverlapCircle(killPoint.position, <span class="number">0.2f</span>,LayerMask.GetMask(<span class="string">&quot;enemy&quot;</span>));<span class="comment">//原点位置，半径，碰撞层</span></span><br><span class="line">        <span class="keyword">if</span> (enemy == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Destroy(enemy.gameObject);</span><br><span class="line"></span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(rb.velocity.x, <span class="number">0f</span>);</span><br><span class="line">        rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0f</span>, <span class="number">200f</span>));<span class="comment">//弹起</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-跳跃敌人头部弹起，优化手感"><a href="#7-跳跃敌人头部弹起，优化手感" class="headerlink" title="7.跳跃敌人头部弹起，优化手感"></a>7.跳跃敌人头部弹起，优化手感</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Enemy()//敌人</span><br><span class="line">    &#123;</span><br><span class="line">        Collider2D enemy =Physics2D.OverlapCircle(killPoint.position, 0.2f,LayerMask.GetMask(&quot;enemy&quot;));//原点位置，半径，碰撞层</span><br><span class="line">        if (enemy == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        	Destroy(enemy.gameObject);</span><br><span class="line">            rb.velocity = new Vector2(rb.velocity.x, 0f);</span><br><span class="line">    		rb.AddForce(new Vector2(0f, 200f));//弹起</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8-切换不同场景-传送门"><a href="#8-切换不同场景-传送门" class="headerlink" title="8.切换不同场景&#x2F;传送门"></a>8.切换不同场景&#x2F;传送门</h2><p>1.要贴图，添加图层，触发器√</p>
<p>2.部分代码实现，door和人物player接触既可触发场景切换和音乐暂停等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.tag == &quot;player&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            finishSund.Play();</span><br><span class="line">            Invoke(&quot;FinishS1&quot;, 1f);//一秒后切换场景</span><br><span class="line">            Debug.Log(&quot;Door&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">private void FinishS1()//切换场景</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);</span><br><span class="line">        SaveData()；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-相机跟随人物"><a href="#9-相机跟随人物" class="headerlink" title="9.相机跟随人物"></a>9.相机跟随人物</h2><p>下载Unity的扩展Virtual Camera，导入场景后，可以根据自己喜欢设置跟随速度和跟随方式。</p>
<p>另外游戏背景音乐什么的，可以添加到相机中，方便管理。</p>
<h2 id="10-不同场景数据互通"><a href="#10-不同场景数据互通" class="headerlink" title="10.不同场景数据互通"></a>10.不同场景数据互通</h2><p>使用静态类型数据。</p>
<pre><code>public class Globalint : MonoBehaviour
&#123;
public static Globalint Instance;

//要保存使用的数据;
public int HP=100;
public int POWER= 10;
public int Bananas=0;

//初始化
private void Awake()
 &#123;
    if (Instance == null)
    &#123;
        DontDestroyOnLoad(gameObject);
        Instance = this;
    &#125;
    else if (Instance != null)
    &#123;
        Destroy(gameObject);
    &#125;
 &#125;
｝
</code></pre>
<h2 id="11-game窗口的粒子特效问题"><a href="#11-game窗口的粒子特效问题" class="headerlink" title="11.game窗口的粒子特效问题"></a>11.game窗口的粒子特效问题</h2><p>主要是Unity的粒子特效组件的设置问题，比如layout范围、粒子发散方向、粒子数量、布局范围，这个布局范围有好几个要设置成“世界”，否则可能会在game窗口看不见你的粒子特效。主要还是下面三个问题：</p>
<ol>
<li><strong>未正确添加或设置 <code>Particle</code> 组件</strong>：确保在人物的游戏对象上正确添加了 <code>Particle System</code> 组件。可以通过选择人物对象，在 Inspector 面板中查看是否有该组件存在，并检查其相关参数设置是否符合预期。</li>
<li>缺少触发调用的条件或事件：粒子系统的播放通常需要通过某种条件或事件来触发。检查是否在适当的时机（例如特定的游戏逻辑、动画事件、输入操作等）触发了粒子系统的播放。可以在相关的脚本中添加代码来调用粒子系统的播放方法，例如 <code>ParticleSystem.Play()</code> 。</li>
<li>脚本中的引用问题：如果通过脚本控制粒子系统，确保在脚本中正确获取了人物对象上的 <code>Particle</code> 组件的引用。</li>
</ol>
<h2 id="12-地面检测失败"><a href="#12-地面检测失败" class="headerlink" title="12.地面检测失败"></a>12.地面检测失败</h2><p>主要是layout布局是否正确，以及是否勾选trigger（触发器）等设置，代码方面一般都不会有问题。</p>
<h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2>]]></content>
      <categories>
        <category>C#</category>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
</search>
